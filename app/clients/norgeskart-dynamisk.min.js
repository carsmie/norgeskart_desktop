"use strict";

var NK = NK || {};
NK.mapEventListeners = {};

var gkopen, 
    gkopen_wmts,
    proj,
    mapProj,
    mapBounds,
    xdmsocket,
    initLayers,
    postEvent,
    map;

gkopen = "http://opencache.statkart.no/gatekeeper/gk/gk.open";
gkopen_wmts = "http://opencache.statkart.no/gatekeeper/gk/gk.open_wmts";

NK.gkToken = "unInitialized";
NK.encTicket = "unInitialized";

NK.tokenService = "/ws/gkt.py";

NK.ticketService = "/ws/esk.py?wms.ecc_enc";

NK.baseProjection = "32633";
NK.baseProjection = "32633";

NK.tokenLastUpdated = new Date(0);
NK.ticketLastUpdated = new Date(0);
NK.tokenUpdatePaused = false;
NK.ticketUpdatePaused = false;


NK.tokenError = {
  PAUSE_MINUTES: 2,
  RELOAD_LIMIT_SECONDS: 15,
  messagePopup: null,
  pauseTimeRemainingElement: null,
  pauseTimeRemainingText: null,
  pauseTimer: null,
  pauseCountdownTimer: null
};
NK.ticketError = {
  PAUSE_MINUTES: 2,
  RELOAD_LIMIT_SECONDS: 15,
  messagePopup: null,
  pauseTimeRemainingElement: null,
  pauseTimeRemainingText: null,
  pauseTimer: null,
  pauseCountdownTimer: null
};



NK.mapservers = {};
NK.mapservers.wmts = [
  "http://gatekeeper1.geonorge.no/BaatGatekeeper/gk/gk.cache_wmts",
  "http://gatekeeper2.geonorge.no/BaatGatekeeper/gk/gk.cache_wmts",
  "http://gatekeeper3.geonorge.no/BaatGatekeeper/gk/gk.cache_wmts"
];
NK.zoomLevels = 18;

NK.functions = NK.functions || {};

NK.functions.resetTokenError = function () {
  if (NK.tokenError.pauseTimeRemainingElement) {
    NK.tokenError.pauseTimeRemainingElement.parentNode.removeChild(NK.tokenError.pauseTimeRemainingElement);
    NK.tokenError.pauseTimeRemainingElement = null;
  }
  if (NK.tokenError.messagePopup) {
    NK.tokenError.messagePopup.parentNode.removeChild(NK.tokenError.messagePopup);
    NK.tokenError.messagePopup = null;
  }
  if (NK.tokenError.pauseTimer) {
    clearTimeout(NK.tokenError.pauseTimer);
    NK.tokenError.pauseTimer = null;
  }
  if (NK.tokenError.pauseCountdownInterval) {
    clearInterval(NK.tokenError.pauseCountdownInterval);
    NK.tokenError.pauseCountdownInterval = null;
  }
};

NK.functions.resetTicketError = function () {
  if (NK.ticketError.pauseTimeRemainingElement) {
    NK.ticketError.pauseTimeRemainingElement.parentNode.removeChild(NK.ticketError.pauseTimeRemainingElement);
    NK.ticketError.pauseTimeRemainingElement = null;
  }
  if (NK.ticketError.messagePopup) {
    NK.ticketError.messagePopup.parentNode.removeChild(NK.ticketError.messagePopup);
    NK.ticketError.messagePopup = null;
  }
  if (NK.ticketError.pauseTimer) {
    clearTimeout(NK.ticketError.pauseTimer);
    NK.ticketError.pauseTimer = null;
  }
  if (NK.ticketError.pauseCountdownInterval) {
    clearInterval(NK.ticketError.pauseCountdownInterval);
    NK.ticketError.pauseCountdownInterval = null;
  }
};

NK.functions.updateToken = function (request) {
  var i, 
      j, 
      reloadLimit;

  reloadLimit = new Date(Date.now() - NK.tokenError.RELOAD_LIMIT_SECONDS * 1000);

  NK.gkToken = request.responseText.replace(/[\"\r\n]/g, '');

  if (NK.tokenLastUpdated < reloadLimit) { // was token updated less than RELOAD_LIMIT_SECONDS ago?
    if (!NK.tokenUpdatePaused) {
      NK.functions.resetTokenError();
      NK.tokenLastUpdated = new Date();

      for (i = 0, j = map.layers.length; i < j; i += 1) {
        if (map.layers[i].params && map.layers[i].params.gkt) {
          map.layers[i].params.gkt = NK.gkToken;
          map.layers[i].redraw();
        }
      }
    }
  } else {
    NK.functions.pauseTokenUpdate();
  }
};
NK.functions.updateTicket = function (request) {
  var i,
    j,
    reloadLimit;

  reloadLimit = new Date(Date.now() - NK.ticketError.RELOAD_LIMIT_SECONDS * 1000);

  NK.encTicket = request.responseText.replace(/[\"\r\n]/g, '');

  if (NK.tokenLastUpdated < reloadLimit) { // was token updated less than RELOAD_LIMIT_SECONDS ago?
    if (!NK.ticketUpdatePaused) {
      NK.functions.resetTicketError();
      NK.ticketLastUpdated = new Date();

      for (i = 0, j = map.layers.length; i < j; i += 1) {
        if (map.layers[i].params && map.layers[i].params.ticket) {
          map.layers[i].params.ticket = NK.encTicket;
          map.layers[i].redraw();
        }
      }
    }
  } else {
    NK.functions.pauseTicketUpdate();
  }
};

NK.functions.pauseTokenUpdate = function () {
  if (!NK.tokenUpdatePaused) {
    NK.tokenUpdatePaused = true;

    NK.functions.log(OpenLayers.Lang.translate('Server error') +" - "+ OpenLayers.Lang.translate('An error has occured.'));

    NK.tokenError.pauseTimer = setTimeout(function () {
      NK.tokenUpdatePaused = false;
      NK.functions.getNewToken();
    },  60 * parseInt(NK.tokenError.PAUSE_MINUTES, 10) * 1000);

    NK.tokenError.pauseCountdownInterval = setInterval(function () {
      var content, timeLeft;
      if (NK.tokenError.pauseTimeRemainingElement) {
        content = NK.tokenError.pauseTimeRemainingElement.innerHTML;
        timeLeft = (parseInt(content, 10) - 1);
        NK.tokenError.pauseTimeRemainingElement.innerHTML = timeLeft.toString();
        if (timeLeft === 1) {
          if (NK.tokenError.pauseTimeRemainingText.textContent) {
            NK.tokenError.pauseTimeRemainingText.textContent = ' ' + OpenLayers.Lang.translate('minute.');
          } else {
            // old IE...
            NK.tokenError.pauseTimeRemainingText.innerText = ' ' + OpenLayers.Lang.translate('minute.');
          }
        }
      }
    }, 60 * 1000);
  }
};
NK.functions.pauseTicketUpdate = function () {
  if (!NK.ticketUpdatePaused) {
    NK.ticketUpdatePaused = true;

    NK.functions.log(OpenLayers.Lang.translate('Server error') +" - "+ OpenLayers.Lang.translate('An error has occured.'));

    NK.ticketError.pauseTimer = setTimeout(function () {
      NK.ticketUpdatePaused = false;
      NK.functions.getNewTicket();
    },  60 * parseInt(NK.ticketError.PAUSE_MINUTES, 10) * 1000);

    NK.ticketError.pauseCountdownInterval = setInterval(function () {
      var content, timeLeft;
      if (NK.ticketError.pauseTimeRemainingElement) {
        content = NK.ticketError.pauseTimeRemainingElement.innerHTML;
        timeLeft = (parseInt(content, 10) - 1);
        NK.ticketError.pauseTimeRemainingElement.innerHTML = timeLeft.toString();
        if (timeLeft === 1) {
          if (NK.ticketError.pauseTimeRemainingText.textContent) {
            NK.ticketError.pauseTimeRemainingText.textContent = ' ' + OpenLayers.Lang.translate('minute.');
          } else {
            // old IE...
            NK.ticketError.pauseTimeRemainingText.innerText = ' ' + OpenLayers.Lang.translate('minute.');
          }
        }
      }
    }, 60 * 1000);
  }
};

NK.functions.getNewToken = function () {
  if (NK.gkToken !== null) {
    NK.gkToken = null;
    OpenLayers.Request.GET({url: NK.tokenService, success: NK.functions.updateToken});
  }
};
NK.functions.getNewTicket = function () {
  if (NK.encTicket !== null) {
    NK.encTicket = null;
    OpenLayers.Request.GET({url: NK.ticketService, success: NK.functions.updateTicket});
  }
};

var closePopupCallBack = function () {
  var itemIndex;
  for (itemIndex = 0; itemIndex < map.popups.length; itemIndex++) {
    map.popups[itemIndex].hide();
  }
  this.hide();
};

  
NK.styles = NK.styles || {};
NK.styles.labeledMarker = new OpenLayers.StyleMap(
	{
		'default': new OpenLayers.Style(
			{
				fillOpacity: 1, 
				label : '${getLabel}',
				fontColor: "#fff",
				fontSize: "12px",
				pointRadius: 0,
				fontFamily: "Arial, Courier New, monospace",
				fontWeight: "bold",
				fillColor: "transparent",
				labelAlign: "cm",
				labelXOffset: 11,
				labelYOffset: 33,
				graphicWidth: 44,
				graphicHeight: 56,
				graphicYOffset: -55,
				graphicXOffset: -11,
				externalGraphic: 'data:image/png;base64,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'
			},
			{
				context: {
					getLabel: function (feature) {
					console.dir(feature);
						return feature.attributes.label || '';
					}
				}
			}
		),
		'select': new OpenLayers.Style(
			{
				fillOpacity: 1
			}
		),
		'temporary': new OpenLayers.Style(
			{
				fillOpacity: 1
			}
		)		
	}
);



NK.functions.storeInitialLayerVisibility = function () {
  // store the initial layer visibility configuration
  var i, 
      layer;

  NK.initLayers = [];

  for (i in map.layers) {
    if (map.layers.hasOwnProperty(i)) {
      layer = map.layers[i];
      if (layer.visibility) {
        if ((!NK.defaultVisibleLayers || !$.inArray(layer.shortid, NK.defaultVisibleLayers)) && !layer.isUrlDataLayer) {
          NK.initLayers.push(layer.shortid);
        }
      }
    }
  }
};

NK.functions.setMapStateFromPopState = function (evt) {
  if (evt && evt.originalEvent && evt.originalEvent.state) {
    NK.functions.setMapState({'search': evt.originalEvent.state.search, 'hash': evt.originalEvent.state.hash});
  }
};

$(window).on('popstate', NK.functions.setMapStateFromPopState);

NK.functions.addLabeledMarker = function (params, number, okToHide) {
  var layers, 
      layer, 
      x, 
      y, 
      label,
      feature,
      popup,
      properties,xy, pWSG84, pUTM;

  layers = map.getLayersBy('shortid', 'pekere');
  if (layers.length > 0) {
    layer = layers[0];
  } else {
    layer = new OpenLayers.Layer.Vector("Mark&oslash;rer", {shortid: 'pekere', styleMap: NK.styles.labeledMarker});
    map.addLayer(layer);
  }

  x = params[0];
  y = params[1];

  if ((y > 0) && (y < 35) && (x > 50) && (x < 90)) {  /* we are dealing with WSG84 coordinates here */
    pWSG84 = new Proj4js.Proj('EPSG:4326');
    pUTM = new Proj4js.Proj('EPSG:' + NK.baseProjection);
    xy = Proj4js.transform(pWSG84, pUTM, new Proj4js.Point(y, x));
    x = xy.x;
    y = xy.y;
  }

properties = {};

  if ((params.length > 2) && (!!params[2])) {
    properties.popupText = decodeURIComponent(params[2]);
  }  
  if (number) {
    properties.nr = number;
  } else {
    properties.nr = '';
  }

  feature = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.Point(x, y), properties);

  popup = new OpenLayers.Popup.FramedSideAnchored(
    "nk-user-marker" + (number ? '-' + number : ''), 
    feature.geometry.getBounds().getCenterLonLat(),
    null,
    '<span class="label-text">' + feature.data.popupText + '</span>',
    null, 
    false, 
    null, //onPopupClose
    {x: 10, y: -65},
    'user-marker'
  );

  popup.autoSize = true;
  popup.panMapIfOutOfView = false;

  if (!okToHide || !!feature.data.popupText) {
    feature.popup = popup;
    map.addPopup(popup);
    popup.show();
  }

  layer.addFeatures([feature]);
  return feature;
};

NK.functions.parseParamsAndAddDataLayerFromUrl = function (params) {
  var type,
      url,
      epsgCode;

  type = params[0];
  url = decodeURIComponent(params[1]);
  epsgCode = params[2];

  switch (type) {
    case 'geojson':
      NK.functions.addGeoJsonLayer(url, epsgCode);
      break;
    case 'drawing':
      NK.functions.addGeoJsonLayer(url, epsgCode, {'isDrawing': true});
      break;
  }

};

NK.functions.addGeoJsonLayer = function (url, epsgCode, extensionProperties) {
  var mapProjection,
      formatOptions,
      geoJSONFormat,
      layerOptions,
      layer,
      correctEpsgCode,
      layerExtensions;

  formatOptions = {
    'internalProjection': map.getProjection(),
    'externalProjection': map.getProjection()
  };

  /* set external projection, if provided  */

  if (epsgCode && NK.projections[epsgCode]) {
    formatOptions.externalProjection = NK.projections[epsgCode];
    correctEpsgCode = epsgCode;
  } else {
    correctEpsgCode = NK.baseProjection;
  }

  geoJSONFormat = new OpenLayers.Format.GeoJSON(formatOptions);

  layerOptions = {
    shortid: 'urlDataLayer_' + NK.functions.urlDataLayerCounter, 
    protocol: new OpenLayers.Protocol.HTTP({
      'url': url,
      'format': geoJSONFormat
    }),
    strategies: [new OpenLayers.Strategy.Fixed({preload: true, autoActivate: true})],
    styleMap: NK.styles.track,
    projection: mapProjection,
    displayInLayerSwitcher: false,
    visibility: true
  };

  layer = new OpenLayers.Layer.Vector(
    'urlDataLayer_' + NK.functions.urlDataLayerCounter++,
    layerOptions
  );

  layerExtensions = {
    'isUrlDataLayer': true,
    'epsgCode': correctEpsgCode,
    'url': url
  };

  if (extensionProperties) {
    layerExtensions = OpenLayers.Util.extend(layerExtensions, extensionProperties); 
  }

  layer = OpenLayers.Util.extend(layer, layerExtensions);

  map.addLayers([layer]);
};

NK.functions.urlDataLayerCounter = 0;
NK.functions.setMapState = function (params) {
  var parms,
      zoom,
      mapx,
      mapy,
      xy,
      index,
      extra,
      setLayerVisibility,
      showLayerNamed,
      hideLayerNamed,
      highlight,
      search,
      searchArray,
      searchInputField,
      i, j, p,
      hash,
      labeledMarkerCount = 0,
      pWSG84,
      pUTM33;

  search = params.search;
  hash = params.hash;

  if (params.search) {
    search = search.replace('?', '');
    searchArray = search.split('&');
    for (i = 0, j = searchArray.length; i < j; i += 1) {
      p = searchArray[i].split('=');
      if (p[0] === 'sok') {
        p[1] = decodeURIComponent(p[1]);
        searchInputField = document.getElementById('searchInput');
        if (searchInputField) {
          searchInputField.value = p[1];
        }
        map.events.triggerEvent('searchForPhrase', {'phrase': p[1]});
      }
    }
  }

  if (!!hash) {
    parms = hash.split("/");
    if (parms.length >= 3) {
      zoom = parms[0];
      mapx = parms[1];
      mapy = parms[2];

      if ((mapy > 0) && (mapy < 35) && (mapx > 50) && (mapx < 90)) {  /* we are dealing with WSG84 coordinates here */
        pWSG84 = new Proj4js.Proj('EPSG:4326');   
        pUTM = new Proj4js.Proj('EPSG:'+NK.baseProjection);   
        xy = Proj4js.transform(pWSG84, pUTM, new Proj4js.Point(mapy, mapx));
        mapx = xy.x;
        mapy = xy.y;
      }
    }

    setLayerVisibility = function (layerName, visibility) {
      var i, 
          j,
          layer,
          layerSwitcherPresent;

      layerSwitcherPresent =  map.getControlsByClass('OpenLayers.Control.RasterOverlayLayerSwitcher').length > 0;

      for (i = 0, j = map.layers.length; i < j; i += 1) {
        layer = map.layers[i];
        if (layer.shortid === layerName) {
          if (layerSwitcherPresent && visibility && layer.displayInLayerSwitcher && !layer.isBaseLayer && (layer.CLASS_NAME === "OpenLayers.Layer.WMTS" || layer.CLASS_NAME === "OpenLayers.Layer.WMS")) {
              map.events.triggerEvent('rasterLayerChangeRequest', {'shortId': layerName});
          } else {
            layer.setVisibility(visibility);
          }
        }
      }         
    };

    showLayerNamed = function (layerName) {
      return setLayerVisibility(layerName, true);
    };
    
    hideLayerNamed = function (layerName) {
      return setLayerVisibility(layerName, false);
    };

    highlight = function (highlightParam) {
      var select, 
          layers,
          layer;

      select = highlightParam.slice(1).split("!");
      layers = map.getBy("layers", "shortid", select[0]);

      if (layers.length === 1) {
        layer = layers[0];

        /* set a new renderer rule to highlight elements with the given name */
        layer.styleMap.styles['default'].addRules([
          new OpenLayers.Rule({
            filter: new OpenLayers.Filter.FeatureId({
              fids: [select[1]]
            }),
            symbolizer: {
              strokeWidth: 3,
              strokeColor : "orange",
              graphicZIndex: 2,
              fillColor : "orange",
              fillOpacity: 0.1
            }
          }),
          new OpenLayers.Rule({
            elseFilter: true,
            symbolizer: {}
          })
        ]);

        layer.styleMap.styles.temporary.addRules([
          new OpenLayers.Rule({
            filter: new OpenLayers.Filter.FeatureId({
              fids: [select[1]]
            }),
            symbolizer: {
              strokeWidth: 3,
              strokeColor: "yellow",
              fillColor  : "orange",
              fillOpacity: 0.2,
              graphicZIndex: 100
            }
          }),
          new OpenLayers.Rule({
            elseFilter: true,
            symbolizer: {}
          })
        ]); 
      }
    };

    for (index = 3; index < parms.length; index += 1) {
      extra = parms[index];
      switch (extra.charAt(0)) {
        case '+':
          showLayerNamed(extra.slice(1));
          break;
        case '-':
          hideLayerNamed(extra.slice(1));
          break;
        case '!':
          highlight(extra);
          break;
        case 'm':
          setTimeout(
            (function (boundParameters, boundCounter){
              return function () {
                console.log('boundCounter: ' + boundCounter);
                NK.functions.addLabeledMarker(boundParameters, boundCounter, true);  
              };
            }(parms.slice(index + 1, index + 4), ++labeledMarkerCount)),
            500
          );
          index += 3;
          break;
        case 'l':
          NK.functions.parseParamsAndAddDataLayerFromUrl(parms.slice(index + 1, index + 4));
          index += 3;
          break;
      }
    }
    if (mapx && mapy && zoom) {
      map.setCenter(new OpenLayers.LonLat(mapx, mapy), zoom);
    }
  }
  var result = {
    'x': mapx,
    'y': mapy,
    'zoom': zoom
  };
  return result;
};

NK.functions.setMapStateFromURL = function () {
  // adjust layer visibility and pan/zoom based on hash, if available

  var hash,
      search;

  search = window.location.search;
  hash = window.location.href.split("#")[1]; // avoids window.location.hash because Firefox automatically decodes URI encoded hashes


  return NK.functions.setMapState({'search': search, 'hash': hash});
};



NK.init = function () {

  var prmstr,
      prmarr,
      params,
      tmparr,
      i,
      j;

  if (!OpenLayers || !Proj4js) {
    setTimeout(NK.init, 100);
    return;
  }

  Proj4js.defs["EPSG:4326"] ="+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";
  Proj4js.defs["EPSG:32631"]="+proj=utm +zone=31 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32632"]="+proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32633"]="+proj=utm +zone=33 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32634"]="+proj=utm +zone=34 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32635"]="+proj=utm +zone=35 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32636"]="+proj=utm +zone=36 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:25831"]="+proj=utm +zone=31 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25832"]="+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25833"]="+proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25834"]="+proj=utm +zone=34 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25835"]="+proj=utm +zone=35 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25836"]="+proj=utm +zone=36 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:3575"] ="+proj=laea +lat_0=90 +lon_0=10 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:3034"] ="+proj=lcc +lat_1=35 +lat_2=65 +lat_0=52 +lon_0=10 +x_0=4000000 +y_0=2800000 +ellps=GRS80 +units=m +no_defs";

  NK.projections = proj = {  
    //pregenerated projection objects
    "32633": new OpenLayers.Projection('EPSG:32633'),
    "32631": new OpenLayers.Projection('EPSG:32631'),
    "32632": new OpenLayers.Projection('EPSG:32632'),
    "32634": new OpenLayers.Projection('EPSG:32634'),
    "32635": new OpenLayers.Projection('EPSG:32635'),
    "32636": new OpenLayers.Projection('EPSG:32636'),
    "25831": new OpenLayers.Projection('EPSG:25831'),
    "25832": new OpenLayers.Projection('EPSG:25832'),
    "25833": new OpenLayers.Projection('EPSG:25833'),
    "25834": new OpenLayers.Projection('EPSG:25834'),
    "25835": new OpenLayers.Projection('EPSG:25835'),
    "25836": new OpenLayers.Projection('EPSG:25836'),
    "4326" : new OpenLayers.Projection('EPSG:4326'),
    "3034" : new OpenLayers.Projection('EPSG:3034'),
    "3575" : new OpenLayers.Projection('EPSG:3575')
  };

  mapProj = proj[NK.baseProjection];
  mapBounds = new OpenLayers.Bounds(-2500000.0,3500000.0,3045984.0,9045984.0);

  OpenLayers.Util.onImageLoadErrorColor = 'transparent';
  OpenLayers.ImgPath = 'img/';

  OpenLayers.Lang.setCode('nb');

  // extract URL parameters into dictionary
  prmstr = window.location.search.substr(1);
  prmarr = prmstr.split ("&");
  params = {};

  for (i = 0, j = prmarr.length; i < j; i += 1) {
    tmparr = prmarr[i].split("=");
    params[tmparr[0]] = tmparr[1];
  }

  // Create map canvas

  if (!!params.proj) {
    mapProj = proj[params.proj]; 
  }
var options = {
};

  NK.mapOptions = {
    projection: mapProj,
    displayProjection: mapProj,
    maxExtent:  mapBounds,
    units: "m",
    maxResolution: 21664.0,
  //      minResolution: 0.165283203125,
    numZoomLevels: NK.zoomLevels,
  theme: 'theme/norgeskart/style.css'
  };

  map = new OpenLayers.Map( 
    'map', 
    OpenLayers.Util.extend(NK.mapOptions, {
      controls: [], //defined later
      numZoomLevels: NK.zoomLevels,
      eventListeners: NK.mapEventListeners
    })
  );

  // Default placement and zoom of the map
  NK.defaultCenter = new OpenLayers.LonLat(378604,7226208);
NK.defaultZoom = 5;


  // load SLD styles
  
NK = NK || {};
NK.styles = NK.styles || {};
NK.styles.unlabeledMarker = new OpenLayers.StyleMap(
	{
		'default': new OpenLayers.Style(
			{
				fillOpacity: 1, 
				pointRadius: 0,
				fontFamily: "Arial, Courier New, monospace",
				fontWeight: "bold",
				fillColor: "transparent",
				graphicWidth: 44,
				graphicHeight: 56,
				graphicYOffset: -55,
				graphicXOffset: -11,
				zIndex: 0,
				externalGraphic: 'data:image/png;base64,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'
			},
			{}
		),
		'select': new OpenLayers.Style(
			{
				fillOpacity: 1
			},
			{}
		),
		'temporary': new OpenLayers.Style(
			{
				fillOpacity: 1
			},
			{}
		)
	}
);



NK.styles = NK.styles || {};
NK.styles.omriss = new OpenLayers.StyleMap(
	{
	  'default': new OpenLayers.Style(
	    {
	      strokeWidth: 0,
	      strokeColor: "#606161",
	      strokeOpacity: 0.5,
	      fillOpacity: 1,
	      fillColor: "white"
	    }
	  )
	}
);


NK.styles = NK.styles || {};
NK.styles.track = NK.styles.track = new OpenLayers.StyleMap({
	'default': new OpenLayers.Style({
	  strokeWidth: 5,
	  strokeColor  : "#0058a3",
	  fillOpacity: 0.4,
	  fillColor: "#0058a3",
	  graphicName: 'circle',
	  pointRadius: 6,
	  fontColor: "#0058a3",
	  fontSize: "16px",
	  fontFamily: "Arial, sans-serif",
	  fontWeight: "normal",
	  labelAlign: "${getLabelAlign}",
	  label: "${getLabel}",
	  labelXOffset: "${getLabelXOffset}",
	  labelYOffset: 0,
	  labelOutlineColor: "white",
	  labelOutlineWidth: 3	  
	},
	{
		context: {
			getLabel: function (feature) {
				return feature.attributes.label || '';
			},
			getLabelXOffset: function (feature) {
				return (feature.geometry.CLASS_NAME === 'OpenLayers.Geometry.Point') ? 10 : 0;
			},
			getLabelAlign: function (feature) {
				return (feature.geometry.CLASS_NAME === 'OpenLayers.Geometry.Point') ? 'lm' : 'cm';
			}

		}
	}),
	'temporary': new OpenLayers.Style({
	  strokeWidth: 5,
	  strokeColor  : "#0058a3",
	  fillOpacity: 0.4,
	  strokeDashstyle: "${getStrokeDashStyle}",
	  fillColor: "#0058a3",
	  pointRadius: 6
	},
	{
		context: {
			getStrokeDashStyle: function (feature) {
				return (feature.geometry.CLASS_NAME === 'OpenLayers.Geometry.Point') ? 'solid' : 'dash';
			}
		}
	}),
	'select': new OpenLayers.Style({
	  strokeWidth: 6,
	  strokeColor  : "#f058a3",
	  fillOpacity: 0.4,
	  fillColor: "#f058a3",
	  pointRadius: 5,
	  cursor: 'text',
	  fontColor: "#0058a3",
	  fontSize: "16px",
	  fontFamily: "Arial, sans-serif",
	  fontWeight: "normal",
	  labelAlign: "${getLabelAlign}",
	  label: "${getLabel}",
	  labelXOffset: "${getLabelXOffset}",
	  labelYOffset: 0,
	  labelOutlineColor: "white",
	  labelOutlineWidth: 3	  
	},
	{
		context: {
			getLabel: function (feature) {
				return feature.attributes.label || '';
			},
			getLabelXOffset: function (feature) {
				return (feature.geometry.CLASS_NAME === 'OpenLayers.Geometry.Point') ? 10 : 0;
			},
			getLabelAlign: function (feature) {
				return (feature.geometry.CLASS_NAME === 'OpenLayers.Geometry.Point') ? 'lm' : 'cm';
			}

		}
	})
});



  // Base layers
  var matrixIds,
    wmts,
    i;

matrixIds = new Array(NK.zoomLevels);

for (i = 0; i <= NK.zoomLevels; ++i) {
  matrixIds[i] = {};
  matrixIds[i].identifier = mapProj + ":" + i;
} 

wmts = new OpenLayers.Layer.WMTS({
  name: "Europa",
  url: NK.mapservers.wmts,
  layer: "egk",
  matrixSet: mapProj,
  matrixIds: matrixIds,
  format: "image/png",
  requestEncoding: "kvp",
  style: "default",
  shortid: "europa", 
  visibility: 0, 
  transitionEffect: 'resize',
  opacity: 1.0,
  params: {
    gkt: NK.gkToken
  }
});

if (wmts.params.GKT) {
  wmts.params.gkt = wmts.params.GKT;
  delete wmts.params.GKT; 
}

wmts.events.register("tileerror", wmts, function(arg) {
  NK.functions.getNewToken();
});

map.events.register('zoomend', wmts, function (evt) {
  this.setVisibility(map.getZoom() <= 6);
});

map.addLayers([wmts]);


  // Overlays
  
NK.addLayerType = NK.addLayerType || {};
NK.addLayerType.WMTS = (function (M, MP) {
  var matrixIds = [],
      i;

  for (i = 0; i <= NK.zoomLevels; ++i) {
    matrixIds[i] = {};
    matrixIds[i].identifier = MP + ":" + i;
  } 

  return function (id, name, url, layer, options) {
    var layer, 
        layerOptions;
    var myMatrixIds = matrixIds;

    if (!!options.customProj) {
      var myMatrixIds = [],
        i;

      for (i = 0; i <= NK.zoomLevels; ++i) {
        myMatrixIds[i] = {};
        if (!!options.shortMatrixIds) {
          myMatrixIds[i].identifier = "" + i;
        } else {
          myMatrixIds[i].identifier = options.customProj + ":" + i;
        }
      } 
    } 

    layerOptions = {
      'name': name,
      'url': url,
      'layer': layer,
      'matrixSet': options.customProj || MP,
      'matrixIds': myMatrixIds,
      'format': "image/png",
      'requestEncoding': "kvp",
      'style': "default",
      'shortid': id, 
      'isBaseLayer': false,
      'linkedTo': options.linkedTo || null,
      'transitionEffect': 'resize',
      'displayOutsideMaxExtent': false,
      'buffer': 1
    };

    if (!!options.attribution) {
      layerOptions['attribution'] = options.attribution;
    }
    if (!!options.extent) {
      var c = options.extent.split(",");
      var customBounds = new OpenLayers.Bounds(c);
      layerOptions['tileFullExtent'] = customBounds;
    }
    if (!!options.tileorigin) {
      var c = options.tileorigin.split(",");
      var origin = new OpenLayers.LonLat(c);
      layerOptions['tileOrigin'] = origin;
    }
    if (!!options.databbox) {
      var c = options.databbox.split(",");
      var customBounds = new OpenLayers.Bounds(c);
      layerOptions['maxExtent'] = customBounds;
      layerOptions['visibility'] = 1;
    }

    layerOptions.displayInLayerSwitcher = !!(options.displayInLayerSwitcher) ? 1 : 0;
    layerOptions.visibility = !!(options.visibility) ? 1 : 0;

    if (!!options.params) {
      layerOptions.params = options.params;
    }

    layer = new OpenLayers.Layer.WMTS(layerOptions);

    if (options.layerGroup) {
      layer = OpenLayers.Util.extend(layer, {
        'layerGroup': options.layerGroup
      });
    }

    if (layer.params.GKT) {
      layer.params.gkt = layer.params.GKT;
      delete layer.params.GKT; 
    }

    if (options.visible) {
      NK.defaultVisibleLayers = NK.defaultVisibleLayers || [];
      NK.defaultVisibleLayers.push(id);
    }

    if (options.linkedTo) {
      layer.events.register("visibilitychanged", layer, function(arg) {
        map.getLayersBy("shortid",options.linkedTo)[0].setVisibility(layer.getVisibility());
      });
    }

    layer.events.register("tileerror", layer, function(arg) {
      NK.functions.getNewToken();
    });

    M.addLayers([layer]);

    return layer;
  };
}(map, mapProj));



(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;

    options.visibility = true;

    options.layerGroup = "land";

    options.params = { 'gkt': NK.gkToken };







    options.attribution = {
      title: "Kartverket",
      href: "http://www.kartverket.no/"
    }

  var layer = NK.addLayerType.WMTS('land', 'Land', url, 'topo2_dybde', options);

}());


(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;


    options.layerGroup = "land";

    options.params = { 'gkt': NK.gkToken };








  var layer = NK.addLayerType.WMTS('enkel', 'enkel', url, 'norges_grunnkart', options);

}());


(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;


    options.layerGroup = "sjo";

    options.params = { 'gkt': NK.gkToken };








  var layer = NK.addLayerType.WMTS('sjo', 'Hovedkart', url, 'sjokartraster', options);

}());

(function () {
  var wms = new OpenLayers.Layer.WMS(
    "Elektron. Sj&oslash;kart",
    "http://wms.geonorge.no/skwms1/wms.ecc_enc",
    {
      ticket: NK.encTicket,
      layers: "cells",
      transparent: true, 
      styles: "style-id-263",
      format: 'image/png'
    },
    {
      shortid: "sjo_enc", 
      isBaseLayer: false,
      buffer: 0,
      ratio: 1, 
      visibility: false, 
      singleTile: true,
      minZoom: 10,
      transitionEffect: 'resize'
    }
  );

    wms = OpenLayers.Util.extend(wms, { layerGroup: 'sjo' });



  if (wms.params.GKT) {
    wms.params.gkt = wms.params.GKT;
    delete wms.params.GKT; 
  }

  if (wms.params.TICKET) {
    wms.params.ticket = wms.params.TICKET;
    delete wms.params.TICKET;
  }

  wms.events.register("visibilitychanged", wms, function(arg) {
    map.getLayersBy("shortid","enkel")[0].setVisibility(wms.getVisibility());
  });
  

  map.addLayers([wms]);
}());

(function () {
  var wms = new OpenLayers.Layer.WMS(
    "Fly&shy;bilder",
    "http://gatekeeper1.geonorge.no/BaatGatekeeper/gk/gk.nibcache",
    {
      gkt: NK.gkToken,
      layers: "NiB",
      transparent: 0, 
      format: 'image/jpeg'
    },
    {
      shortid: "flybilder", 
      isBaseLayer: false,
      buffer: 0,
      ratio: 1, 
      visibility: 0, 
      singleTile: false,
      transitionEffect: 'resize'
    }
  );

    wms = OpenLayers.Util.extend(wms, { layerGroup: 'land' });



  if (wms.params.GKT) {
    wms.params.gkt = wms.params.GKT;
    delete wms.params.GKT; 
  }


  

  map.addLayers([wms]);
}());


(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;


    options.layerGroup = "land";

    options.params = { 'gkt': NK.gkToken };








  var layer = NK.addLayerType.WMTS('terreng', 'terreng', url, 'terreng_norgeskart', options);

}());


(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;


    options.layerGroup = "land";

    options.params = { 'gkt': NK.gkToken };






    options.linkedTo = "fjellskygge"


  var layer = NK.addLayerType.WMTS('toporaster', 'Rasterkart', url, 'toporaster3', options);

}());


(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;



    options.params = { 'gkt': NK.gkToken };








  var layer = NK.addLayerType.WMTS('fjellskygge', 'Fjellskygge', url, 'fjellskygge', options);

}());


(function () {
  var url, 
      options = {};

    url = "http://geodata.npolar.no/arcgis/rest/services/Basisdata/NP_Basiskart_JanMayen_WMTS_25833/MapServer/WMTS?";

    options.displayInLayerSwitcher = true;


    options.layerGroup = "flere";


    options.customProj = "EPSG:25833"

    options.shortMatrixIds = true


    options.databbox = "-393783.2540000008,7978220.98008712,-276963.7430000013,8084965.524000007"

    options.tileorigin = "-5120900.0,9998100.0"



  var layer = NK.addLayerType.WMTS('janmayen', 'janmayen', url, 'Basisdata_NP_Basiskart_JanMayen_WMTS_25833', options);

}());


(function () {
  var url, 
      options = {};

    url = "http://geodata.npolar.no/arcgis/rest/services/Basisdata/NP_Basiskart_Svalbard_WMTS_25833/MapServer/WMTS?";

    options.displayInLayerSwitcher = true;


    options.layerGroup = "flere";


    options.customProj = "EPSG:25833"

    options.shortMatrixIds = true


    options.databbox = "369976.3899489096,8221306.539890718,878234.7199568129,9010718.76990194"

    options.tileorigin = "-5120900.0,9998100.0"



  var layer = NK.addLayerType.WMTS('svalbard', 'svalbard', url, 'Basisdata_NP_Basiskart_Svalbard_WMTS_25833', options);

}());



NK.functions = NK.functions || {};
NK.functions.vector = NK.functions.vector || {};

NK.functions.vector.markAllById = function (layer, intent, preserveIntent) {
  return function(element, evt) {
    if (preserveIntent && element.feature.renderIntent === preserveIntent) {
      return false;
    }
    // highlight all elements with the same element.feature.fid
    var ident = layer.getFeaturesByFid(element.feature.fid);
    $.each(ident, function (i, feature) {

      if (preserveIntent && feature.renderIntent === preserveIntent) {
        return false;
      } else {
        feature.renderIntent = intent;
        layer.drawFeature(feature);
      }
    });
  };
};

NK.functions.vector.addVectorHoverControls = function (map, layer, options) {
  var hoverCtrl,
      selectFeatureProperties;

  selectFeatureProperties = {
      hover: true,
      highlightOnly: true,
      renderIntent: "temporary"
  };

  if (options && options.groupByFid) {
    selectFeatureProperties.eventListeners = {
        beforefeaturehighlighted: NK.functions.vector.markAllById(layer, "temporary", options.preserveIntent),
        featureunhighlighted: NK.functions.vector.markAllById(layer, "default", options.preserveIntent)
    };
  }

  hoverCtrl = new OpenLayers.Control.SelectFeature(
    layer,
    selectFeatureProperties
  );


  map.addControl(hoverCtrl);
  hoverCtrl.activate();
  return hoverCtrl;
};

NK.functions.vector.addVectorControls = function (map, layer, options) {
  var controls = {};

  controls.hover = NK.functions.vector.addVectorHoverControls(map, layer, options);

  return controls;
};




NK.styles = NK.styles || {};
NK.styles.dekning = NK.styles.dekning || {};
NK.styles.dekning.land = new OpenLayers.StyleMap(
	{
	  'default': new OpenLayers.Style(
	    {
	      strokeWidth: 2,
	      strokeColor  : "#484",
	      fillOpacity: 0.1, 
	      label : "${nr}",
	      fontColor: "#8a8",
	      fontSize: "12px",
	      fontFamily: "Courier New, monospace",
	      fontWeight: "bold",
	      labelAlign: "cm",
	      labelOutlineColor: "white",
	      labelOutlineWidth: 5
	    },
	    {
	      rules: [
	        new OpenLayers.Rule({
	          maxScaleDenominator: 5000000,
	          symbolizer: {
	            label: "${nr}"
	          }
	        }),
	        new OpenLayers.Rule({
	          minScaleDenominator: 5000000,
	          symbolizer: {
	            label: ""
	          }
	        }),
	        new OpenLayers.Rule({
	          filter: new OpenLayers.Filter.Comparison({
	            type: OpenLayers.Filter.Comparison.LIKE,
	            property: "u",
	            value: "2013"
	          }),
	          symbolizer: {
	            strokeColor  : "#844",
	            fontColor: "#a88"
	          }
	        })
	      ]
	    }
	  ),
	  'temporary': new OpenLayers.Style(
			{
		      strokeWidth: 3,
		      strokeColor  : "#ada",
		      fontColor: "#ada",
		      fillOpacity: 0.1
			},
			{
				rules: [
			        new OpenLayers.Rule({
			        	symbolizer: {
					        strokeColor  : "#ada",
					        fontColor: "#ada"
				        }
				    }),
			        new OpenLayers.Rule({
						filter: new OpenLayers.Filter.Comparison({
							type: OpenLayers.Filter.Comparison.LIKE,
							property: "u",
							value: "2013"
						}),
						symbolizer: {
							strokeColor  : "#daa",
							fontColor: "#daa"
						}
			    })
				]
			}
	  )
	}
);



(function (M, MP, P) {
  var layer,
      selectControl,
      onPopupClose = null,
      onFeatureUnselect,
      onFeatureSelect,
      generatePopupMarkup,
      requestHandler;

  // dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Norge 1:50000",
    {
      shortid: "dekning.land", 
      styleMap: NK.styles.dekning.land, 
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "toporaster"
    }
  );

  M.addLayer(layer);

  requestHandler = function (request) {
    var geojson_format,
        features,
        feature, 
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['32633'] 
    });

    features = geojson_format.read(request.responseText);

    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        feature.attributes.nr = feature.fid;
      }
    }
    layer.addFeatures(features);
  };

  OpenLayers.Request.GET({
    url: "/json/dekning/land/n50/plast.json",
    callback: requestHandler
  });

  onPopupClose = function (evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  };

  generatePopupMarkup = function (feature) {
    var a  = feature.attributes;
      var markup = '<article>';
      if (a.n && a.n !== 'NULL') {
        markup += '<h1 class="h">' + a.n + '</h1>';
      }
      if (a.nr) {
        markup += '<p>' + OpenLayers.Lang.translate('Map number') + ': ' + a.nr + '</p>';
      }
      if (a.k) {
        markup += '<div class="municipalities">' + OpenLayers.Lang.translate('Municipalities') + ': <span>' + a.k.split(',').join(',</span><span>') + '</span></div>';
      }
      if (a.u) {
        markup += '<p>' + OpenLayers.Lang.translate('Updated') + ': ' + a.u + '</p>';
      }
      if (a.e) {
        markup += '<p>' + OpenLayers.Lang.translate('EAN-number') + ': ' + a.e + '</p>';
      }
      markup += '</article>';
      return markup;
  };

  onFeatureUnselect = function (feature) {
      if (feature === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      if (feature.popup) {
        M.removePopup(feature.popup);
        feature.popup.destroy();
        feature.popup = null;
      }
  };

  onFeatureSelect = function (feature) {
      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        var message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };
        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {
        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;
        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
    }
  };

  NK.functions.vector.addVectorHoverControls(M, layer);

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect,
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);


OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Map number': 'Kartblad',
  'Latest print': 'Siste trykk',
  'Datum': 'Datum',
  'Municipalities': 'Kommuner',
  'EAN-number': 'EAN-nummer',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Updated': 'Sist oppdatert',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});


}(map, mapProj, proj));

(function (M, MP, P){
  var styleMap,
      layer,
      dataResponseHandler,
      highlightAllById,
      unhighlightAllById,
      selectControl;

    styleMap = new OpenLayers.StyleMap({
    'default': new OpenLayers.Style(
      {
        strokeWidth: 2,
        strokeColor  :"#844",
        fillOpacity: 0.1, 
        strokeOpacity: 1,

        label : "${nr}",
        fontColor: "#a88",
        fontSize: "12px",
        fontFamily: "Courier New, monospace",
        fontWeight: "bold",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 5
      }, 
      {
        rules: [
          new OpenLayers.Rule({
            maxScaleDenominator: 2500000,
            symbolizer: {
              label: "${nr}"
            }
          }),
          new OpenLayers.Rule({
            minScaleDenominator: 2500000,
            symbolizer: {
              label: ""
            }
          })       
        ]
      }
    ),
    'temporary': {
      strokeWidth: 6,
      strokeColor  : "#daa",
      fontColor: "#daa",
      fillOpacity: 0.1
    }
  });
  

  
	styleMap.styles['default'].defaultStyle.strokeColor = "#484";
	styleMap.styles['default'].defaultStyle.fontColor = "#8a8";
	styleMap.styles.temporary.defaultStyle.strokeColor = "#ada";
	styleMap.styles.temporary.defaultStyle.fontColor = "#ada";


  //dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Hoved&shy;kart sj&oslash;",
    {
      shortid: "dekning.sjo",
      styleMap: styleMap,
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "sjo"
    }
  );

  dataResponseHandler = function(request) {
    var geojson_format, 
        features,
        feature,
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['4326'] 
    });
    features = geojson_format.read(request.responseText);
    features = features.sort(function (a,b) {
       // sort by area
      return b.geometry.getArea() - a.geometry.getArea();
    });
    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        if (feature.fid.length < 4) {
          feature.attributes.nr = feature.fid;
          feature.attributes.vignett = '';
        } else {
          feature.attributes.nr = '';
          feature.attributes.vignett = feature.fid;
          feature.fid = feature.fid.slice(0, 3);
        }
      }
    }
    layer.addFeatures(features);
  };

  M.addLayer(layer);

  OpenLayers.Request.GET({
    url: "/json/dekning/sjo/hovedserie_ny.json",
    callback: dataResponseHandler
  });

  highlightAllById = function(element) {
    // highlight all elements with the same element.feature.fid;
    var ident = layer.getFeaturesByFid (element.feature.fid);
    $.each(ident, function(i, feature) {
      feature.renderIntent = "temporary";
      layer.drawFeature(feature);
    });
  };

  // un-highlight all elements with the same element.feature.fid;
  unhighlightAllById = function(element) {
    var ident = layer.getFeaturesByFid (element.feature.fid);

    $.each(ident, function(i, feature) {
      feature.renderIntent = "default";
      layer.drawFeature(feature);
    });
  };

  var highlightDekningCtrl = new OpenLayers.Control.SelectFeature(layer, {
    hover: true,
    multiple: true,
    highlightOnly: true,
    renderIntent: "temporary",
    eventListeners: {
        beforefeaturehighlighted: highlightAllById,
        featureunhighlighted: unhighlightAllById
    },
    autoActivate: true
  });
  map.addControl(highlightDekningCtrl);
  
  function onPopupClose(evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  }

  function projectionName(projectionNumber) {
    switch (projectionNumber) {
      case '8':
        return 'Mercator';
      case '16':
        return 'Gauss Kr\u00FCger';
      default:
        return '';  
    }
  }

  var datumNames = {
    '2': 'WGS84'
    // TODO: values for ED50 and NGO (see http://kartverket.no/en/Kart/Nautical-Charts/Nautical-Charts/) 
  };

  function generatePopupMarkup (feature) {
    var a  = feature.attributes;
    var mainMapFeature, i, j;
      var markup = '<article>';
      if (!!a.n) {
        markup += '<h1 class="h">' + feature.fid + " " + a.n + '</h1>';
      }
      if (a.vignett) {
        var mainMapNumber = a.vignett.slice(0, 3);
        for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
          if (feature.layer.features[i].attributes.nr === mainMapNumber) {
            mainMapFeature = feature.layer.features[i];
          }
        }
        if (mainMapFeature) {
          if (mainMapFeature.attributes.s !== a.s) {
            markup += OpenLayers.Lang.translate('Special in map');
          } else {
            markup += OpenLayers.Lang.translate('Vignette in map');
          }
           markup += ' ' + mainMapFeature.attributes.nr + ' ' + mainMapFeature.attributes.n;
        }
      }
      if (a.f) {
        markup += '<p>' + OpenLayers.Lang.translate('Current edition') + ': ' + a.f + '</p>';
      }
      if (a.g) {
        markup += '<p>' + OpenLayers.Lang.translate('Latest print') + ': ' + a.g + '</p>';
      }
      if (a.s) {
        markup += '<p>' + OpenLayers.Lang.translate('Scale') + ' ' + a.s + '</p>';
      }
      if (a.p) {
        markup += '<p>' + OpenLayers.Lang.translate('Projection') + ': ' + a.p + '</p>';
      }
      if (a.d) {
        markup += '<p>' + OpenLayers.Lang.translate('Datum') + ': ' + a.d + '</p>';
      }
      markup += '</article>';
      return markup;
  }

  function onFeatureSelect (feature) {
    var i, 
        j, 
        mainMapNumber,
        message,
        vignettes = [],
        specials = [],
        a;

      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };

        if (feature.attributes.vignett) {
            mainMapNumber = feature.attributes.vignett.slice(0, 3);
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              if (feature.layer.features[i].attributes.nr === mainMapNumber) {
                message.mainMapFeature = feature.layer.features[i].attributes;
              }
            }
        } else {
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              a = feature.layer.features[i].attributes;
              if (a.vignett && a.vignett.indexOf(feature.attributes.nr) === 0) {
                // feature[i] is a special or vignette in the selected map
                
                if (feature.attributes.s === a.s) {
                  vignettes.push(a);
                } else {
                  specials.push(a);
                }
              }
            }
            if (specials.length > 0) {
              message.specials = specials;
            }
            if (vignettes.length > 0) {
              message.vignettes = vignettes;
            }
        }

        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {

        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;

        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
      }
  }
  
  function onFeatureUnselect (feature) {
      if (feature.popup === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      M.removePopup(feature.popup);
      feature.popup.destroy();
      feature.popup = null;

  }

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect, 
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);

OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Current edition': 'Gyldig utgave',
  'Latest print': 'Siste trykk md/&aring;r',
  'Datum': 'Datum',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});

}(map, mapProj, proj));

(function (M, MP, P){
  var styleMap,
      layer,
      dataResponseHandler,
      highlightAllById,
      unhighlightAllById,
      selectControl;

    styleMap = new OpenLayers.StyleMap({
    'default': new OpenLayers.Style(
      {
        strokeWidth: 2,
        strokeColor  :"#844",
        fillOpacity: 0.1, 
        strokeOpacity: 1,

        label : "${nr}",
        fontColor: "#a88",
        fontSize: "12px",
        fontFamily: "Courier New, monospace",
        fontWeight: "bold",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 5
      }, 
      {
        rules: [
          new OpenLayers.Rule({
            maxScaleDenominator: 2500000,
            symbolizer: {
              label: "${nr}"
            }
          }),
          new OpenLayers.Rule({
            minScaleDenominator: 2500000,
            symbolizer: {
              label: ""
            }
          })       
        ]
      }
    ),
    'temporary': {
      strokeWidth: 6,
      strokeColor  : "#daa",
      fontColor: "#daa",
      fillOpacity: 0.1
    }
  });
  

  


  //dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Havne&shy;kart",
    {
      shortid: "dekning.sjo.hv",
      styleMap: styleMap,
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "sjo"
    }
  );

  dataResponseHandler = function(request) {
    var geojson_format, 
        features,
        feature,
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['4326'] 
    });
    features = geojson_format.read(request.responseText);
    features = features.sort(function (a,b) {
       // sort by area
      return b.geometry.getArea() - a.geometry.getArea();
    });
    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        if (feature.fid.length < 4) {
          feature.attributes.nr = feature.fid;
          feature.attributes.vignett = '';
        } else {
          feature.attributes.nr = '';
          feature.attributes.vignett = feature.fid;
          feature.fid = feature.fid.slice(0, 3);
        }
      }
    }
    layer.addFeatures(features);
  };

  M.addLayer(layer);

  OpenLayers.Request.GET({
    url: "/json/dekning/sjo/havnekart_ny.json",
    callback: dataResponseHandler
  });

  highlightAllById = function(element) {
    // highlight all elements with the same element.feature.fid;
    var ident = layer.getFeaturesByFid (element.feature.fid);
    $.each(ident, function(i, feature) {
      feature.renderIntent = "temporary";
      layer.drawFeature(feature);
    });
  };

  // un-highlight all elements with the same element.feature.fid;
  unhighlightAllById = function(element) {
    var ident = layer.getFeaturesByFid (element.feature.fid);

    $.each(ident, function(i, feature) {
      feature.renderIntent = "default";
      layer.drawFeature(feature);
    });
  };

  var highlightDekningCtrl = new OpenLayers.Control.SelectFeature(layer, {
    hover: true,
    multiple: true,
    highlightOnly: true,
    renderIntent: "temporary",
    eventListeners: {
        beforefeaturehighlighted: highlightAllById,
        featureunhighlighted: unhighlightAllById
    },
    autoActivate: true
  });
  map.addControl(highlightDekningCtrl);
  
  function onPopupClose(evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  }

  function projectionName(projectionNumber) {
    switch (projectionNumber) {
      case '8':
        return 'Mercator';
      case '16':
        return 'Gauss Kr\u00FCger';
      default:
        return '';  
    }
  }

  var datumNames = {
    '2': 'WGS84'
    // TODO: values for ED50 and NGO (see http://kartverket.no/en/Kart/Nautical-Charts/Nautical-Charts/) 
  };

  function generatePopupMarkup (feature) {
    var a  = feature.attributes;
    var mainMapFeature, i, j;
      var markup = '<article>';
      if (!!a.n) {
        markup += '<h1 class="h">' + feature.fid + " " + a.n + '</h1>';
      }
      if (a.vignett) {
        var mainMapNumber = a.vignett.slice(0, 3);
        for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
          if (feature.layer.features[i].attributes.nr === mainMapNumber) {
            mainMapFeature = feature.layer.features[i];
          }
        }
        if (mainMapFeature) {
          if (mainMapFeature.attributes.s !== a.s) {
            markup += OpenLayers.Lang.translate('Special in map');
          } else {
            markup += OpenLayers.Lang.translate('Vignette in map');
          }
           markup += ' ' + mainMapFeature.attributes.nr + ' ' + mainMapFeature.attributes.n;
        }
      }
      if (a.f) {
        markup += '<p>' + OpenLayers.Lang.translate('Current edition') + ': ' + a.f + '</p>';
      }
      if (a.g) {
        markup += '<p>' + OpenLayers.Lang.translate('Latest print') + ': ' + a.g + '</p>';
      }
      if (a.s) {
        markup += '<p>' + OpenLayers.Lang.translate('Scale') + ' ' + a.s + '</p>';
      }
      if (a.p) {
        markup += '<p>' + OpenLayers.Lang.translate('Projection') + ': ' + a.p + '</p>';
      }
      if (a.d) {
        markup += '<p>' + OpenLayers.Lang.translate('Datum') + ': ' + a.d + '</p>';
      }
      markup += '</article>';
      return markup;
  }

  function onFeatureSelect (feature) {
    var i, 
        j, 
        mainMapNumber,
        message,
        vignettes = [],
        specials = [],
        a;

      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };

        if (feature.attributes.vignett) {
            mainMapNumber = feature.attributes.vignett.slice(0, 3);
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              if (feature.layer.features[i].attributes.nr === mainMapNumber) {
                message.mainMapFeature = feature.layer.features[i].attributes;
              }
            }
        } else {
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              a = feature.layer.features[i].attributes;
              if (a.vignett && a.vignett.indexOf(feature.attributes.nr) === 0) {
                // feature[i] is a special or vignette in the selected map
                
                if (feature.attributes.s === a.s) {
                  vignettes.push(a);
                } else {
                  specials.push(a);
                }
              }
            }
            if (specials.length > 0) {
              message.specials = specials;
            }
            if (vignettes.length > 0) {
              message.vignettes = vignettes;
            }
        }

        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {

        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;

        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
      }
  }
  
  function onFeatureUnselect (feature) {
      if (feature.popup === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      M.removePopup(feature.popup);
      feature.popup.destroy();
      feature.popup = null;

  }

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect, 
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);

OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Current edition': 'Gyldig utgave',
  'Latest print': 'Siste trykk md/&aring;r',
  'Datum': 'Datum',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});

}(map, mapProj, proj));

(function (M, MP, P){
  var styleMap,
      layer,
      dataResponseHandler,
      highlightAllById,
      unhighlightAllById,
      selectControl;

    styleMap = new OpenLayers.StyleMap({
    'default': new OpenLayers.Style(
      {
        strokeWidth: 2,
        strokeColor  :"#844",
        fillOpacity: 0.1, 
        strokeOpacity: 1,

        label : "${nr}",
        fontColor: "#a88",
        fontSize: "12px",
        fontFamily: "Courier New, monospace",
        fontWeight: "bold",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 5
      }, 
      {
        rules: [
          new OpenLayers.Rule({
            maxScaleDenominator: 2500000,
            symbolizer: {
              label: "${nr}"
            }
          }),
          new OpenLayers.Rule({
            minScaleDenominator: 2500000,
            symbolizer: {
              label: ""
            }
          })       
        ]
      }
    ),
    'temporary': {
      strokeWidth: 6,
      strokeColor  : "#daa",
      fontColor: "#daa",
      fillOpacity: 0.1
    }
  });
  

  
styleMap.styles['default'].defaultStyle.strokeColor = "#844";
styleMap.styles['default'].defaultStyle.fontColor = "#aa8";
styleMap.styles.temporary.defaultStyle.strokeColor = "#dda";
styleMap.styles.temporary.defaultStyle.fontColor = "#dda";


  //dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Kyst&shy;kart",
    {
      shortid: "dekning.sjo.ky",
      styleMap: styleMap,
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "sjo"
    }
  );

  dataResponseHandler = function(request) {
    var geojson_format, 
        features,
        feature,
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['4326'] 
    });
    features = geojson_format.read(request.responseText);
    features = features.sort(function (a,b) {
       // sort by area
      return b.geometry.getArea() - a.geometry.getArea();
    });
    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        if (feature.fid.length < 4) {
          feature.attributes.nr = feature.fid;
          feature.attributes.vignett = '';
        } else {
          feature.attributes.nr = '';
          feature.attributes.vignett = feature.fid;
          feature.fid = feature.fid.slice(0, 3);
        }
      }
    }
    layer.addFeatures(features);
  };

  M.addLayer(layer);

  OpenLayers.Request.GET({
    url: "/json/dekning/sjo/kystkart_ny.json",
    callback: dataResponseHandler
  });

  highlightAllById = function(element) {
    // highlight all elements with the same element.feature.fid;
    var ident = layer.getFeaturesByFid (element.feature.fid);
    $.each(ident, function(i, feature) {
      feature.renderIntent = "temporary";
      layer.drawFeature(feature);
    });
  };

  // un-highlight all elements with the same element.feature.fid;
  unhighlightAllById = function(element) {
    var ident = layer.getFeaturesByFid (element.feature.fid);

    $.each(ident, function(i, feature) {
      feature.renderIntent = "default";
      layer.drawFeature(feature);
    });
  };

  var highlightDekningCtrl = new OpenLayers.Control.SelectFeature(layer, {
    hover: true,
    multiple: true,
    highlightOnly: true,
    renderIntent: "temporary",
    eventListeners: {
        beforefeaturehighlighted: highlightAllById,
        featureunhighlighted: unhighlightAllById
    },
    autoActivate: true
  });
  map.addControl(highlightDekningCtrl);
  
  function onPopupClose(evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  }

  function projectionName(projectionNumber) {
    switch (projectionNumber) {
      case '8':
        return 'Mercator';
      case '16':
        return 'Gauss Kr\u00FCger';
      default:
        return '';  
    }
  }

  var datumNames = {
    '2': 'WGS84'
    // TODO: values for ED50 and NGO (see http://kartverket.no/en/Kart/Nautical-Charts/Nautical-Charts/) 
  };

  function generatePopupMarkup (feature) {
    var a  = feature.attributes;
    var mainMapFeature, i, j;
      var markup = '<article>';
      if (!!a.n) {
        markup += '<h1 class="h">' + feature.fid + " " + a.n + '</h1>';
      }
      if (a.vignett) {
        var mainMapNumber = a.vignett.slice(0, 3);
        for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
          if (feature.layer.features[i].attributes.nr === mainMapNumber) {
            mainMapFeature = feature.layer.features[i];
          }
        }
        if (mainMapFeature) {
          if (mainMapFeature.attributes.s !== a.s) {
            markup += OpenLayers.Lang.translate('Special in map');
          } else {
            markup += OpenLayers.Lang.translate('Vignette in map');
          }
           markup += ' ' + mainMapFeature.attributes.nr + ' ' + mainMapFeature.attributes.n;
        }
      }
      if (a.f) {
        markup += '<p>' + OpenLayers.Lang.translate('Current edition') + ': ' + a.f + '</p>';
      }
      if (a.g) {
        markup += '<p>' + OpenLayers.Lang.translate('Latest print') + ': ' + a.g + '</p>';
      }
      if (a.s) {
        markup += '<p>' + OpenLayers.Lang.translate('Scale') + ' ' + a.s + '</p>';
      }
      if (a.p) {
        markup += '<p>' + OpenLayers.Lang.translate('Projection') + ': ' + a.p + '</p>';
      }
      if (a.d) {
        markup += '<p>' + OpenLayers.Lang.translate('Datum') + ': ' + a.d + '</p>';
      }
      markup += '</article>';
      return markup;
  }

  function onFeatureSelect (feature) {
    var i, 
        j, 
        mainMapNumber,
        message,
        vignettes = [],
        specials = [],
        a;

      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };

        if (feature.attributes.vignett) {
            mainMapNumber = feature.attributes.vignett.slice(0, 3);
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              if (feature.layer.features[i].attributes.nr === mainMapNumber) {
                message.mainMapFeature = feature.layer.features[i].attributes;
              }
            }
        } else {
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              a = feature.layer.features[i].attributes;
              if (a.vignett && a.vignett.indexOf(feature.attributes.nr) === 0) {
                // feature[i] is a special or vignette in the selected map
                
                if (feature.attributes.s === a.s) {
                  vignettes.push(a);
                } else {
                  specials.push(a);
                }
              }
            }
            if (specials.length > 0) {
              message.specials = specials;
            }
            if (vignettes.length > 0) {
              message.vignettes = vignettes;
            }
        }

        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {

        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;

        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
      }
  }
  
  function onFeatureUnselect (feature) {
      if (feature.popup === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      M.removePopup(feature.popup);
      feature.popup.destroy();
      feature.popup = null;

  }

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect, 
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);

OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Current edition': 'Gyldig utgave',
  'Latest print': 'Siste trykk md/&aring;r',
  'Datum': 'Datum',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});

}(map, mapProj, proj));

(function (M, MP, P){
  var styleMap,
      layer,
      dataResponseHandler,
      highlightAllById,
      unhighlightAllById,
      selectControl;

    styleMap = new OpenLayers.StyleMap({
    'default': new OpenLayers.Style(
      {
        strokeWidth: 2,
        strokeColor  :"#844",
        fillOpacity: 0.1, 
        strokeOpacity: 1,

        label : "${nr}",
        fontColor: "#a88",
        fontSize: "12px",
        fontFamily: "Courier New, monospace",
        fontWeight: "bold",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 5
      }, 
      {
        rules: [
          new OpenLayers.Rule({
            maxScaleDenominator: 2500000,
            symbolizer: {
              label: "${nr}"
            }
          }),
          new OpenLayers.Rule({
            minScaleDenominator: 2500000,
            symbolizer: {
              label: ""
            }
          })       
        ]
      }
    ),
    'temporary': {
      strokeWidth: 6,
      strokeColor  : "#daa",
      fontColor: "#daa",
      fillOpacity: 0.1
    }
  });
  

  
styleMap.styles['default'].defaultStyle.strokeColor = "#448";
styleMap.styles['default'].defaultStyle.fontColor = "#88a";
styleMap.styles.temporary.defaultStyle.strokeColor = "#aad";
styleMap.styles.temporary.defaultStyle.fontColor = "#aad";


  //dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Overseilingskart",
    {
      shortid: "dekning.sjo.fi",
      styleMap: styleMap,
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "sjo"
    }
  );

  dataResponseHandler = function(request) {
    var geojson_format, 
        features,
        feature,
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['4326'] 
    });
    features = geojson_format.read(request.responseText);
    features = features.sort(function (a,b) {
       // sort by area
      return b.geometry.getArea() - a.geometry.getArea();
    });
    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        if (feature.fid.length < 4) {
          feature.attributes.nr = feature.fid;
          feature.attributes.vignett = '';
        } else {
          feature.attributes.nr = '';
          feature.attributes.vignett = feature.fid;
          feature.fid = feature.fid.slice(0, 3);
        }
      }
    }
    layer.addFeatures(features);
  };

  M.addLayer(layer);

  OpenLayers.Request.GET({
    url: "/json/dekning/sjo/overseilingskart_ny.json",
    callback: dataResponseHandler
  });

  highlightAllById = function(element) {
    // highlight all elements with the same element.feature.fid;
    var ident = layer.getFeaturesByFid (element.feature.fid);
    $.each(ident, function(i, feature) {
      feature.renderIntent = "temporary";
      layer.drawFeature(feature);
    });
  };

  // un-highlight all elements with the same element.feature.fid;
  unhighlightAllById = function(element) {
    var ident = layer.getFeaturesByFid (element.feature.fid);

    $.each(ident, function(i, feature) {
      feature.renderIntent = "default";
      layer.drawFeature(feature);
    });
  };

  var highlightDekningCtrl = new OpenLayers.Control.SelectFeature(layer, {
    hover: true,
    multiple: true,
    highlightOnly: true,
    renderIntent: "temporary",
    eventListeners: {
        beforefeaturehighlighted: highlightAllById,
        featureunhighlighted: unhighlightAllById
    },
    autoActivate: true
  });
  map.addControl(highlightDekningCtrl);
  
  function onPopupClose(evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  }

  function projectionName(projectionNumber) {
    switch (projectionNumber) {
      case '8':
        return 'Mercator';
      case '16':
        return 'Gauss Kr\u00FCger';
      default:
        return '';  
    }
  }

  var datumNames = {
    '2': 'WGS84'
    // TODO: values for ED50 and NGO (see http://kartverket.no/en/Kart/Nautical-Charts/Nautical-Charts/) 
  };

  function generatePopupMarkup (feature) {
    var a  = feature.attributes;
    var mainMapFeature, i, j;
      var markup = '<article>';
      if (!!a.n) {
        markup += '<h1 class="h">' + feature.fid + " " + a.n + '</h1>';
      }
      if (a.vignett) {
        var mainMapNumber = a.vignett.slice(0, 3);
        for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
          if (feature.layer.features[i].attributes.nr === mainMapNumber) {
            mainMapFeature = feature.layer.features[i];
          }
        }
        if (mainMapFeature) {
          if (mainMapFeature.attributes.s !== a.s) {
            markup += OpenLayers.Lang.translate('Special in map');
          } else {
            markup += OpenLayers.Lang.translate('Vignette in map');
          }
           markup += ' ' + mainMapFeature.attributes.nr + ' ' + mainMapFeature.attributes.n;
        }
      }
      if (a.f) {
        markup += '<p>' + OpenLayers.Lang.translate('Current edition') + ': ' + a.f + '</p>';
      }
      if (a.g) {
        markup += '<p>' + OpenLayers.Lang.translate('Latest print') + ': ' + a.g + '</p>';
      }
      if (a.s) {
        markup += '<p>' + OpenLayers.Lang.translate('Scale') + ' ' + a.s + '</p>';
      }
      if (a.p) {
        markup += '<p>' + OpenLayers.Lang.translate('Projection') + ': ' + a.p + '</p>';
      }
      if (a.d) {
        markup += '<p>' + OpenLayers.Lang.translate('Datum') + ': ' + a.d + '</p>';
      }
      markup += '</article>';
      return markup;
  }

  function onFeatureSelect (feature) {
    var i, 
        j, 
        mainMapNumber,
        message,
        vignettes = [],
        specials = [],
        a;

      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };

        if (feature.attributes.vignett) {
            mainMapNumber = feature.attributes.vignett.slice(0, 3);
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              if (feature.layer.features[i].attributes.nr === mainMapNumber) {
                message.mainMapFeature = feature.layer.features[i].attributes;
              }
            }
        } else {
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              a = feature.layer.features[i].attributes;
              if (a.vignett && a.vignett.indexOf(feature.attributes.nr) === 0) {
                // feature[i] is a special or vignette in the selected map
                
                if (feature.attributes.s === a.s) {
                  vignettes.push(a);
                } else {
                  specials.push(a);
                }
              }
            }
            if (specials.length > 0) {
              message.specials = specials;
            }
            if (vignettes.length > 0) {
              message.vignettes = vignettes;
            }
        }

        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {

        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;

        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
      }
  }
  
  function onFeatureUnselect (feature) {
      if (feature.popup === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      M.removePopup(feature.popup);
      feature.popup.destroy();
      feature.popup = null;

  }

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect, 
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);

OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Current edition': 'Gyldig utgave',
  'Latest print': 'Siste trykk md/&aring;r',
  'Datum': 'Datum',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});

}(map, mapProj, proj));




  
NK.functions = NK.functions || {};
NK.functions.popup = NK.functions.popup || {};

NK.functions.popup.generatePopupMarkup = function (conf) {
  return function (feature) {
    var a = feature.attributes, 
        i,
        l,
        markup = '<article>';

    if (conf.heading && a[conf.heading]) {
      markup += '<h1 class="h">' + a[conf.heading] + '</h1>';
    }
    if (conf.data) {
      for (i = 0, l = conf.data.length; i < l; i += 1) {
        if (conf.data[i].attribute && a[conf.data[i].attribute]) {
          markup += '<p>' + OpenLayers.Lang.translate(conf.data[i].label) + ': ' + a[conf.data[i].attribute] + ' '+ conf.data[i].unit +'</p>';
        }
      }
    }
    markup += '</article>';
    return markup;
  };
};

NK.functions.popup.getFeatureSelector = function (M, markupGeneratorFunction, popupCloseFunction, options) {
  var featureSelector = options.selectControl;
  return function (feature) {
    var popup, 
        message, 
        mousePosition,
        featurePosition,
        popupPosition,
        offset = {},
        sameFidFeatures,
        xOffset,
        yOffset,
        i, j;

    if (feature.cluster) {
      return false;
    }

    if (NK.easyXDM && NK.easyXDM.socket) {
      // there is an active easyXDM socket - send feature data
      message = {
        cmd: 'featureSelected', 
        feature: feature.fid,
        attributes: feature.attributes,
        layer: feature.layer.shortid
      };
      NK.easyXDM.socket.postMessage(JSON.stringify(message));
    }

    if (feature.fid && feature.layer) {

      sameFidFeatures = feature.layer.getFeaturesByFid(feature.fid);
      for (i = 0, j = sameFidFeatures.length; i < j; i += 1) {
        feature.layer.selectedFeatures.push(sameFidFeatures[i]);

        this.highlight.apply(this, [sameFidFeatures[i]]);
      } 
    }

    // find out where to position the popup
    if (options && options.featureCentroidPosition) {
      featurePosition = feature.geometry.getBounds().getCenterLonLat();

      if (featurePosition) {
        xOffset = feature.layer.styleMap.styles[feature.renderIntent].defaultStyle.graphicXOffset || feature.layer.styleMap.styles['default'].defaultStyle.graphicXOffset || 0;
        xOffset += (feature.layer.styleMap.styles[feature.renderIntent].defaultStyle.graphicWidth || feature.layer.styleMap.styles['default'].defaultStyle.graphicWidth) / 2;
        yOffset = feature.layer.styleMap.styles[feature.renderIntent].defaultStyle.graphicYOffset || feature.layer.styleMap.styles['default'].defaultStyle.graphicYOffset || 0;

        if (xOffset || yOffset) {
          offset.x = -5;
          offset.y = -18;
          offset.addX = xOffset;
          offset.addY = yOffset;
        }
      }
    }

    mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
    popupPosition = featurePosition || mousePosition;

    M.panTo(popupPosition);

    popup = new OpenLayers.Popup.FramedSideAnchored(
      "nk-selected-coverage-map", 
      popupPosition,
      null,
      markupGeneratorFunction(feature),
      null, 
      true, 
      popupCloseFunction,
      offset,
      'selected-feature-popup'
    );

    popup.autoSize = true;
    feature.popup = popup;
    popup.feature = feature;
    M.addPopup(popup);
  
  };
};

NK.functions.popup.addConfiguredPopup = function (M, layer, popupConfig) {

  var generatePopupMarkup,
      onFeatureSelect,
      onFeatureUnselect,
      onPopupClose,
      selectControl;
      
  generatePopupMarkup = NK.functions.popup.generatePopupMarkup(popupConfig);

  onPopupClose = function (evt) {
    if (this.feature) {
      selectControl.unselect(this.feature);
    }
  };

  onFeatureSelect = NK.functions.popup.getFeatureSelector(M, generatePopupMarkup, onPopupClose, popupConfig);

  onFeatureUnselect = function (feature) {
      if (feature.popup) {
        feature.popup.feature = null;
        M.removePopup(feature.popup);
        feature.popup.destroy();
        feature.popup = null;
      }
  };

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      onUnselect: onFeatureUnselect,
      highlightOnly: true,
      autoActivate: true
  });
  selectControl.onSelect = OpenLayers.Function.bind(onFeatureSelect, selectControl);

  M.addControl(selectControl);

};





NK.addLayerType = NK.addLayerType || {};

NK.addLayerType.geoJSONFile = (function (M, MP, P) {
  return function (id, name, url, options) {
    var layer,
        layerOptions,
        formatOptions,
        geoJSONFormat;

    formatOptions = {
      'internalProjection': MP,
      'externalProjection': MP 
    };

    // set external projection, if provided  
    if (options.epsgCode && P[options.epsgCode]) {
      formatOptions.externalProjection = P[options.epsgCode];
    }

    geoJSONFormat = new OpenLayers.Format.GeoJSON(formatOptions);

    layerOptions = {
      shortid: id, 
      protocol: new OpenLayers.Protocol.HTTP({
        'url': url,
        'format': geoJSONFormat
      }),
      strategies: [new OpenLayers.Strategy.Fixed({preload: true, autoActivate: true})],
      styleMap: NK.styles.omriss,
      projection: MP,
      displayInLayerSwitcher: (options && options.hideFromLayerSwitcher) ? 0 : 1,
      visibility: (options && options.visible) ? 1 : 0
    };
    if (options) {

      if (options.styleName && NK.styles && NK.styles[options.styleName]) {
        layerOptions.styleMap = NK.styles[options.styleName];
      }

      if (options.styleNameSLD && NK.styles && NK.styles.SLD && NK.styles.SLD[options.styleNameSLD]) {
        layerOptions.styleMap = NK.styles.SLD[options.styleName];
      }

      if (options.label) {
        var tempSM = layerOptions.styleMap;
        layerOptions.styleMap = new OpenLayers.StyleMap(
          {
            'default': tempSM.styles['default'].clone(),
            'select': tempSM.styles.select, 
            'temporary': tempSM.styles.temporary,
            'delete': tempSM.styles['delete']
          }
        );
        layerOptions.styleMap.styles['default'].context = {
          'getLabel': function (feature) {
            return feature.attributes[options.label];
          }
        };

        layerOptions.styleMap.styles['default'].defaultStyle.label = '${getLabel}';
      }

      if (options.cluster && NK.strategies.cluster) {
        layerOptions.strategies.push(NK.strategies.cluster);
      }
    }

    layer = new OpenLayers.Layer.Vector(
      name,
      layerOptions
    );

    if (options) {
      if (options.styleNameSLD && NK.styles && NK.styles.SLD && NK.styles.SLD[options.styleNameSLD]) {
        NK.functions.setSLDStyleForLayer(options.styleNameSLD, layer);
      }

      if (options.cluster) {
        NK.styles.addClusteringRule(layer.styleMap);
      }

      if (options && options.layerGroup) {
        layer = OpenLayers.Util.extend(layer, {'layerGroup': options.layerGroup});
      }

      if (options && options.visible) {
        NK.defaultVisibleLayers = NK.defaultVisibleLayers || [];
        NK.defaultVisibleLayers.push(id);
      }

      if (options && options.popupConfig) {
        NK.functions.popup.addConfiguredPopup(M, layer, options.popupConfig);
      }
    }
    
    M.addLayer(layer);
  };
}(map, mapProj, proj));



(function () {
  var options = {};

  options.layerGroup = 'tjenester.fakta';




  options.styleName = 'unlabeledMarker';



  options.epsgCode = '32633';

  options.popupConfig = (function () {
	var result = {
		'heading': 'OFFISIELT NAVN'
	};
	result.data = [];
	result.data.push({'attribute': 'FYLKESNAVN', 'label': 'Fylke', 'unit': ''});

result.data.push({'attribute': 'KOMMUNENAVN', 'label': 'Kommune', 'unit': ''});

result.data.push({'attribute': 'HOYDE [m]', 'label': 'H&oslash;yde', 'unit': 'm'});

	return result;
}());
;

  NK.addLayerType.geoJSONFile('fjelltopper', 'Kommunenes fjelltopper', '/json/tema/kommunefjell/Kommunefjell.geojson', options);
}());


  var removePopups = function () {
    var popup, p;

    for (p in map.popups) {
      if (map.popups.hasOwnProperty(p)) {
        popup = map.popups[p];

        map.removePopup(popup);
      }
    }
  };

  map.events.register('changelayer', map, removePopups);

  // Add controls at the end, to keep focus
  var controlContext = map;
  var container = null;
  var collect = null;

  NK.status = document.createElement("div");
NK.status.setAttribute("class","toolbar");
NK.status.setAttribute("id","status");
NK.status.messages = {};
document.body.appendChild(NK.status);

NK.status.refresh = function() {
  var content = "", msg, height;
  var now = new Date().getTime();
  for (msg in NK.status.messages) { 
    if (now > parseInt(msg) + 20000) {
      delete NK.status.messages[msg];
    }
  }
  for (msg in NK.status.messages) { 
    content += '<div class="statusmsg">'+NK.status.messages[msg]+'</div>';
  }
  NK.status.innerHTML = content;

  if (!!Object.keys(NK.status.messages).length) {
    $("#status").animate({"max-height": "200px"}); 
  } else {
    $("#status").animate({"max-height": "0px"}); 
  }
}

NK.functions.log = function(msg) {
  var now = new Date().getTime();
  NK.status.messages[new Date().getTime()] = msg;
  NK.status.refresh();
  setTimeout(NK.status.refresh, 21000);
  return now;
}
NK.functions.updateLog = function(time, msg) {
  delete NK.status.messages[time];
  NK.functions.log(msg);
}


NK.functions = NK.functions || {};

/**
 *  used by controls templates to place controls in the correct context
 *
 */
NK.functions.addControlToContext = function (control, context) {
  // utility method to add control to map or panel

  if (context.addControl) {
    // context is a map
    context.addControl(control);
  } else if (context.addControls) {
    // context is a panel
    context.addControls([control]);
  }
};




(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	
options.dragPanOptions = {enableKinetic: false};
NK.functions.addControlToContext(new OpenLayers.Control.Navigation(options), context);
NK.functions.addControlToContext(new OpenLayers.Control.TouchNavigation(options), context);
NK.functions.addControlToContext(new OpenLayers.Control.KeyboardDefaults(options), context);
NK.functions.addControlToContext(new OpenLayers.Control.MousePosition({
	draw: function() {
		return this.div;
	}, 
	redraw: function(evt) {
		if (evt) {
			this.lastXy = evt.xy;
		}
	}
}), context);

}(controlContext, container));


(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
		

NK.functions.addControlToContext(new OpenLayers.Control.ScaleLine({bottomOutUnits:''}), context);

}(controlContext, container));


(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	

NK.functions.addControlToContext(new OpenLayers.Control.Popout(options), context);

}(controlContext, container));


  // initialize URL update state
  if (NK.functions.storeInitialLayerVisibility) {
    NK.functions.storeInitialLayerVisibility();
  }

  var mapPosition = {x: null, y: null};
  if (NK.functions.setMapStateFromURL) {
    mapPosition = NK.functions.setMapStateFromURL();
  }

  // decide which position to use
  if (!(mapPosition.x && mapPosition.y)) {
    map.setCenter(NK.defaultCenter, NK.defaultZoom);

    if (NK.geolocator) {
      NK.geolocator.activate();
    } 
  }

  if (NK.functions.postMessage) {
    (function () {
      var vectorLayers,
          layer,
          feature,
          vectorLayerData = [],
          vectorFeatureData = [],
          i, 
          j,
          k,
          l,
          message;

      vectorLayers = map.getLayersByClass("OpenLayers.Layer.Vector").slice();

      for (i = 0, j = vectorLayers.length; i < j; i += 1) {
        layer = vectorLayers[i];
        vectorLayerData.push({shortid: layer.shortid, name: layer.name, visibility: layer.visibility});

        if (layer.visibility && layer.features && layer.features.length) {

          for (k = 0, l = layer.features.length; k < l; k += 1) {
            feature = layer.features[k];
            vectorFeatureData.push({
              "feature": feature.fid,
              "attributes": feature.attributes
            });
          }

        }
      }

      message = {
        "type": "mapInitialized",
        "vectorLayers": vectorLayerData
      };

      if (vectorFeatureData.length > 0) {
        message.visibleLayerFeatures = vectorFeatureData;
      }

      NK.functions.postMessage(message);
    }());

  }
  map.addControl(new OpenLayers.Control.Attribution());

};
// end init()


var addEvent = function(event, handler) {
  var listen = window.addEventListener || window.attachEvent;
  if (window.addEventListener) {
    listen(event, handler, false);
  } else {
    listen("on" + event, handler);
  }
};

var cb = function(response, status, request) {
  NK.gkToken = request.responseText.replace(/[\"\r\n]/g, '');
};
var startTicket = function(response, status, request) {
  NK.encTicket = request.responseText.replace(/[\"\r\n]/g, '');
  NK.init();
};

var initializeToken = function () {
  $.ajax({
    url: NK.ticketService,
    success: startTicket,
    type: 'GET'
  });
  $.ajax({
    url: NK.tokenService, 
    success: cb,
    type: 'GET'
  });
};
addEvent('load', initializeToken);


"use strict";

var NK = NK || {};
NK.mapEventListeners = {};

var gkopen, 
    gkopen_wmts,
    proj,
    mapProj,
    mapBounds,
    xdmsocket,
    initLayers,
    postEvent,
    map;

gkopen = "http://opencache.statkart.no/gatekeeper/gk/gk.open";
gkopen_wmts = "http://opencache.statkart.no/gatekeeper/gk/gk.open_wmts";

NK.gkToken = "unInitialized";
NK.encTicket = "unInitialized";

NK.tokenService = "/ws/gkt.py";

NK.ticketService = "/ws/esk.py?wms.ecc_enc";

NK.baseProjection = "32633";
NK.baseProjection = "32633";

NK.tokenLastUpdated = new Date(0);
NK.ticketLastUpdated = new Date(0);
NK.tokenUpdatePaused = false;
NK.ticketUpdatePaused = false;

  (function() {
var translations = {};

translations['Server error'] = 'Feil med tjenesten';
translations['An error has occured.'] = 'Ett eller flere kartlag vises ikke som de skal.';
translations['Reloading maps in'] = 'Pr&oslash;ver &aring; laste kartlagene p&aring; nytt om';
translations['minutes.'] = 'minutter.';
translations['minute.'] = 'minutt.';

OpenLayers.Util.extend(OpenLayers.Lang['nb'], translations);
}());


NK.tokenError = {
  PAUSE_MINUTES: 2,
  RELOAD_LIMIT_SECONDS: 15,
  messagePopup: null,
  pauseTimeRemainingElement: null,
  pauseTimeRemainingText: null,
  pauseTimer: null,
  pauseCountdownTimer: null
};
NK.ticketError = {
  PAUSE_MINUTES: 2,
  RELOAD_LIMIT_SECONDS: 15,
  messagePopup: null,
  pauseTimeRemainingElement: null,
  pauseTimeRemainingText: null,
  pauseTimer: null,
  pauseCountdownTimer: null
};



NK.mapservers = {};
NK.mapservers.wmts = [
  "http://gatekeeper1.geonorge.no/BaatGatekeeper/gk/gk.cache_wmts",
  "http://gatekeeper2.geonorge.no/BaatGatekeeper/gk/gk.cache_wmts",
  "http://gatekeeper3.geonorge.no/BaatGatekeeper/gk/gk.cache_wmts"
];
NK.zoomLevels = 18;

NK.functions = NK.functions || {};

NK.functions.resetTokenError = function () {
  if (NK.tokenError.pauseTimeRemainingElement) {
    NK.tokenError.pauseTimeRemainingElement.parentNode.removeChild(NK.tokenError.pauseTimeRemainingElement);
    NK.tokenError.pauseTimeRemainingElement = null;
  }
  if (NK.tokenError.messagePopup) {
    NK.tokenError.messagePopup.parentNode.removeChild(NK.tokenError.messagePopup);
    NK.tokenError.messagePopup = null;
  }
  if (NK.tokenError.pauseTimer) {
    clearTimeout(NK.tokenError.pauseTimer);
    NK.tokenError.pauseTimer = null;
  }
  if (NK.tokenError.pauseCountdownInterval) {
    clearInterval(NK.tokenError.pauseCountdownInterval);
    NK.tokenError.pauseCountdownInterval = null;
  }
};

NK.functions.resetTicketError = function () {
  if (NK.ticketError.pauseTimeRemainingElement) {
    NK.ticketError.pauseTimeRemainingElement.parentNode.removeChild(NK.ticketError.pauseTimeRemainingElement);
    NK.ticketError.pauseTimeRemainingElement = null;
  }
  if (NK.ticketError.messagePopup) {
    NK.ticketError.messagePopup.parentNode.removeChild(NK.ticketError.messagePopup);
    NK.ticketError.messagePopup = null;
  }
  if (NK.ticketError.pauseTimer) {
    clearTimeout(NK.ticketError.pauseTimer);
    NK.ticketError.pauseTimer = null;
  }
  if (NK.ticketError.pauseCountdownInterval) {
    clearInterval(NK.ticketError.pauseCountdownInterval);
    NK.ticketError.pauseCountdownInterval = null;
  }
};

NK.functions.updateToken = function (request) {
  var i, 
      j, 
      reloadLimit;

  reloadLimit = new Date(Date.now() - NK.tokenError.RELOAD_LIMIT_SECONDS * 1000);

  NK.gkToken = request.responseText.replace(/[\"\r\n]/g, '');

  if (NK.tokenLastUpdated < reloadLimit) { // was token updated less than RELOAD_LIMIT_SECONDS ago?
    if (!NK.tokenUpdatePaused) {
      NK.functions.resetTokenError();
      NK.tokenLastUpdated = new Date();

      for (i = 0, j = map.layers.length; i < j; i += 1) {
        if (map.layers[i].params && map.layers[i].params.gkt) {
          map.layers[i].params.gkt = NK.gkToken;
          map.layers[i].redraw();
        }
      }
    }
  } else {
    NK.functions.pauseTokenUpdate();
  }
};
NK.functions.updateTicket = function (request) {
  var i,
    j,
    reloadLimit;

  reloadLimit = new Date(Date.now() - NK.ticketError.RELOAD_LIMIT_SECONDS * 1000);

  NK.encTicket = request.responseText.replace(/[\"\r\n]/g, '');

  if (NK.tokenLastUpdated < reloadLimit) { // was token updated less than RELOAD_LIMIT_SECONDS ago?
    if (!NK.ticketUpdatePaused) {
      NK.functions.resetTicketError();
      NK.ticketLastUpdated = new Date();

      for (i = 0, j = map.layers.length; i < j; i += 1) {
        if (map.layers[i].params && map.layers[i].params.ticket) {
          map.layers[i].params.ticket = NK.encTicket;
          map.layers[i].redraw();
        }
      }
    }
  } else {
    NK.functions.pauseTicketUpdate();
  }
};

NK.functions.pauseTokenUpdate = function () {
  if (!NK.tokenUpdatePaused) {
    NK.tokenUpdatePaused = true;

    NK.functions.log(OpenLayers.Lang.translate('Server error') +" - "+ OpenLayers.Lang.translate('An error has occured.'));

    NK.tokenError.pauseTimer = setTimeout(function () {
      NK.tokenUpdatePaused = false;
      NK.functions.getNewToken();
    },  60 * parseInt(NK.tokenError.PAUSE_MINUTES, 10) * 1000);

    NK.tokenError.pauseCountdownInterval = setInterval(function () {
      var content, timeLeft;
      if (NK.tokenError.pauseTimeRemainingElement) {
        content = NK.tokenError.pauseTimeRemainingElement.innerHTML;
        timeLeft = (parseInt(content, 10) - 1);
        NK.tokenError.pauseTimeRemainingElement.innerHTML = timeLeft.toString();
        if (timeLeft === 1) {
          if (NK.tokenError.pauseTimeRemainingText.textContent) {
            NK.tokenError.pauseTimeRemainingText.textContent = ' ' + OpenLayers.Lang.translate('minute.');
          } else {
            // old IE...
            NK.tokenError.pauseTimeRemainingText.innerText = ' ' + OpenLayers.Lang.translate('minute.');
          }
        }
      }
    }, 60 * 1000);
  }
};
NK.functions.pauseTicketUpdate = function () {
  if (!NK.ticketUpdatePaused) {
    NK.ticketUpdatePaused = true;

    NK.functions.log(OpenLayers.Lang.translate('Server error') +" - "+ OpenLayers.Lang.translate('An error has occured.'));

    NK.ticketError.pauseTimer = setTimeout(function () {
      NK.ticketUpdatePaused = false;
      NK.functions.getNewTicket();
    },  60 * parseInt(NK.ticketError.PAUSE_MINUTES, 10) * 1000);

    NK.ticketError.pauseCountdownInterval = setInterval(function () {
      var content, timeLeft;
      if (NK.ticketError.pauseTimeRemainingElement) {
        content = NK.ticketError.pauseTimeRemainingElement.innerHTML;
        timeLeft = (parseInt(content, 10) - 1);
        NK.ticketError.pauseTimeRemainingElement.innerHTML = timeLeft.toString();
        if (timeLeft === 1) {
          if (NK.ticketError.pauseTimeRemainingText.textContent) {
            NK.ticketError.pauseTimeRemainingText.textContent = ' ' + OpenLayers.Lang.translate('minute.');
          } else {
            // old IE...
            NK.ticketError.pauseTimeRemainingText.innerText = ' ' + OpenLayers.Lang.translate('minute.');
          }
        }
      }
    }, 60 * 1000);
  }
};

NK.functions.getNewToken = function () {
  if (NK.gkToken !== null) {
    NK.gkToken = null;
    OpenLayers.Request.GET({url: NK.tokenService, success: NK.functions.updateToken});
  }
};
NK.functions.getNewTicket = function () {
  if (NK.encTicket !== null) {
    NK.encTicket = null;
    OpenLayers.Request.GET({url: NK.ticketService, success: NK.functions.updateTicket});
  }
};

var closePopupCallBack = function () {
  var itemIndex;
  for (itemIndex = 0; itemIndex < map.popups.length; itemIndex++) {
    map.popups[itemIndex].hide();
  }
  this.hide();
};

  var NK = NK || {};
NK.functions = NK.functions || {};

NK.functions.updateHistory = function (evt) {
  var center,
      zoom,
      i,
      layer,
      uid,
      search,
      searchInput;

  if (!!map) {
    center = map.getCenter();
    zoom   = map.getZoom();

    if (!!center && !!zoom) {
      uid = zoom + "/" + Math.round(center.lon) + "/" + Math.round(center.lat); 
      /* 1m precision ought to be enough for everyone --BG */

      if (!!NK.initLayers && !!map.layers) { 
        for (i in map.layers) {
          if (map.layers.hasOwnProperty(i)) {
            layer = map.layers[i];
            if (!layer.isBaseLayer) {
              if (!layer.isUrlDataLayer) {
                if (layer.visibility) {
                  if ($.inArray(layer.shortid, NK.initLayers) === -1 && typeof layer.shortid !== 'undefined') {
                    uid += "/+" + layer.shortid;
                  }
                } else {
                  if ($.inArray(layer.shortid, NK.initLayers) > -1 && typeof layer.shortid !== 'undefined') {
                    uid += "/-" + layer.shortid;
                  }
                }
              } else {
                if (layer.isDrawing) {
                  uid += '/l/drawing/' + encodeURIComponent(layer.url) + '/' + layer.epsgCode;
                } else {
                  uid += '/l/geojson/' + encodeURIComponent(layer.url) + '/' + layer.epsgCode;
                }
              }
            }
          }
        }
      }
    }
    searchInput = document.getElementById('searchInput');
    if (!!searchInput) {
      search = searchInput.value;
      if (history.replaceState) {
        if (!!search) {
          if (!!history.state) {
            if (history.state.hash != uid) {
              history.replaceState({'search': 'sok=' + search, 'hash': uid}, document.title, '?sok=' + encodeURIComponent(search) + '#' + uid);
            }
          } else {
            history.replaceState({'search': 'sok=' + search, 'hash': uid}, document.title, '?sok=' + encodeURIComponent(search) + '#' + uid);
          }
        } else {
          if (!!history.state) {
            if (history.state.hash != uid) {
              history.replaceState({'hash': uid}, document.title, '#' + uid);
            }
          } else {
            history.replaceState({'hash': uid}, document.title, '#' + uid);
          }
        }
      } else {
        window.location.hash = uid;
      }
    }
    NK.functions.updateScaleLine();
  }
};

NK.mapEventListeners = NK.mapEventListeners || {};
NK.mapEventListeners.moveend = NK.functions.updateHistory;
NK.mapEventListeners.zoomend = NK.functions.updateHistory;
NK.mapEventListeners.changelayer = NK.functions.updateHistory;
NK.mapEventListeners.changebaselayer = NK.functions.updateHistory;

NK.functions.updateScaleLine = function () {
    var layers, scaleLine;
    if (!!self.map){
        layers = self.map.getLayersByName("Sj&oslash;")[0];
        if (!!layers) {
            if(layers.getVisibility()) {
                //NK.functions.addControlToContext(new OpenLayers.Control.ScaleLine({bottomOutUnits:'nm '}));
                scaleLine = map.getControlsByClass('OpenLayers.Control.ScaleLine');
                if (scaleLine.length > 0){
                    scaleLine[0].bottomOutUnits = 'nm';
                    scaleLine[0].bottomInUnits = 'nm';
                    scaleLine[0].eBottom.style.visibility = "visible";
                }
            } else {
                scaleLine = map.getControlsByClass('OpenLayers.Control.ScaleLine');
                if (scaleLine.length > 0){
                    scaleLine[0].bottomOutUnits = '';
                    scaleLine[0].bottomInUnits = '';
                    scaleLine[0].eBottom.style.visibility = "hidden";
                }
            }
        }
    }
}


NK.styles = NK.styles || {};
NK.styles.labeledMarker = new OpenLayers.StyleMap(
	{
		'default': new OpenLayers.Style(
			{
				fillOpacity: 1, 
				label : '${getLabel}',
				fontColor: "#fff",
				fontSize: "12px",
				pointRadius: 0,
				fontFamily: "Arial, Courier New, monospace",
				fontWeight: "bold",
				fillColor: "transparent",
				labelAlign: "cm",
				labelXOffset: 11,
				labelYOffset: 33,
				graphicWidth: 44,
				graphicHeight: 56,
				graphicYOffset: -55,
				graphicXOffset: -11,
				externalGraphic: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAA5CAYAAACiXaIXAAAGqElEQVR4XtWZW2xURRjHv3PbW7vdC21XirBUSwFrsLUJaEKEkmLEhIYYX0pfIDE+aJr4YIwm8mRiYkiQR8XwICo1PpgIxoK9kEJt6qWxEohUpC2u7tJLtt3uLnvuxznhjFtncnJ23a6wX/LPNzObdH7z7zdnd+Ywhw4dgvsZ586dg2KDL2EyphTYrq4uA/5j8CWAOrWxDLoNBrFooyjoEmAZLKIPFDSdDaLPFAPPFwxLA7IEOPk5DZqXToDn4QsA5x2BaSdZnE2RYxjaAVYn2kW5zjsBE2IJcUSfcJwCNqVZGYvB7UJd5wsBJkFJEQsg61ongEkRGxIvpDinaWAalifEmdqxY8djfr//EY7j/IBCUZSFlZWV29evX/9tFaSKMxae0xpnset28LzDxsPAJKhgiW9tbX2yvr6+2+12P6NX1YU0dwh0zgWGAeBVshCSUtDY2DgvSdJQPB4/ixYwZa6HKCkMDHn37cuEL8BljoB1mbmtra29rq6uxxXa0CVG2iAViILGeRGsAToCNnSUrTYrZ+o9K9Pd0Zqr3Q0NDZ/FYrEzN27cuAUAMl0eGBC7be80Xcu0yxjY3dHR8Up1qP418eHdsLJuGxhggRLAeEzhfSCFWtDCtoM/ea2nqWqiJxKJvDMyMnKGhqYXgN2moB2AeQzc2dn5lmfdxqPZLV2gCtWOwLollFBmIBl8HNLeBtjAfnts37594eHh4ZMY0EaU27z9E4N2GU3S66mNHs1uexE0hi8OWM/3c0IIZjYchEbjq1f37NmTRI5/vPop4/QUYQmXgQD+B3rnzp27q4J1vdmmgyUB489lxgMzkWfBHwwfa25ubsQbm3j2MwQXhnYsD1NCOBw+LEY7QBOqSgW2xgDu8kFIBFohGo0eoaFp8GKg+V27du3lwtH9UvDRNQPG43d824Grru1paWnZSnwXMFh0eTi7zIdCoW4x0r62wLiPEOJVLYAehYdtygMcnKbgufXr14cFX81eORBdc2DD6i94NoPH43meKItCnaa1adOmJ1RfPejAlAXYlMIIkBOCAVQizTSwPTRj57bP59uqemvLBoyNuMsFIBAINNlsPoeNSLjOcVxA59zlA7b6MuMGQRDCNqci2mkHcQYwZQU2rM8cgoa2Ox5pmpZklFxZgc02b0igqmqKmL8gaCChRVGc5qSlsgKbYz4tDel0epoAXpVpaMNG+uzs7E+ubAJNoJcNmNNlqNaWAf1cnaLOjkiOThNnOi2RSCQ1MTPuyv5ZFmAz1ykxkMTclzIKc04C2BHaoM90oKZSqb6axZ/LAmzybRZ/hbm5uT5zLmJ++/KwOTlrWGNjYxfYpdkrnvTtNQVGI9Ag3QImu/DFLyjycxbvtEE6jaQsLy/31c6PAaPm1gzYo6WhWbwKqATPWudGtRBw1u5xR5ye1fHx8QF5+c4HDYlBRKGVDMzqMrRnL0NuJXn8Ggo8TyElwuIbTCenkeShoaETzNLs+WiiH1g1V5LDT2cGADLzpy9duvSRdcBVCGDCYefyMEhoDP5HLPapkZyBpjvnwX83VjTwQ/IsPJUZBC2VOD44OPgeAEj47xOlYQrsa5p2W6fdBtmU1+v1i6IIYjIBG+P9sHXhIgRyMUSp2gKzugIREzZ9EZqXLn89F5s+jBz+0AKWHeoZCrn3+Dc8ES6Xq5plWVA1DdKZDAjiTdiciUGT2wspIQIi6wOFcQFj6MAZCni0DITUeZAl8ZvFxcW+iYmJ74n/XqEbkIbGbuOTuQ20IQiC34Q2rFLA8IAk8EuAVgQsw9ybUddvZrPZdy9OTv6w6otDJaTRwPQGpKHt3QYC3OA5rgZDr5YZpvtgygzDUOLx+MvT09Oz9heQNHAx99O02zS4YYrluCCDnDQDZQyNQfGMgIw9gYCn6D1CX/cSDhMl6gBNg9OX3cjl4Gpg3DbD7DP38szU1NRJk528UCdB7WvY3nHilZzz64vO/fsvoNyJgbFW9yVJeuG70dEBh1+QhLM0cIHQzvAI+keU2ingfPvz4aGhI06HC6oESn9RRJcLhkcRJkHRGG5mkMtvWjVrBw1FwTo77aycKKZRqsZ9wvHXBwcG3neCwUaU+40tBnblgSlNIsdPIhgdyhwsFBdhsI9er8eDy6IioE8j4FH4n4LBG8pJzx04YKbdSFcIgCTSFisXHBf6+++r028TwA98eYwinUKCSoHWkHrNXDHQlsOTSPCgQ9dZ+S+kN/BgRThtAWcqCXoE6SwSVAp0NdJLSFBJ0J8g/V5p0KfgAYi/AQ0R+7KQtU9QAAAAAElFTkSuQmCC'
			},
			{
				context: {
					getLabel: function (feature) {
					console.dir(feature);
						return feature.attributes.label || '';
					}
				}
			}
		),
		'select': new OpenLayers.Style(
			{
				fillOpacity: 1
			}
		),
		'temporary': new OpenLayers.Style(
			{
				fillOpacity: 1
			}
		)		
	}
);



NK.functions.storeInitialLayerVisibility = function () {
  // store the initial layer visibility configuration
  var i, 
      layer;

  NK.initLayers = [];

  for (i in map.layers) {
    if (map.layers.hasOwnProperty(i)) {
      layer = map.layers[i];
      if (layer.visibility) {
        if ((!NK.defaultVisibleLayers || !$.inArray(layer.shortid, NK.defaultVisibleLayers)) && !layer.isUrlDataLayer) {
          NK.initLayers.push(layer.shortid);
        }
      }
    }
  }
};

NK.functions.setMapStateFromPopState = function (evt) {
  if (evt && evt.originalEvent && evt.originalEvent.state) {
    NK.functions.setMapState({'search': evt.originalEvent.state.search, 'hash': evt.originalEvent.state.hash});
  }
};

$(window).on('popstate', NK.functions.setMapStateFromPopState);

NK.functions.addLabeledMarker = function (params, number, okToHide) {
  var layers, 
      layer, 
      x, 
      y, 
      label,
      feature,
      popup,
      properties,xy, pWSG84, pUTM;

  layers = map.getLayersBy('shortid', 'pekere');
  if (layers.length > 0) {
    layer = layers[0];
  } else {
    layer = new OpenLayers.Layer.Vector("Mark&oslash;rer", {shortid: 'pekere', styleMap: NK.styles.labeledMarker});
    map.addLayer(layer);
  }

  x = params[0];
  y = params[1];

  if ((y > 0) && (y < 35) && (x > 50) && (x < 90)) {  /* we are dealing with WSG84 coordinates here */
    pWSG84 = new Proj4js.Proj('EPSG:4326');
    pUTM = new Proj4js.Proj('EPSG:' + NK.baseProjection);
    xy = Proj4js.transform(pWSG84, pUTM, new Proj4js.Point(y, x));
    x = xy.x;
    y = xy.y;
  }

properties = {};

  if ((params.length > 2) && (!!params[2])) {
    properties.popupText = decodeURIComponent(params[2]);
  }  
  if (number) {
    properties.nr = number;
  } else {
    properties.nr = '';
  }

  feature = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.Point(x, y), properties);

  popup = new OpenLayers.Popup.FramedSideAnchored(
    "nk-user-marker" + (number ? '-' + number : ''), 
    feature.geometry.getBounds().getCenterLonLat(),
    null,
    '<span class="label-text">' + feature.data.popupText + '</span>',
    null, 
    false, 
    null, //onPopupClose
    {x: 10, y: -65},
    'user-marker'
  );

  popup.autoSize = true;
  popup.panMapIfOutOfView = false;

  if (!okToHide || !!feature.data.popupText) {
    feature.popup = popup;
    map.addPopup(popup);
    popup.show();
  }

  layer.addFeatures([feature]);
  return feature;
};

NK.functions.parseParamsAndAddDataLayerFromUrl = function (params) {
  var type,
      url,
      epsgCode;

  type = params[0];
  url = decodeURIComponent(params[1]);
  epsgCode = params[2];

  switch (type) {
    case 'geojson':
      NK.functions.addGeoJsonLayer(url, epsgCode);
      break;
    case 'drawing':
      NK.functions.addGeoJsonLayer(url, epsgCode, {'isDrawing': true});
      break;
  }

};

NK.functions.addGeoJsonLayer = function (url, epsgCode, extensionProperties) {
  var mapProjection,
      formatOptions,
      geoJSONFormat,
      layerOptions,
      layer,
      correctEpsgCode,
      layerExtensions;

  formatOptions = {
    'internalProjection': map.getProjection(),
    'externalProjection': map.getProjection()
  };

  /* set external projection, if provided  */

  if (epsgCode && NK.projections[epsgCode]) {
    formatOptions.externalProjection = NK.projections[epsgCode];
    correctEpsgCode = epsgCode;
  } else {
    correctEpsgCode = NK.baseProjection;
  }

  geoJSONFormat = new OpenLayers.Format.GeoJSON(formatOptions);

  layerOptions = {
    shortid: 'urlDataLayer_' + NK.functions.urlDataLayerCounter, 
    protocol: new OpenLayers.Protocol.HTTP({
      'url': url,
      'format': geoJSONFormat
    }),
    strategies: [new OpenLayers.Strategy.Fixed({preload: true, autoActivate: true})],
    styleMap: NK.styles.track,
    projection: mapProjection,
    displayInLayerSwitcher: false,
    visibility: true
  };

  layer = new OpenLayers.Layer.Vector(
    'urlDataLayer_' + NK.functions.urlDataLayerCounter++,
    layerOptions
  );

  layerExtensions = {
    'isUrlDataLayer': true,
    'epsgCode': correctEpsgCode,
    'url': url
  };

  if (extensionProperties) {
    layerExtensions = OpenLayers.Util.extend(layerExtensions, extensionProperties); 
  }

  layer = OpenLayers.Util.extend(layer, layerExtensions);

  map.addLayers([layer]);
};

NK.functions.urlDataLayerCounter = 0;
NK.functions.setMapState = function (params) {
  var parms,
      zoom,
      mapx,
      mapy,
      xy,
      index,
      extra,
      setLayerVisibility,
      showLayerNamed,
      hideLayerNamed,
      highlight,
      search,
      searchArray,
      searchInputField,
      i, j, p,
      hash,
      labeledMarkerCount = 0,
      pWSG84,
      pUTM33;

  search = params.search;
  hash = params.hash;

  if (params.search) {
    search = search.replace('?', '');
    searchArray = search.split('&');
    for (i = 0, j = searchArray.length; i < j; i += 1) {
      p = searchArray[i].split('=');
      if (p[0] === 'sok') {
        p[1] = decodeURIComponent(p[1]);
        searchInputField = document.getElementById('searchInput');
        if (searchInputField) {
          searchInputField.value = p[1];
        }
        map.events.triggerEvent('searchForPhrase', {'phrase': p[1]});
      }
    }
  }

  if (!!hash) {
    parms = hash.split("/");
    if (parms.length >= 3) {
      zoom = parms[0];
      mapx = parms[1];
      mapy = parms[2];

      if ((mapy > 0) && (mapy < 35) && (mapx > 50) && (mapx < 90)) {  /* we are dealing with WSG84 coordinates here */
        pWSG84 = new Proj4js.Proj('EPSG:4326');   
        pUTM = new Proj4js.Proj('EPSG:'+NK.baseProjection);   
        xy = Proj4js.transform(pWSG84, pUTM, new Proj4js.Point(mapy, mapx));
        mapx = xy.x;
        mapy = xy.y;
      }
    }

    setLayerVisibility = function (layerName, visibility) {
      var i, 
          j,
          layer,
          layerSwitcherPresent;

      layerSwitcherPresent =  map.getControlsByClass('OpenLayers.Control.RasterOverlayLayerSwitcher').length > 0;

      for (i = 0, j = map.layers.length; i < j; i += 1) {
        layer = map.layers[i];
        if (layer.shortid === layerName) {
          if (layerSwitcherPresent && visibility && layer.displayInLayerSwitcher && !layer.isBaseLayer && (layer.CLASS_NAME === "OpenLayers.Layer.WMTS" || layer.CLASS_NAME === "OpenLayers.Layer.WMS")) {
              map.events.triggerEvent('rasterLayerChangeRequest', {'shortId': layerName});
          } else {
            layer.setVisibility(visibility);
          }
        }
      }         
    };

    showLayerNamed = function (layerName) {
      return setLayerVisibility(layerName, true);
    };
    
    hideLayerNamed = function (layerName) {
      return setLayerVisibility(layerName, false);
    };

    highlight = function (highlightParam) {
      var select, 
          layers,
          layer;

      select = highlightParam.slice(1).split("!");
      layers = map.getBy("layers", "shortid", select[0]);

      if (layers.length === 1) {
        layer = layers[0];

        /* set a new renderer rule to highlight elements with the given name */
        layer.styleMap.styles['default'].addRules([
          new OpenLayers.Rule({
            filter: new OpenLayers.Filter.FeatureId({
              fids: [select[1]]
            }),
            symbolizer: {
              strokeWidth: 3,
              strokeColor : "orange",
              graphicZIndex: 2,
              fillColor : "orange",
              fillOpacity: 0.1
            }
          }),
          new OpenLayers.Rule({
            elseFilter: true,
            symbolizer: {}
          })
        ]);

        layer.styleMap.styles.temporary.addRules([
          new OpenLayers.Rule({
            filter: new OpenLayers.Filter.FeatureId({
              fids: [select[1]]
            }),
            symbolizer: {
              strokeWidth: 3,
              strokeColor: "yellow",
              fillColor  : "orange",
              fillOpacity: 0.2,
              graphicZIndex: 100
            }
          }),
          new OpenLayers.Rule({
            elseFilter: true,
            symbolizer: {}
          })
        ]); 
      }
    };

    for (index = 3; index < parms.length; index += 1) {
      extra = parms[index];
      switch (extra.charAt(0)) {
        case '+':
          showLayerNamed(extra.slice(1));
          break;
        case '-':
          hideLayerNamed(extra.slice(1));
          break;
        case '!':
          highlight(extra);
          break;
        case 'm':
          setTimeout(
            (function (boundParameters, boundCounter){
              return function () {
                console.log('boundCounter: ' + boundCounter);
                NK.functions.addLabeledMarker(boundParameters, boundCounter, true);  
              };
            }(parms.slice(index + 1, index + 4), ++labeledMarkerCount)),
            500
          );
          index += 3;
          break;
        case 'l':
          NK.functions.parseParamsAndAddDataLayerFromUrl(parms.slice(index + 1, index + 4));
          index += 3;
          break;
      }
    }
    if (mapx && mapy && zoom) {
      map.setCenter(new OpenLayers.LonLat(mapx, mapy), zoom);
    }
  }
  var result = {
    'x': mapx,
    'y': mapy,
    'zoom': zoom
  };
  return result;
};

NK.functions.setMapStateFromURL = function () {
  // adjust layer visibility and pan/zoom based on hash, if available

  var hash,
      search;

  search = window.location.search;
  hash = window.location.href.split("#")[1]; // avoids window.location.hash because Firefox automatically decodes URI encoded hashes


  return NK.functions.setMapState({'search': search, 'hash': hash});
};


NK.functions = NK.functions || {};
NK.functions.vector = NK.functions.vector || {};

NK.functions.vector.markAllById = function (layer, intent, preserveIntent) {
  return function(element, evt) {
    if (preserveIntent && element.feature.renderIntent === preserveIntent) {
      return false;
    }
    // highlight all elements with the same element.feature.fid
    var ident = layer.getFeaturesByFid(element.feature.fid);
    $.each(ident, function (i, feature) {

      if (preserveIntent && feature.renderIntent === preserveIntent) {
        return false;
      } else {
        feature.renderIntent = intent;
        layer.drawFeature(feature);
      }
    });
  };
};

NK.functions.vector.addVectorHoverControls = function (map, layer, options) {
  var hoverCtrl,
      selectFeatureProperties;

  selectFeatureProperties = {
      hover: true,
      highlightOnly: true,
      renderIntent: "temporary"
  };

  if (options && options.groupByFid) {
    selectFeatureProperties.eventListeners = {
        beforefeaturehighlighted: NK.functions.vector.markAllById(layer, "temporary", options.preserveIntent),
        featureunhighlighted: NK.functions.vector.markAllById(layer, "default", options.preserveIntent)
    };
  }

  hoverCtrl = new OpenLayers.Control.SelectFeature(
    layer,
    selectFeatureProperties
  );


  map.addControl(hoverCtrl);
  hoverCtrl.activate();
  return hoverCtrl;
};

NK.functions.vector.addVectorControls = function (map, layer, options) {
  var controls = {};

  controls.hover = NK.functions.vector.addVectorHoverControls(map, layer, options);

  return controls;
};






NK.init = function () {

  var prmstr,
      prmarr,
      params,
      tmparr,
      i,
      j;

  if (!OpenLayers || !Proj4js) {
    setTimeout(NK.init, 100);
    return;
  }

  Proj4js.defs["EPSG:4326"] ="+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";
  Proj4js.defs["EPSG:32631"]="+proj=utm +zone=31 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32632"]="+proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32633"]="+proj=utm +zone=33 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32634"]="+proj=utm +zone=34 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32635"]="+proj=utm +zone=35 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32636"]="+proj=utm +zone=36 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:25831"]="+proj=utm +zone=31 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25832"]="+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25833"]="+proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25834"]="+proj=utm +zone=34 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25835"]="+proj=utm +zone=35 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25836"]="+proj=utm +zone=36 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:3575"] ="+proj=laea +lat_0=90 +lon_0=10 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:3034"] ="+proj=lcc +lat_1=35 +lat_2=65 +lat_0=52 +lon_0=10 +x_0=4000000 +y_0=2800000 +ellps=GRS80 +units=m +no_defs";

  NK.projections = proj = {  
    //pregenerated projection objects
    "32633": new OpenLayers.Projection('EPSG:32633'),
    "32631": new OpenLayers.Projection('EPSG:32631'),
    "32632": new OpenLayers.Projection('EPSG:32632'),
    "32634": new OpenLayers.Projection('EPSG:32634'),
    "32635": new OpenLayers.Projection('EPSG:32635'),
    "32636": new OpenLayers.Projection('EPSG:32636'),
    "25831": new OpenLayers.Projection('EPSG:25831'),
    "25832": new OpenLayers.Projection('EPSG:25832'),
    "25833": new OpenLayers.Projection('EPSG:25833'),
    "25834": new OpenLayers.Projection('EPSG:25834'),
    "25835": new OpenLayers.Projection('EPSG:25835'),
    "25836": new OpenLayers.Projection('EPSG:25836'),
    "4326" : new OpenLayers.Projection('EPSG:4326'),
    "3034" : new OpenLayers.Projection('EPSG:3034'),
    "3575" : new OpenLayers.Projection('EPSG:3575')
  };

  mapProj = proj[NK.baseProjection];
  mapBounds = new OpenLayers.Bounds(-2500000.0,3500000.0,3045984.0,9045984.0);

  OpenLayers.Util.onImageLoadErrorColor = 'transparent';
  OpenLayers.ImgPath = 'img/';

  OpenLayers.Lang.setCode('nb');

  // extract URL parameters into dictionary
  prmstr = window.location.search.substr(1);
  prmarr = prmstr.split ("&");
  params = {};

  for (i = 0, j = prmarr.length; i < j; i += 1) {
    tmparr = prmarr[i].split("=");
    params[tmparr[0]] = tmparr[1];
  }

  // Create map canvas

  if (!!params.proj) {
    mapProj = proj[params.proj]; 
  }
var options = {
};

  NK.mapOptions = {
    projection: mapProj,
    displayProjection: mapProj,
    maxExtent:  mapBounds,
    units: "m",
    maxResolution: 21664.0,
  //      minResolution: 0.165283203125,
    numZoomLevels: NK.zoomLevels,
  theme: 'theme/norgeskart/style.css'
  };

  map = new OpenLayers.Map( 
    'map', 
    OpenLayers.Util.extend(NK.mapOptions, {
      controls: [], //defined later
      numZoomLevels: NK.zoomLevels,
      eventListeners: NK.mapEventListeners
    })
  );

  // Default placement and zoom of the map
  NK.defaultCenter = new OpenLayers.LonLat(378604,7226208);
NK.defaultZoom = 5;


  // load SLD styles
  
NK = NK || {};
NK.styles = NK.styles || {};
NK.styles.unlabeledMarker = new OpenLayers.StyleMap(
	{
		'default': new OpenLayers.Style(
			{
				fillOpacity: 1, 
				pointRadius: 0,
				fontFamily: "Arial, Courier New, monospace",
				fontWeight: "bold",
				fillColor: "transparent",
				graphicWidth: 44,
				graphicHeight: 56,
				graphicYOffset: -55,
				graphicXOffset: -11,
				zIndex: 0,
				externalGraphic: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAA5CAYAAACiXaIXAAAGqElEQVR4XtWZW2xURRjHv3PbW7vdC21XirBUSwFrsLUJaEKEkmLEhIYYX0pfIDE+aJr4YIwm8mRiYkiQR8XwICo1PpgIxoK9kEJt6qWxEohUpC2u7tJLtt3uLnvuxznhjFtncnJ23a6wX/LPNzObdH7z7zdnd+Ywhw4dgvsZ586dg2KDL2EyphTYrq4uA/5j8CWAOrWxDLoNBrFooyjoEmAZLKIPFDSdDaLPFAPPFwxLA7IEOPk5DZqXToDn4QsA5x2BaSdZnE2RYxjaAVYn2kW5zjsBE2IJcUSfcJwCNqVZGYvB7UJd5wsBJkFJEQsg61ongEkRGxIvpDinaWAalifEmdqxY8djfr//EY7j/IBCUZSFlZWV29evX/9tFaSKMxae0xpnset28LzDxsPAJKhgiW9tbX2yvr6+2+12P6NX1YU0dwh0zgWGAeBVshCSUtDY2DgvSdJQPB4/ixYwZa6HKCkMDHn37cuEL8BljoB1mbmtra29rq6uxxXa0CVG2iAViILGeRGsAToCNnSUrTYrZ+o9K9Pd0Zqr3Q0NDZ/FYrEzN27cuAUAMl0eGBC7be80Xcu0yxjY3dHR8Up1qP418eHdsLJuGxhggRLAeEzhfSCFWtDCtoM/ea2nqWqiJxKJvDMyMnKGhqYXgN2moB2AeQzc2dn5lmfdxqPZLV2gCtWOwLollFBmIBl8HNLeBtjAfnts37594eHh4ZMY0EaU27z9E4N2GU3S66mNHs1uexE0hi8OWM/3c0IIZjYchEbjq1f37NmTRI5/vPop4/QUYQmXgQD+B3rnzp27q4J1vdmmgyUB489lxgMzkWfBHwwfa25ubsQbm3j2MwQXhnYsD1NCOBw+LEY7QBOqSgW2xgDu8kFIBFohGo0eoaFp8GKg+V27du3lwtH9UvDRNQPG43d824Grru1paWnZSnwXMFh0eTi7zIdCoW4x0r62wLiPEOJVLYAehYdtygMcnKbgufXr14cFX81eORBdc2DD6i94NoPH43meKItCnaa1adOmJ1RfPejAlAXYlMIIkBOCAVQizTSwPTRj57bP59uqemvLBoyNuMsFIBAINNlsPoeNSLjOcVxA59zlA7b6MuMGQRDCNqci2mkHcQYwZQU2rM8cgoa2Ox5pmpZklFxZgc02b0igqmqKmL8gaCChRVGc5qSlsgKbYz4tDel0epoAXpVpaMNG+uzs7E+ubAJNoJcNmNNlqNaWAf1cnaLOjkiOThNnOi2RSCQ1MTPuyv5ZFmAz1ykxkMTclzIKc04C2BHaoM90oKZSqb6axZ/LAmzybRZ/hbm5uT5zLmJ++/KwOTlrWGNjYxfYpdkrnvTtNQVGI9Ag3QImu/DFLyjycxbvtEE6jaQsLy/31c6PAaPm1gzYo6WhWbwKqATPWudGtRBw1u5xR5ye1fHx8QF5+c4HDYlBRKGVDMzqMrRnL0NuJXn8Ggo8TyElwuIbTCenkeShoaETzNLs+WiiH1g1V5LDT2cGADLzpy9duvSRdcBVCGDCYefyMEhoDP5HLPapkZyBpjvnwX83VjTwQ/IsPJUZBC2VOD44OPgeAEj47xOlYQrsa5p2W6fdBtmU1+v1i6IIYjIBG+P9sHXhIgRyMUSp2gKzugIREzZ9EZqXLn89F5s+jBz+0AKWHeoZCrn3+Dc8ES6Xq5plWVA1DdKZDAjiTdiciUGT2wspIQIi6wOFcQFj6MAZCni0DITUeZAl8ZvFxcW+iYmJ74n/XqEbkIbGbuOTuQ20IQiC34Q2rFLA8IAk8EuAVgQsw9ybUddvZrPZdy9OTv6w6otDJaTRwPQGpKHt3QYC3OA5rgZDr5YZpvtgygzDUOLx+MvT09Oz9heQNHAx99O02zS4YYrluCCDnDQDZQyNQfGMgIw9gYCn6D1CX/cSDhMl6gBNg9OX3cjl4Gpg3DbD7DP38szU1NRJk528UCdB7WvY3nHilZzz64vO/fsvoNyJgbFW9yVJeuG70dEBh1+QhLM0cIHQzvAI+keU2ingfPvz4aGhI06HC6oESn9RRJcLhkcRJkHRGG5mkMtvWjVrBw1FwTo77aycKKZRqsZ9wvHXBwcG3neCwUaU+40tBnblgSlNIsdPIhgdyhwsFBdhsI9er8eDy6IioE8j4FH4n4LBG8pJzx04YKbdSFcIgCTSFisXHBf6+++r028TwA98eYwinUKCSoHWkHrNXDHQlsOTSPCgQ9dZ+S+kN/BgRThtAWcqCXoE6SwSVAp0NdJLSFBJ0J8g/V5p0KfgAYi/AQ0R+7KQtU9QAAAAAElFTkSuQmCC'
			},
			{}
		),
		'select': new OpenLayers.Style(
			{
				fillOpacity: 1
			},
			{}
		),
		'temporary': new OpenLayers.Style(
			{
				fillOpacity: 1
			},
			{}
		)
	}
);






  // Base layers
  var matrixIds,
    wmts,
    i;

matrixIds = new Array(NK.zoomLevels);

for (i = 0; i <= NK.zoomLevels; ++i) {
  matrixIds[i] = {};
  matrixIds[i].identifier = mapProj + ":" + i;
} 

wmts = new OpenLayers.Layer.WMTS({
  name: "Europa",
  url: NK.mapservers.wmts,
  layer: "egk",
  matrixSet: mapProj,
  matrixIds: matrixIds,
  format: "image/png",
  requestEncoding: "kvp",
  style: "default",
  shortid: "europa", 
  visibility: 0, 
  transitionEffect: 'resize',
  opacity: 1.0,
  params: {
    gkt: NK.gkToken
  }
});

if (wmts.params.GKT) {
  wmts.params.gkt = wmts.params.GKT;
  delete wmts.params.GKT; 
}

wmts.events.register("tileerror", wmts, function(arg) {
  NK.functions.getNewToken();
});

map.events.register('zoomend', wmts, function (evt) {
  this.setVisibility(map.getZoom() <= 6);
});

map.addLayers([wmts]);


  // Overlays
  
NK.addLayerType = NK.addLayerType || {};
NK.addLayerType.WMTS = (function (M, MP) {
  var matrixIds = [],
      i;

  for (i = 0; i <= NK.zoomLevels; ++i) {
    matrixIds[i] = {};
    matrixIds[i].identifier = MP + ":" + i;
  } 

  return function (id, name, url, layer, options) {
    var layer, 
        layerOptions;
    var myMatrixIds = matrixIds;

    if (!!options.customProj) {
      var myMatrixIds = [],
        i;

      for (i = 0; i <= NK.zoomLevels; ++i) {
        myMatrixIds[i] = {};
        if (!!options.shortMatrixIds) {
          myMatrixIds[i].identifier = "" + i;
        } else {
          myMatrixIds[i].identifier = options.customProj + ":" + i;
        }
      } 
    } 

    layerOptions = {
      'name': name,
      'url': url,
      'layer': layer,
      'matrixSet': options.customProj || MP,
      'matrixIds': myMatrixIds,
      'format': "image/png",
      'requestEncoding': "kvp",
      'style': "default",
      'shortid': id, 
      'isBaseLayer': false,
      'linkedTo': options.linkedTo || null,
      'transitionEffect': 'resize',
      'displayOutsideMaxExtent': false,
      'buffer': 1
    };

    if (!!options.attribution) {
      layerOptions['attribution'] = options.attribution;
    }
    if (!!options.extent) {
      var c = options.extent.split(",");
      var customBounds = new OpenLayers.Bounds(c);
      layerOptions['tileFullExtent'] = customBounds;
    }
    if (!!options.tileorigin) {
      var c = options.tileorigin.split(",");
      var origin = new OpenLayers.LonLat(c);
      layerOptions['tileOrigin'] = origin;
    }
    if (!!options.databbox) {
      var c = options.databbox.split(",");
      var customBounds = new OpenLayers.Bounds(c);
      layerOptions['maxExtent'] = customBounds;
      layerOptions['visibility'] = 1;
    }

    layerOptions.displayInLayerSwitcher = !!(options.displayInLayerSwitcher) ? 1 : 0;
    layerOptions.visibility = !!(options.visibility) ? 1 : 0;

    if (!!options.params) {
      layerOptions.params = options.params;
    }

    layer = new OpenLayers.Layer.WMTS(layerOptions);

    if (options.layerGroup) {
      layer = OpenLayers.Util.extend(layer, {
        'layerGroup': options.layerGroup
      });
    }

    if (layer.params.GKT) {
      layer.params.gkt = layer.params.GKT;
      delete layer.params.GKT; 
    }

    if (options.visible) {
      NK.defaultVisibleLayers = NK.defaultVisibleLayers || [];
      NK.defaultVisibleLayers.push(id);
    }

    if (options.linkedTo) {
      layer.events.register("visibilitychanged", layer, function(arg) {
        map.getLayersBy("shortid",options.linkedTo)[0].setVisibility(layer.getVisibility());
      });
    }

    layer.events.register("tileerror", layer, function(arg) {
      NK.functions.getNewToken();
    });

    M.addLayers([layer]);

    return layer;
  };
}(map, mapProj));



(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;

    options.visibility = true;

    options.layerGroup = "land";

    options.params = { 'gkt': NK.gkToken };







    options.attribution = {
      title: "Kartverket",
      href: "http://www.kartverket.no/"
    }

  var layer = NK.addLayerType.WMTS('land', 'Land', url, 'topo2_dybde', options);

}());


(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;


    options.layerGroup = "land";

    options.params = { 'gkt': NK.gkToken };








  var layer = NK.addLayerType.WMTS('enkel', 'enkel', url, 'norges_grunnkart', options);

}());


(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;


    options.layerGroup = "sjo";

    options.params = { 'gkt': NK.gkToken };








  var layer = NK.addLayerType.WMTS('sjo', 'Hovedkart', url, 'sjokartraster', options);

}());

(function () {
  var wms = new OpenLayers.Layer.WMS(
    "Elektron. Sj&oslash;kart",
    "http://wms.geonorge.no/skwms1/wms.ecc_enc",
    {
      ticket: NK.encTicket,
      layers: "cells",
      transparent: true, 
      styles: "style-id-263",
      format: 'image/png'
    },
    {
      shortid: "sjo_enc", 
      isBaseLayer: false,
      buffer: 0,
      ratio: 1, 
      visibility: false, 
      singleTile: true,
      minZoom: 10,
      transitionEffect: 'resize'
    }
  );

    wms = OpenLayers.Util.extend(wms, { layerGroup: 'sjo' });



  if (wms.params.GKT) {
    wms.params.gkt = wms.params.GKT;
    delete wms.params.GKT; 
  }

  if (wms.params.TICKET) {
    wms.params.ticket = wms.params.TICKET;
    delete wms.params.TICKET;
  }

  wms.events.register("visibilitychanged", wms, function(arg) {
    map.getLayersBy("shortid","enkel")[0].setVisibility(wms.getVisibility());
  });
  

  map.addLayers([wms]);
}());

(function () {
  var wms = new OpenLayers.Layer.WMS(
    "Fly&shy;bilder",
    "http://gatekeeper1.geonorge.no/BaatGatekeeper/gk/gk.nibcache",
    {
      gkt: NK.gkToken,
      layers: "NiB",
      transparent: 0, 
      format: 'image/jpeg'
    },
    {
      shortid: "flybilder", 
      isBaseLayer: false,
      buffer: 0,
      ratio: 1, 
      visibility: 0, 
      singleTile: false,
      transitionEffect: 'resize'
    }
  );

    wms = OpenLayers.Util.extend(wms, { layerGroup: 'land' });



  if (wms.params.GKT) {
    wms.params.gkt = wms.params.GKT;
    delete wms.params.GKT; 
  }


  

  map.addLayers([wms]);
}());


(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;


    options.layerGroup = "land";

    options.params = { 'gkt': NK.gkToken };








  var layer = NK.addLayerType.WMTS('terreng', 'terreng', url, 'terreng_norgeskart', options);

}());


(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;


    options.layerGroup = "land";

    options.params = { 'gkt': NK.gkToken };






    options.linkedTo = "fjellskygge"


  var layer = NK.addLayerType.WMTS('toporaster', 'Rasterkart', url, 'toporaster3', options);

}());


(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;



    options.params = { 'gkt': NK.gkToken };








  var layer = NK.addLayerType.WMTS('fjellskygge', 'Fjellskygge', url, 'fjellskygge', options);

}());


(function () {
  var url, 
      options = {};

    url = "http://geodata.npolar.no/arcgis/rest/services/Basisdata/NP_Basiskart_JanMayen_WMTS_25833/MapServer/WMTS?";

    options.displayInLayerSwitcher = true;


    options.layerGroup = "flere";


    options.customProj = "EPSG:25833"

    options.shortMatrixIds = true


    options.databbox = "-393783.2540000008,7978220.98008712,-276963.7430000013,8084965.524000007"

    options.tileorigin = "-5120900.0,9998100.0"



  var layer = NK.addLayerType.WMTS('janmayen', 'janmayen', url, 'Basisdata_NP_Basiskart_JanMayen_WMTS_25833', options);

}());


(function () {
  var url, 
      options = {};

    url = "http://geodata.npolar.no/arcgis/rest/services/Basisdata/NP_Basiskart_Svalbard_WMTS_25833/MapServer/WMTS?";

    options.displayInLayerSwitcher = true;


    options.layerGroup = "flere";


    options.customProj = "EPSG:25833"

    options.shortMatrixIds = true


    options.databbox = "369976.3899489096,8221306.539890718,878234.7199568129,9010718.76990194"

    options.tileorigin = "-5120900.0,9998100.0"



  var layer = NK.addLayerType.WMTS('svalbard', 'svalbard', url, 'Basisdata_NP_Basiskart_Svalbard_WMTS_25833', options);

}());



NK.styles = NK.styles || {};
NK.styles.dekning = NK.styles.dekning || {};
NK.styles.dekning.land = new OpenLayers.StyleMap(
	{
	  'default': new OpenLayers.Style(
	    {
	      strokeWidth: 2,
	      strokeColor  : "#484",
	      fillOpacity: 0.1, 
	      label : "${nr}",
	      fontColor: "#8a8",
	      fontSize: "12px",
	      fontFamily: "Courier New, monospace",
	      fontWeight: "bold",
	      labelAlign: "cm",
	      labelOutlineColor: "white",
	      labelOutlineWidth: 5
	    },
	    {
	      rules: [
	        new OpenLayers.Rule({
	          maxScaleDenominator: 5000000,
	          symbolizer: {
	            label: "${nr}"
	          }
	        }),
	        new OpenLayers.Rule({
	          minScaleDenominator: 5000000,
	          symbolizer: {
	            label: ""
	          }
	        }),
	        new OpenLayers.Rule({
	          filter: new OpenLayers.Filter.Comparison({
	            type: OpenLayers.Filter.Comparison.LIKE,
	            property: "u",
	            value: "2013"
	          }),
	          symbolizer: {
	            strokeColor  : "#844",
	            fontColor: "#a88"
	          }
	        })
	      ]
	    }
	  ),
	  'temporary': new OpenLayers.Style(
			{
		      strokeWidth: 3,
		      strokeColor  : "#ada",
		      fontColor: "#ada",
		      fillOpacity: 0.1
			},
			{
				rules: [
			        new OpenLayers.Rule({
			        	symbolizer: {
					        strokeColor  : "#ada",
					        fontColor: "#ada"
				        }
				    }),
			        new OpenLayers.Rule({
						filter: new OpenLayers.Filter.Comparison({
							type: OpenLayers.Filter.Comparison.LIKE,
							property: "u",
							value: "2013"
						}),
						symbolizer: {
							strokeColor  : "#daa",
							fontColor: "#daa"
						}
			    })
				]
			}
	  )
	}
);



(function (M, MP, P) {
  var layer,
      selectControl,
      onPopupClose = null,
      onFeatureUnselect,
      onFeatureSelect,
      generatePopupMarkup,
      requestHandler;

  // dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Norge 1:50000",
    {
      shortid: "dekning.land", 
      styleMap: NK.styles.dekning.land, 
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "toporaster"
    }
  );

  M.addLayer(layer);

  requestHandler = function (request) {
    var geojson_format,
        features,
        feature, 
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['32633'] 
    });

    features = geojson_format.read(request.responseText);

    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        feature.attributes.nr = feature.fid;
      }
    }
    layer.addFeatures(features);
  };

  OpenLayers.Request.GET({
    url: "/json/dekning/land/n50/plast.json",
    callback: requestHandler
  });

  onPopupClose = function (evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  };

  generatePopupMarkup = function (feature) {
    var a  = feature.attributes;
      var markup = '<article>';
      if (a.n && a.n !== 'NULL') {
        markup += '<h1 class="h">' + a.n + '</h1>';
      }
      if (a.nr) {
        markup += '<p>' + OpenLayers.Lang.translate('Map number') + ': ' + a.nr + '</p>';
      }
      if (a.k) {
        markup += '<div class="municipalities">' + OpenLayers.Lang.translate('Municipalities') + ': <span>' + a.k.split(',').join(',</span><span>') + '</span></div>';
      }
      if (a.u) {
        markup += '<p>' + OpenLayers.Lang.translate('Updated') + ': ' + a.u + '</p>';
      }
      if (a.e) {
        markup += '<p>' + OpenLayers.Lang.translate('EAN-number') + ': ' + a.e + '</p>';
      }
      markup += '</article>';
      return markup;
  };

  onFeatureUnselect = function (feature) {
      if (feature === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      if (feature.popup) {
        M.removePopup(feature.popup);
        feature.popup.destroy();
        feature.popup = null;
      }
  };

  onFeatureSelect = function (feature) {
      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        var message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };
        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {
        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;
        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
    }
  };

  NK.functions.vector.addVectorHoverControls(M, layer);

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect,
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);


OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Map number': 'Kartblad',
  'Latest print': 'Siste trykk',
  'Datum': 'Datum',
  'Municipalities': 'Kommuner',
  'EAN-number': 'EAN-nummer',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Updated': 'Sist oppdatert',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});


}(map, mapProj, proj));

(function (M, MP, P){
  var styleMap,
      layer,
      dataResponseHandler,
      highlightAllById,
      unhighlightAllById,
      selectControl;

    styleMap = new OpenLayers.StyleMap({
    'default': new OpenLayers.Style(
      {
        strokeWidth: 2,
        strokeColor  :"#844",
        fillOpacity: 0.1, 
        strokeOpacity: 1,

        label : "${nr}",
        fontColor: "#a88",
        fontSize: "12px",
        fontFamily: "Courier New, monospace",
        fontWeight: "bold",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 5
      }, 
      {
        rules: [
          new OpenLayers.Rule({
            maxScaleDenominator: 2500000,
            symbolizer: {
              label: "${nr}"
            }
          }),
          new OpenLayers.Rule({
            minScaleDenominator: 2500000,
            symbolizer: {
              label: ""
            }
          })       
        ]
      }
    ),
    'temporary': {
      strokeWidth: 6,
      strokeColor  : "#daa",
      fontColor: "#daa",
      fillOpacity: 0.1
    }
  });
  

  
	styleMap.styles['default'].defaultStyle.strokeColor = "#484";
	styleMap.styles['default'].defaultStyle.fontColor = "#8a8";
	styleMap.styles.temporary.defaultStyle.strokeColor = "#ada";
	styleMap.styles.temporary.defaultStyle.fontColor = "#ada";


  //dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Hoved&shy;kart sj&oslash;",
    {
      shortid: "dekning.sjo",
      styleMap: styleMap,
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "sjo"
    }
  );

  dataResponseHandler = function(request) {
    var geojson_format, 
        features,
        feature,
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['4326'] 
    });
    features = geojson_format.read(request.responseText);
    features = features.sort(function (a,b) {
       // sort by area
      return b.geometry.getArea() - a.geometry.getArea();
    });
    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        if (feature.fid.length < 4) {
          feature.attributes.nr = feature.fid;
          feature.attributes.vignett = '';
        } else {
          feature.attributes.nr = '';
          feature.attributes.vignett = feature.fid;
          feature.fid = feature.fid.slice(0, 3);
        }
      }
    }
    layer.addFeatures(features);
  };

  M.addLayer(layer);

  OpenLayers.Request.GET({
    url: "/json/dekning/sjo/hovedserie_ny.json",
    callback: dataResponseHandler
  });

  highlightAllById = function(element) {
    // highlight all elements with the same element.feature.fid;
    var ident = layer.getFeaturesByFid (element.feature.fid);
    $.each(ident, function(i, feature) {
      feature.renderIntent = "temporary";
      layer.drawFeature(feature);
    });
  };

  // un-highlight all elements with the same element.feature.fid;
  unhighlightAllById = function(element) {
    var ident = layer.getFeaturesByFid (element.feature.fid);

    $.each(ident, function(i, feature) {
      feature.renderIntent = "default";
      layer.drawFeature(feature);
    });
  };

  var highlightDekningCtrl = new OpenLayers.Control.SelectFeature(layer, {
    hover: true,
    multiple: true,
    highlightOnly: true,
    renderIntent: "temporary",
    eventListeners: {
        beforefeaturehighlighted: highlightAllById,
        featureunhighlighted: unhighlightAllById
    },
    autoActivate: true
  });
  map.addControl(highlightDekningCtrl);
  
  function onPopupClose(evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  }

  function projectionName(projectionNumber) {
    switch (projectionNumber) {
      case '8':
        return 'Mercator';
      case '16':
        return 'Gauss Kr\u00FCger';
      default:
        return '';  
    }
  }

  var datumNames = {
    '2': 'WGS84'
    // TODO: values for ED50 and NGO (see http://kartverket.no/en/Kart/Nautical-Charts/Nautical-Charts/) 
  };

  function generatePopupMarkup (feature) {
    var a  = feature.attributes;
    var mainMapFeature, i, j;
      var markup = '<article>';
      if (!!a.n) {
        markup += '<h1 class="h">' + feature.fid + " " + a.n + '</h1>';
      }
      if (a.vignett) {
        var mainMapNumber = a.vignett.slice(0, 3);
        for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
          if (feature.layer.features[i].attributes.nr === mainMapNumber) {
            mainMapFeature = feature.layer.features[i];
          }
        }
        if (mainMapFeature) {
          if (mainMapFeature.attributes.s !== a.s) {
            markup += OpenLayers.Lang.translate('Special in map');
          } else {
            markup += OpenLayers.Lang.translate('Vignette in map');
          }
           markup += ' ' + mainMapFeature.attributes.nr + ' ' + mainMapFeature.attributes.n;
        }
      }
      if (a.f) {
        markup += '<p>' + OpenLayers.Lang.translate('Current edition') + ': ' + a.f + '</p>';
      }
      if (a.g) {
        markup += '<p>' + OpenLayers.Lang.translate('Latest print') + ': ' + a.g + '</p>';
      }
      if (a.s) {
        markup += '<p>' + OpenLayers.Lang.translate('Scale') + ' ' + a.s + '</p>';
      }
      if (a.p) {
        markup += '<p>' + OpenLayers.Lang.translate('Projection') + ': ' + a.p + '</p>';
      }
      if (a.d) {
        markup += '<p>' + OpenLayers.Lang.translate('Datum') + ': ' + a.d + '</p>';
      }
      markup += '</article>';
      return markup;
  }

  function onFeatureSelect (feature) {
    var i, 
        j, 
        mainMapNumber,
        message,
        vignettes = [],
        specials = [],
        a;

      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };

        if (feature.attributes.vignett) {
            mainMapNumber = feature.attributes.vignett.slice(0, 3);
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              if (feature.layer.features[i].attributes.nr === mainMapNumber) {
                message.mainMapFeature = feature.layer.features[i].attributes;
              }
            }
        } else {
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              a = feature.layer.features[i].attributes;
              if (a.vignett && a.vignett.indexOf(feature.attributes.nr) === 0) {
                // feature[i] is a special or vignette in the selected map
                
                if (feature.attributes.s === a.s) {
                  vignettes.push(a);
                } else {
                  specials.push(a);
                }
              }
            }
            if (specials.length > 0) {
              message.specials = specials;
            }
            if (vignettes.length > 0) {
              message.vignettes = vignettes;
            }
        }

        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {

        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;

        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
      }
  }
  
  function onFeatureUnselect (feature) {
      if (feature.popup === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      M.removePopup(feature.popup);
      feature.popup.destroy();
      feature.popup = null;

  }

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect, 
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);

OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Current edition': 'Gyldig utgave',
  'Latest print': 'Siste trykk md/&aring;r',
  'Datum': 'Datum',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});

}(map, mapProj, proj));

(function (M, MP, P){
  var styleMap,
      layer,
      dataResponseHandler,
      highlightAllById,
      unhighlightAllById,
      selectControl;

    styleMap = new OpenLayers.StyleMap({
    'default': new OpenLayers.Style(
      {
        strokeWidth: 2,
        strokeColor  :"#844",
        fillOpacity: 0.1, 
        strokeOpacity: 1,

        label : "${nr}",
        fontColor: "#a88",
        fontSize: "12px",
        fontFamily: "Courier New, monospace",
        fontWeight: "bold",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 5
      }, 
      {
        rules: [
          new OpenLayers.Rule({
            maxScaleDenominator: 2500000,
            symbolizer: {
              label: "${nr}"
            }
          }),
          new OpenLayers.Rule({
            minScaleDenominator: 2500000,
            symbolizer: {
              label: ""
            }
          })       
        ]
      }
    ),
    'temporary': {
      strokeWidth: 6,
      strokeColor  : "#daa",
      fontColor: "#daa",
      fillOpacity: 0.1
    }
  });
  

  


  //dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Havne&shy;kart",
    {
      shortid: "dekning.sjo.hv",
      styleMap: styleMap,
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "sjo"
    }
  );

  dataResponseHandler = function(request) {
    var geojson_format, 
        features,
        feature,
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['4326'] 
    });
    features = geojson_format.read(request.responseText);
    features = features.sort(function (a,b) {
       // sort by area
      return b.geometry.getArea() - a.geometry.getArea();
    });
    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        if (feature.fid.length < 4) {
          feature.attributes.nr = feature.fid;
          feature.attributes.vignett = '';
        } else {
          feature.attributes.nr = '';
          feature.attributes.vignett = feature.fid;
          feature.fid = feature.fid.slice(0, 3);
        }
      }
    }
    layer.addFeatures(features);
  };

  M.addLayer(layer);

  OpenLayers.Request.GET({
    url: "/json/dekning/sjo/havnekart_ny.json",
    callback: dataResponseHandler
  });

  highlightAllById = function(element) {
    // highlight all elements with the same element.feature.fid;
    var ident = layer.getFeaturesByFid (element.feature.fid);
    $.each(ident, function(i, feature) {
      feature.renderIntent = "temporary";
      layer.drawFeature(feature);
    });
  };

  // un-highlight all elements with the same element.feature.fid;
  unhighlightAllById = function(element) {
    var ident = layer.getFeaturesByFid (element.feature.fid);

    $.each(ident, function(i, feature) {
      feature.renderIntent = "default";
      layer.drawFeature(feature);
    });
  };

  var highlightDekningCtrl = new OpenLayers.Control.SelectFeature(layer, {
    hover: true,
    multiple: true,
    highlightOnly: true,
    renderIntent: "temporary",
    eventListeners: {
        beforefeaturehighlighted: highlightAllById,
        featureunhighlighted: unhighlightAllById
    },
    autoActivate: true
  });
  map.addControl(highlightDekningCtrl);
  
  function onPopupClose(evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  }

  function projectionName(projectionNumber) {
    switch (projectionNumber) {
      case '8':
        return 'Mercator';
      case '16':
        return 'Gauss Kr\u00FCger';
      default:
        return '';  
    }
  }

  var datumNames = {
    '2': 'WGS84'
    // TODO: values for ED50 and NGO (see http://kartverket.no/en/Kart/Nautical-Charts/Nautical-Charts/) 
  };

  function generatePopupMarkup (feature) {
    var a  = feature.attributes;
    var mainMapFeature, i, j;
      var markup = '<article>';
      if (!!a.n) {
        markup += '<h1 class="h">' + feature.fid + " " + a.n + '</h1>';
      }
      if (a.vignett) {
        var mainMapNumber = a.vignett.slice(0, 3);
        for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
          if (feature.layer.features[i].attributes.nr === mainMapNumber) {
            mainMapFeature = feature.layer.features[i];
          }
        }
        if (mainMapFeature) {
          if (mainMapFeature.attributes.s !== a.s) {
            markup += OpenLayers.Lang.translate('Special in map');
          } else {
            markup += OpenLayers.Lang.translate('Vignette in map');
          }
           markup += ' ' + mainMapFeature.attributes.nr + ' ' + mainMapFeature.attributes.n;
        }
      }
      if (a.f) {
        markup += '<p>' + OpenLayers.Lang.translate('Current edition') + ': ' + a.f + '</p>';
      }
      if (a.g) {
        markup += '<p>' + OpenLayers.Lang.translate('Latest print') + ': ' + a.g + '</p>';
      }
      if (a.s) {
        markup += '<p>' + OpenLayers.Lang.translate('Scale') + ' ' + a.s + '</p>';
      }
      if (a.p) {
        markup += '<p>' + OpenLayers.Lang.translate('Projection') + ': ' + a.p + '</p>';
      }
      if (a.d) {
        markup += '<p>' + OpenLayers.Lang.translate('Datum') + ': ' + a.d + '</p>';
      }
      markup += '</article>';
      return markup;
  }

  function onFeatureSelect (feature) {
    var i, 
        j, 
        mainMapNumber,
        message,
        vignettes = [],
        specials = [],
        a;

      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };

        if (feature.attributes.vignett) {
            mainMapNumber = feature.attributes.vignett.slice(0, 3);
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              if (feature.layer.features[i].attributes.nr === mainMapNumber) {
                message.mainMapFeature = feature.layer.features[i].attributes;
              }
            }
        } else {
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              a = feature.layer.features[i].attributes;
              if (a.vignett && a.vignett.indexOf(feature.attributes.nr) === 0) {
                // feature[i] is a special or vignette in the selected map
                
                if (feature.attributes.s === a.s) {
                  vignettes.push(a);
                } else {
                  specials.push(a);
                }
              }
            }
            if (specials.length > 0) {
              message.specials = specials;
            }
            if (vignettes.length > 0) {
              message.vignettes = vignettes;
            }
        }

        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {

        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;

        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
      }
  }
  
  function onFeatureUnselect (feature) {
      if (feature.popup === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      M.removePopup(feature.popup);
      feature.popup.destroy();
      feature.popup = null;

  }

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect, 
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);

OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Current edition': 'Gyldig utgave',
  'Latest print': 'Siste trykk md/&aring;r',
  'Datum': 'Datum',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});

}(map, mapProj, proj));

(function (M, MP, P){
  var styleMap,
      layer,
      dataResponseHandler,
      highlightAllById,
      unhighlightAllById,
      selectControl;

    styleMap = new OpenLayers.StyleMap({
    'default': new OpenLayers.Style(
      {
        strokeWidth: 2,
        strokeColor  :"#844",
        fillOpacity: 0.1, 
        strokeOpacity: 1,

        label : "${nr}",
        fontColor: "#a88",
        fontSize: "12px",
        fontFamily: "Courier New, monospace",
        fontWeight: "bold",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 5
      }, 
      {
        rules: [
          new OpenLayers.Rule({
            maxScaleDenominator: 2500000,
            symbolizer: {
              label: "${nr}"
            }
          }),
          new OpenLayers.Rule({
            minScaleDenominator: 2500000,
            symbolizer: {
              label: ""
            }
          })       
        ]
      }
    ),
    'temporary': {
      strokeWidth: 6,
      strokeColor  : "#daa",
      fontColor: "#daa",
      fillOpacity: 0.1
    }
  });
  

  
styleMap.styles['default'].defaultStyle.strokeColor = "#844";
styleMap.styles['default'].defaultStyle.fontColor = "#aa8";
styleMap.styles.temporary.defaultStyle.strokeColor = "#dda";
styleMap.styles.temporary.defaultStyle.fontColor = "#dda";


  //dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Kyst&shy;kart",
    {
      shortid: "dekning.sjo.ky",
      styleMap: styleMap,
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "sjo"
    }
  );

  dataResponseHandler = function(request) {
    var geojson_format, 
        features,
        feature,
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['4326'] 
    });
    features = geojson_format.read(request.responseText);
    features = features.sort(function (a,b) {
       // sort by area
      return b.geometry.getArea() - a.geometry.getArea();
    });
    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        if (feature.fid.length < 4) {
          feature.attributes.nr = feature.fid;
          feature.attributes.vignett = '';
        } else {
          feature.attributes.nr = '';
          feature.attributes.vignett = feature.fid;
          feature.fid = feature.fid.slice(0, 3);
        }
      }
    }
    layer.addFeatures(features);
  };

  M.addLayer(layer);

  OpenLayers.Request.GET({
    url: "/json/dekning/sjo/kystkart_ny.json",
    callback: dataResponseHandler
  });

  highlightAllById = function(element) {
    // highlight all elements with the same element.feature.fid;
    var ident = layer.getFeaturesByFid (element.feature.fid);
    $.each(ident, function(i, feature) {
      feature.renderIntent = "temporary";
      layer.drawFeature(feature);
    });
  };

  // un-highlight all elements with the same element.feature.fid;
  unhighlightAllById = function(element) {
    var ident = layer.getFeaturesByFid (element.feature.fid);

    $.each(ident, function(i, feature) {
      feature.renderIntent = "default";
      layer.drawFeature(feature);
    });
  };

  var highlightDekningCtrl = new OpenLayers.Control.SelectFeature(layer, {
    hover: true,
    multiple: true,
    highlightOnly: true,
    renderIntent: "temporary",
    eventListeners: {
        beforefeaturehighlighted: highlightAllById,
        featureunhighlighted: unhighlightAllById
    },
    autoActivate: true
  });
  map.addControl(highlightDekningCtrl);
  
  function onPopupClose(evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  }

  function projectionName(projectionNumber) {
    switch (projectionNumber) {
      case '8':
        return 'Mercator';
      case '16':
        return 'Gauss Kr\u00FCger';
      default:
        return '';  
    }
  }

  var datumNames = {
    '2': 'WGS84'
    // TODO: values for ED50 and NGO (see http://kartverket.no/en/Kart/Nautical-Charts/Nautical-Charts/) 
  };

  function generatePopupMarkup (feature) {
    var a  = feature.attributes;
    var mainMapFeature, i, j;
      var markup = '<article>';
      if (!!a.n) {
        markup += '<h1 class="h">' + feature.fid + " " + a.n + '</h1>';
      }
      if (a.vignett) {
        var mainMapNumber = a.vignett.slice(0, 3);
        for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
          if (feature.layer.features[i].attributes.nr === mainMapNumber) {
            mainMapFeature = feature.layer.features[i];
          }
        }
        if (mainMapFeature) {
          if (mainMapFeature.attributes.s !== a.s) {
            markup += OpenLayers.Lang.translate('Special in map');
          } else {
            markup += OpenLayers.Lang.translate('Vignette in map');
          }
           markup += ' ' + mainMapFeature.attributes.nr + ' ' + mainMapFeature.attributes.n;
        }
      }
      if (a.f) {
        markup += '<p>' + OpenLayers.Lang.translate('Current edition') + ': ' + a.f + '</p>';
      }
      if (a.g) {
        markup += '<p>' + OpenLayers.Lang.translate('Latest print') + ': ' + a.g + '</p>';
      }
      if (a.s) {
        markup += '<p>' + OpenLayers.Lang.translate('Scale') + ' ' + a.s + '</p>';
      }
      if (a.p) {
        markup += '<p>' + OpenLayers.Lang.translate('Projection') + ': ' + a.p + '</p>';
      }
      if (a.d) {
        markup += '<p>' + OpenLayers.Lang.translate('Datum') + ': ' + a.d + '</p>';
      }
      markup += '</article>';
      return markup;
  }

  function onFeatureSelect (feature) {
    var i, 
        j, 
        mainMapNumber,
        message,
        vignettes = [],
        specials = [],
        a;

      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };

        if (feature.attributes.vignett) {
            mainMapNumber = feature.attributes.vignett.slice(0, 3);
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              if (feature.layer.features[i].attributes.nr === mainMapNumber) {
                message.mainMapFeature = feature.layer.features[i].attributes;
              }
            }
        } else {
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              a = feature.layer.features[i].attributes;
              if (a.vignett && a.vignett.indexOf(feature.attributes.nr) === 0) {
                // feature[i] is a special or vignette in the selected map
                
                if (feature.attributes.s === a.s) {
                  vignettes.push(a);
                } else {
                  specials.push(a);
                }
              }
            }
            if (specials.length > 0) {
              message.specials = specials;
            }
            if (vignettes.length > 0) {
              message.vignettes = vignettes;
            }
        }

        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {

        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;

        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
      }
  }
  
  function onFeatureUnselect (feature) {
      if (feature.popup === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      M.removePopup(feature.popup);
      feature.popup.destroy();
      feature.popup = null;

  }

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect, 
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);

OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Current edition': 'Gyldig utgave',
  'Latest print': 'Siste trykk md/&aring;r',
  'Datum': 'Datum',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});

}(map, mapProj, proj));

(function (M, MP, P){
  var styleMap,
      layer,
      dataResponseHandler,
      highlightAllById,
      unhighlightAllById,
      selectControl;

    styleMap = new OpenLayers.StyleMap({
    'default': new OpenLayers.Style(
      {
        strokeWidth: 2,
        strokeColor  :"#844",
        fillOpacity: 0.1, 
        strokeOpacity: 1,

        label : "${nr}",
        fontColor: "#a88",
        fontSize: "12px",
        fontFamily: "Courier New, monospace",
        fontWeight: "bold",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 5
      }, 
      {
        rules: [
          new OpenLayers.Rule({
            maxScaleDenominator: 2500000,
            symbolizer: {
              label: "${nr}"
            }
          }),
          new OpenLayers.Rule({
            minScaleDenominator: 2500000,
            symbolizer: {
              label: ""
            }
          })       
        ]
      }
    ),
    'temporary': {
      strokeWidth: 6,
      strokeColor  : "#daa",
      fontColor: "#daa",
      fillOpacity: 0.1
    }
  });
  

  
styleMap.styles['default'].defaultStyle.strokeColor = "#448";
styleMap.styles['default'].defaultStyle.fontColor = "#88a";
styleMap.styles.temporary.defaultStyle.strokeColor = "#aad";
styleMap.styles.temporary.defaultStyle.fontColor = "#aad";


  //dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Overseilingskart",
    {
      shortid: "dekning.sjo.fi",
      styleMap: styleMap,
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "sjo"
    }
  );

  dataResponseHandler = function(request) {
    var geojson_format, 
        features,
        feature,
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['4326'] 
    });
    features = geojson_format.read(request.responseText);
    features = features.sort(function (a,b) {
       // sort by area
      return b.geometry.getArea() - a.geometry.getArea();
    });
    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        if (feature.fid.length < 4) {
          feature.attributes.nr = feature.fid;
          feature.attributes.vignett = '';
        } else {
          feature.attributes.nr = '';
          feature.attributes.vignett = feature.fid;
          feature.fid = feature.fid.slice(0, 3);
        }
      }
    }
    layer.addFeatures(features);
  };

  M.addLayer(layer);

  OpenLayers.Request.GET({
    url: "/json/dekning/sjo/overseilingskart_ny.json",
    callback: dataResponseHandler
  });

  highlightAllById = function(element) {
    // highlight all elements with the same element.feature.fid;
    var ident = layer.getFeaturesByFid (element.feature.fid);
    $.each(ident, function(i, feature) {
      feature.renderIntent = "temporary";
      layer.drawFeature(feature);
    });
  };

  // un-highlight all elements with the same element.feature.fid;
  unhighlightAllById = function(element) {
    var ident = layer.getFeaturesByFid (element.feature.fid);

    $.each(ident, function(i, feature) {
      feature.renderIntent = "default";
      layer.drawFeature(feature);
    });
  };

  var highlightDekningCtrl = new OpenLayers.Control.SelectFeature(layer, {
    hover: true,
    multiple: true,
    highlightOnly: true,
    renderIntent: "temporary",
    eventListeners: {
        beforefeaturehighlighted: highlightAllById,
        featureunhighlighted: unhighlightAllById
    },
    autoActivate: true
  });
  map.addControl(highlightDekningCtrl);
  
  function onPopupClose(evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  }

  function projectionName(projectionNumber) {
    switch (projectionNumber) {
      case '8':
        return 'Mercator';
      case '16':
        return 'Gauss Kr\u00FCger';
      default:
        return '';  
    }
  }

  var datumNames = {
    '2': 'WGS84'
    // TODO: values for ED50 and NGO (see http://kartverket.no/en/Kart/Nautical-Charts/Nautical-Charts/) 
  };

  function generatePopupMarkup (feature) {
    var a  = feature.attributes;
    var mainMapFeature, i, j;
      var markup = '<article>';
      if (!!a.n) {
        markup += '<h1 class="h">' + feature.fid + " " + a.n + '</h1>';
      }
      if (a.vignett) {
        var mainMapNumber = a.vignett.slice(0, 3);
        for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
          if (feature.layer.features[i].attributes.nr === mainMapNumber) {
            mainMapFeature = feature.layer.features[i];
          }
        }
        if (mainMapFeature) {
          if (mainMapFeature.attributes.s !== a.s) {
            markup += OpenLayers.Lang.translate('Special in map');
          } else {
            markup += OpenLayers.Lang.translate('Vignette in map');
          }
           markup += ' ' + mainMapFeature.attributes.nr + ' ' + mainMapFeature.attributes.n;
        }
      }
      if (a.f) {
        markup += '<p>' + OpenLayers.Lang.translate('Current edition') + ': ' + a.f + '</p>';
      }
      if (a.g) {
        markup += '<p>' + OpenLayers.Lang.translate('Latest print') + ': ' + a.g + '</p>';
      }
      if (a.s) {
        markup += '<p>' + OpenLayers.Lang.translate('Scale') + ' ' + a.s + '</p>';
      }
      if (a.p) {
        markup += '<p>' + OpenLayers.Lang.translate('Projection') + ': ' + a.p + '</p>';
      }
      if (a.d) {
        markup += '<p>' + OpenLayers.Lang.translate('Datum') + ': ' + a.d + '</p>';
      }
      markup += '</article>';
      return markup;
  }

  function onFeatureSelect (feature) {
    var i, 
        j, 
        mainMapNumber,
        message,
        vignettes = [],
        specials = [],
        a;

      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };

        if (feature.attributes.vignett) {
            mainMapNumber = feature.attributes.vignett.slice(0, 3);
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              if (feature.layer.features[i].attributes.nr === mainMapNumber) {
                message.mainMapFeature = feature.layer.features[i].attributes;
              }
            }
        } else {
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              a = feature.layer.features[i].attributes;
              if (a.vignett && a.vignett.indexOf(feature.attributes.nr) === 0) {
                // feature[i] is a special or vignette in the selected map
                
                if (feature.attributes.s === a.s) {
                  vignettes.push(a);
                } else {
                  specials.push(a);
                }
              }
            }
            if (specials.length > 0) {
              message.specials = specials;
            }
            if (vignettes.length > 0) {
              message.vignettes = vignettes;
            }
        }

        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {

        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;

        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
      }
  }
  
  function onFeatureUnselect (feature) {
      if (feature.popup === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      M.removePopup(feature.popup);
      feature.popup.destroy();
      feature.popup = null;

  }

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect, 
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);

OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Current edition': 'Gyldig utgave',
  'Latest print': 'Siste trykk md/&aring;r',
  'Datum': 'Datum',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});

}(map, mapProj, proj));




  
NK.functions = NK.functions || {};
NK.functions.popup = NK.functions.popup || {};

NK.functions.popup.generatePopupMarkup = function (conf) {
  return function (feature) {
    var a = feature.attributes, 
        i,
        l,
        markup = '<article>';

    if (conf.heading && a[conf.heading]) {
      markup += '<h1 class="h">' + a[conf.heading] + '</h1>';
    }
    if (conf.data) {
      for (i = 0, l = conf.data.length; i < l; i += 1) {
        if (conf.data[i].attribute && a[conf.data[i].attribute]) {
          markup += '<p>' + OpenLayers.Lang.translate(conf.data[i].label) + ': ' + a[conf.data[i].attribute] + ' '+ conf.data[i].unit +'</p>';
        }
      }
    }
    markup += '</article>';
    return markup;
  };
};

NK.functions.popup.getFeatureSelector = function (M, markupGeneratorFunction, popupCloseFunction, options) {
  var featureSelector = options.selectControl;
  return function (feature) {
    var popup, 
        message, 
        mousePosition,
        featurePosition,
        popupPosition,
        offset = {},
        sameFidFeatures,
        xOffset,
        yOffset,
        i, j;

    if (feature.cluster) {
      return false;
    }

    if (NK.easyXDM && NK.easyXDM.socket) {
      // there is an active easyXDM socket - send feature data
      message = {
        cmd: 'featureSelected', 
        feature: feature.fid,
        attributes: feature.attributes,
        layer: feature.layer.shortid
      };
      NK.easyXDM.socket.postMessage(JSON.stringify(message));
    }

    if (feature.fid && feature.layer) {

      sameFidFeatures = feature.layer.getFeaturesByFid(feature.fid);
      for (i = 0, j = sameFidFeatures.length; i < j; i += 1) {
        feature.layer.selectedFeatures.push(sameFidFeatures[i]);

        this.highlight.apply(this, [sameFidFeatures[i]]);
      } 
    }

    // find out where to position the popup
    if (options && options.featureCentroidPosition) {
      featurePosition = feature.geometry.getBounds().getCenterLonLat();

      if (featurePosition) {
        xOffset = feature.layer.styleMap.styles[feature.renderIntent].defaultStyle.graphicXOffset || feature.layer.styleMap.styles['default'].defaultStyle.graphicXOffset || 0;
        xOffset += (feature.layer.styleMap.styles[feature.renderIntent].defaultStyle.graphicWidth || feature.layer.styleMap.styles['default'].defaultStyle.graphicWidth) / 2;
        yOffset = feature.layer.styleMap.styles[feature.renderIntent].defaultStyle.graphicYOffset || feature.layer.styleMap.styles['default'].defaultStyle.graphicYOffset || 0;

        if (xOffset || yOffset) {
          offset.x = -5;
          offset.y = -18;
          offset.addX = xOffset;
          offset.addY = yOffset;
        }
      }
    }

    mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
    popupPosition = featurePosition || mousePosition;

    M.panTo(popupPosition);

    popup = new OpenLayers.Popup.FramedSideAnchored(
      "nk-selected-coverage-map", 
      popupPosition,
      null,
      markupGeneratorFunction(feature),
      null, 
      true, 
      popupCloseFunction,
      offset,
      'selected-feature-popup'
    );

    popup.autoSize = true;
    feature.popup = popup;
    popup.feature = feature;
    M.addPopup(popup);
  
  };
};

NK.functions.popup.addConfiguredPopup = function (M, layer, popupConfig) {

  var generatePopupMarkup,
      onFeatureSelect,
      onFeatureUnselect,
      onPopupClose,
      selectControl;
      
  generatePopupMarkup = NK.functions.popup.generatePopupMarkup(popupConfig);

  onPopupClose = function (evt) {
    if (this.feature) {
      selectControl.unselect(this.feature);
    }
  };

  onFeatureSelect = NK.functions.popup.getFeatureSelector(M, generatePopupMarkup, onPopupClose, popupConfig);

  onFeatureUnselect = function (feature) {
      if (feature.popup) {
        feature.popup.feature = null;
        M.removePopup(feature.popup);
        feature.popup.destroy();
        feature.popup = null;
      }
  };

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      onUnselect: onFeatureUnselect,
      highlightOnly: true,
      autoActivate: true
  });
  selectControl.onSelect = OpenLayers.Function.bind(onFeatureSelect, selectControl);

  M.addControl(selectControl);

};





NK.addLayerType = NK.addLayerType || {};

NK.addLayerType.geoJSONFile = (function (M, MP, P) {
  return function (id, name, url, options) {
    var layer,
        layerOptions,
        formatOptions,
        geoJSONFormat;

    formatOptions = {
      'internalProjection': MP,
      'externalProjection': MP 
    };

    // set external projection, if provided  
    if (options.epsgCode && P[options.epsgCode]) {
      formatOptions.externalProjection = P[options.epsgCode];
    }

    geoJSONFormat = new OpenLayers.Format.GeoJSON(formatOptions);

    layerOptions = {
      shortid: id, 
      protocol: new OpenLayers.Protocol.HTTP({
        'url': url,
        'format': geoJSONFormat
      }),
      strategies: [new OpenLayers.Strategy.Fixed({preload: true, autoActivate: true})],
      styleMap: NK.styles.omriss,
      projection: MP,
      displayInLayerSwitcher: (options && options.hideFromLayerSwitcher) ? 0 : 1,
      visibility: (options && options.visible) ? 1 : 0
    };
    if (options) {

      if (options.styleName && NK.styles && NK.styles[options.styleName]) {
        layerOptions.styleMap = NK.styles[options.styleName];
      }

      if (options.styleNameSLD && NK.styles && NK.styles.SLD && NK.styles.SLD[options.styleNameSLD]) {
        layerOptions.styleMap = NK.styles.SLD[options.styleName];
      }

      if (options.label) {
        var tempSM = layerOptions.styleMap;
        layerOptions.styleMap = new OpenLayers.StyleMap(
          {
            'default': tempSM.styles['default'].clone(),
            'select': tempSM.styles.select, 
            'temporary': tempSM.styles.temporary,
            'delete': tempSM.styles['delete']
          }
        );
        layerOptions.styleMap.styles['default'].context = {
          'getLabel': function (feature) {
            return feature.attributes[options.label];
          }
        };

        layerOptions.styleMap.styles['default'].defaultStyle.label = '${getLabel}';
      }

      if (options.cluster && NK.strategies.cluster) {
        layerOptions.strategies.push(NK.strategies.cluster);
      }
    }

    layer = new OpenLayers.Layer.Vector(
      name,
      layerOptions
    );

    if (options) {
      if (options.styleNameSLD && NK.styles && NK.styles.SLD && NK.styles.SLD[options.styleNameSLD]) {
        NK.functions.setSLDStyleForLayer(options.styleNameSLD, layer);
      }

      if (options.cluster) {
        NK.styles.addClusteringRule(layer.styleMap);
      }

      if (options && options.layerGroup) {
        layer = OpenLayers.Util.extend(layer, {'layerGroup': options.layerGroup});
      }

      if (options && options.visible) {
        NK.defaultVisibleLayers = NK.defaultVisibleLayers || [];
        NK.defaultVisibleLayers.push(id);
      }

      if (options && options.popupConfig) {
        NK.functions.popup.addConfiguredPopup(M, layer, options.popupConfig);
      }
    }
    
    M.addLayer(layer);
  };
}(map, mapProj, proj));



(function () {
  var options = {};

  options.layerGroup = 'tjenester.fakta';




  options.styleName = 'unlabeledMarker';



  options.epsgCode = '32633';

  options.popupConfig = (function () {
	var result = {
		'heading': 'OFFISIELT NAVN'
	};
	result.data = [];
	result.data.push({'attribute': 'FYLKESNAVN', 'label': 'Fylke', 'unit': ''});

result.data.push({'attribute': 'KOMMUNENAVN', 'label': 'Kommune', 'unit': ''});

result.data.push({'attribute': 'HOYDE [m]', 'label': 'H&oslash;yde', 'unit': 'm'});

	return result;
}());
;

  NK.addLayerType.geoJSONFile('fjelltopper', 'Kommunenes fjelltopper', '/json/tema/kommunefjell/Kommunefjell.geojson', options);
}());


  var removePopups = function () {
    var popup, p;

    for (p in map.popups) {
      if (map.popups.hasOwnProperty(p)) {
        popup = map.popups[p];

        map.removePopup(popup);
      }
    }
  };

  map.events.register('changelayer', map, removePopups);

  // Add controls at the end, to keep focus
  var controlContext = map;
  var container = null;
  var collect = null;

  NK.status = document.createElement("div");
NK.status.setAttribute("class","toolbar");
NK.status.setAttribute("id","status");
NK.status.messages = {};
document.body.appendChild(NK.status);

NK.status.refresh = function() {
  var content = "", msg, height;
  var now = new Date().getTime();
  for (msg in NK.status.messages) { 
    if (now > parseInt(msg) + 20000) {
      delete NK.status.messages[msg];
    }
  }
  for (msg in NK.status.messages) { 
    content += '<div class="statusmsg">'+NK.status.messages[msg]+'</div>';
  }
  NK.status.innerHTML = content;

  if (!!Object.keys(NK.status.messages).length) {
    $("#status").animate({"max-height": "200px"}); 
  } else {
    $("#status").animate({"max-height": "0px"}); 
  }
}

NK.functions.log = function(msg) {
  var now = new Date().getTime();
  NK.status.messages[new Date().getTime()] = msg;
  NK.status.refresh();
  setTimeout(NK.status.refresh, 21000);
  return now;
}
NK.functions.updateLog = function(time, msg) {
  delete NK.status.messages[time];
  NK.functions.log(msg);
}


NK.functions = NK.functions || {};

/**
 *  used by controls templates to place controls in the correct context
 *
 */
NK.functions.addControlToContext = function (control, context) {
  // utility method to add control to map or panel

  if (context.addControl) {
    // context is a map
    context.addControl(control);
  } else if (context.addControls) {
    // context is a panel
    context.addControls([control]);
  }
};




(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	

options.bind = true;
NK.geolocator = new OpenLayers.Control.Geolocate(options); 
NK.functions.addControlToContext(NK.geolocator, context);
}(controlContext, container));


(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	
options.dragPanOptions = {enableKinetic: false};
NK.functions.addControlToContext(new OpenLayers.Control.Navigation(options), context);
NK.functions.addControlToContext(new OpenLayers.Control.TouchNavigation(options), context);
NK.functions.addControlToContext(new OpenLayers.Control.KeyboardDefaults(options), context);
NK.functions.addControlToContext(new OpenLayers.Control.MousePosition({
	draw: function() {
		return this.div;
	}, 
	redraw: function(evt) {
		if (evt) {
			this.lastXy = evt.xy;
		}
	}
}), context);

}(controlContext, container));


(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
		

NK.functions.addControlToContext(new OpenLayers.Control.ScaleLine({bottomOutUnits:''}), context);

}(controlContext, container));




(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "basic-toolbar";



  container.className = className;
  parentContainer.appendChild(container);



	(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "fullscreen-panel";



  container.className = className;
  parentContainer.appendChild(container);



	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	

NK.functions.addControlToContext(new OpenLayers.Control.FullScreen(options), context);
}(controlContext, container));
}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "zoom-panel";



  container.className = className;
  parentContainer.appendChild(container);



	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	

NK.functions.addControlToContext(new OpenLayers.Control.ZoomBarWithButtons( options ), context);

}(controlContext, container));


(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	

NK.functions.addControlToContext(new OpenLayers.Control.ZoomToSelection(options), context);
}(controlContext, container));
}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "layerselector-panel";


      var header = document.createElement("button");
      header.className = "panel-name";
      header.innerHTML = 'Kartvalg';

        header.innerHTML += OpenLayers.Util.hideFromOldIE('<svg width="45" height="45" xmlns="http://www.w3.org/2000/svg"><g><title>Layer 1</title><path id="svg_1" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="m16.768551,38.517307l11.167488,4.42775v-36.803636l-11.167488,-4.427935v36.803631l0,0.000191zm-14.768551,4.911568l12.387096,-4.911568v-36.803627l-12.387096,4.911755v36.803642l0,-0.000202zm28.316563,-37.263813v36.803638l12.417843,-4.923439v-36.803629l-12.417843,4.923722l0,-0.000292l0,0z" fill="none"/></g></svg>');
      var div = document.createElement("div");
      div.setAttribute("id","map_chooser")
      div.setAttribute("class","widget")

      var wrapper = document.createElement("div");
      wrapper.setAttribute("class","wrapper")

      var cnt = document.createElement("div");
      cnt.setAttribute("class","cnt")
      cnt.setAttribute("id","layerswitcher")

      var wrapperHeader = document.createElement("div");
      var h3 = document.createElement("h3");
      var text = document.createTextNode("Velg karttype:");
      h3.appendChild(text);
      wrapperHeader.appendChild(h3);

      wrapper.appendChild(cnt);
      div.appendChild(wrapperHeader);
      div.appendChild(wrapper);

      container.appendChild(div);
      container.appendChild(header);

  container.className = className;
  parentContainer.appendChild(container);

    $('#layerselector-panel').click(this, function(event) {
      $(this).toggleClass('active');
    });


	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	
	options.layerGroup = "land";
	options.title = "Land";
options.popup = true;

var control = new OpenLayers.Control.RasterOverlayLayerSwitcher(options);
NK.functions.addControlToContext(control, context);

if (NK.functions.updateHistory) {
	control.events.register("buttonclick", NK.functions.updateHistory);
}

}(controlContext, container));


(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	
	options.layerGroup = "sjo";
	options.title = "Sj&oslash;";
options.popup = true;

var control = new OpenLayers.Control.RasterOverlayLayerSwitcher(options);
NK.functions.addControlToContext(control, context);

if (NK.functions.updateHistory) {
	control.events.register("buttonclick", NK.functions.updateHistory);
}

}(controlContext, container));


(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	
	options.layerGroup = "flere";
	options.title = "Flere";
options.popup = true;

var control = new OpenLayers.Control.RasterOverlayLayerSwitcher(options);
NK.functions.addControlToContext(control, context);

if (NK.functions.updateHistory) {
	control.events.register("buttonclick", NK.functions.updateHistory);
}

}(controlContext, container));


(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	

options.layerGroup = "dekning";
options.name = "Kart- inndeling";

var control = new OpenLayers.Control.VectorLayerSwitcher(options);
NK.functions.addControlToContext(control, context);

if (NK.functions.updateHistory) {
	control.events.register("buttonclick", NK.functions.updateHistory);
}

}(controlContext, container));
}(controlContext, container, collect));

}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "top-toolbar";



  container.className = className;
  parentContainer.appendChild(container);



	(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "logo-panel";



  container.className = className;
  parentContainer.appendChild(container);



	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	
	options.svgLogo = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="513px" height="181px" viewBox="0 0 513 181" class="kartverket logo" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Kartverket"><title>Kartverket</title><g class="text"><path d="M152.264,89.083h6.806v56.253h-6.806V89.083z M167.024,115.487l22.468,29.85h-8.61l-21.484-29.768l21.648-26.486h8.61L167.024,115.487z"/><path d="M226.408,146.894c-2.788-0.902-4.838-3.115-5.576-5.986c-3.936,3.938-7.134,5.494-11.808,5.494c-10.086,0-13.12-6.148-13.12-11.643c0-9.268,7.954-14.68,21.648-14.68c0.902,0,1.558,0,2.87,0.082v-2.869c0-3.607-0.164-5.084-1.312-6.396c-1.312-1.477-2.952-2.213-5.494-2.213c-4.592,0-10.414,2.459-13.038,4.838l-3.198-4.592c5.412-3.609,11.234-5.494,17.138-5.494c5.658,0,9.594,2.213,11.316,6.395c0.902,2.215,0.984,5.33,0.902,9.021l-0.328,13.447c-0.164,6.643,0.246,8.365,3.28,10.004L226.408,146.894z M217.06,124.427c-10.332,0-14.022,3.525-14.022,9.758c0,4.838,2.378,7.461,7.052,7.461c4.182,0,8.036-2.541,9.922-6.395l0.246-10.66C219.438,124.509,217.962,124.427,217.06,124.427"/><path d="M258.772,110.649c-0.409-0.164-1.147-0.328-1.805-0.328c-2.459,0-4.919,1.066-6.805,2.953c-1.886,1.885-2.378,3.115-2.378,6.477v25.586h-6.396v-31.488c0-5.33-1.148-8.119-1.394-8.693l6.396-1.721c0.328,0.654,1.558,3.607,1.312,6.641c2.952-4.182,7.298-6.805,11.479-6.805c0.985,0,1.968,0.328,2.214,0.41L258.772,110.649z"/><path d="M287.783,109.337h-8.529v26.322c0,4.512,1.23,6.068,5.248,6.068c1.805,0,2.871-0.246,4.02-0.82l0.9,4.102c-2.049,1.064-4.346,1.639-7.215,1.639c-2.133,0-3.771-0.41-5.33-1.146c-2.871-1.395-3.936-4.02-3.936-8.119v-28.045h-5.33v-4.838h5.33c0-3.525,0.492-9.02,0.656-10.332l6.723-1.475c-0.164,1.311-0.82,6.969-0.82,11.807h10.25L287.783,109.337z"/><path d="M317.695,145.747h-6.314l-14.678-40.92l6.561-1.393l9.512,28.125c0.984,2.953,1.805,6.232,1.969,6.971h0.164c0.164-0.656,0.818-3.607,1.967-6.888l9.348-27.144h6.807L317.695,145.747z"/><path d="M346.451,125.982v0.985c0,3.854,0.492,6.806,1.887,8.938c2.297,3.527,6.068,5.002,10.168,5.002c3.936,0,7.135-1.229,10.004-3.854l2.461,4.1c-3.609,3.281-8.529,5.084-13.777,5.084c-11.316,0-18.121-8.199-18.121-21.729c0-6.889,1.475-11.316,4.919-15.416c3.28-3.855,7.298-5.658,12.218-5.658c4.43,0,8.282,1.557,11.07,4.428c3.527,3.607,4.674,7.461,4.674,17.219v0.901H346.451z M363.262,112.044c-1.396-2.215-4.264-3.607-7.379-3.607c-5.822,0-9.104,4.264-9.432,12.709h18.697C365.066,116.718,364.491,114.013,363.262,112.044"/><path d="M401.352,110.649c-0.41-0.164-1.148-0.328-1.805-0.328c-2.459,0-4.92,1.066-6.805,2.953c-1.887,1.885-2.379,3.115-2.379,6.477v25.586h-6.396v-31.488c0-5.33-1.148-8.119-1.393-8.693l6.395-1.721c0.328,0.654,1.559,3.607,1.312,6.641c2.953-4.182,7.299-6.805,11.48-6.805c0.984,0,1.969,0.328,2.213,0.41L401.352,110.649z"/><path d="M412.592,145.337v-50.35c0-4.755-0.82-7.79-1.066-8.363l6.396-1.23c0.246,0.656,1.066,4.099,1.066,9.675v50.268H412.592z M438.012,145.337l-18.777-23.125l15.58-17.713h8.037l-16.072,17.713l19.762,23.125H438.012z"/><path d="M458.02,125.982v0.985c0,3.854,0.492,6.806,1.887,8.938c2.297,3.527,6.068,5.002,10.168,5.002c3.936,0,7.135-1.229,10.004-3.854l2.461,4.1c-3.609,3.281-8.529,5.084-13.777,5.084c-11.316,0-18.121-8.199-18.121-21.729c0-6.889,1.475-11.316,4.92-15.416c3.279-3.855,7.297-5.658,12.217-5.658c4.43,0,8.283,1.557,11.07,4.428c3.527,3.607,4.674,7.461,4.674,17.219v0.901H458.02z M474.83,112.044c-1.395-2.215-4.264-3.607-7.379-3.607c-5.822,0-9.104,4.264-9.432,12.709h18.697C476.635,116.718,476.061,114.013,474.83,112.044"/><path d="M511.057,109.337h-8.527v26.322c0,4.512,1.23,6.068,5.248,6.068c1.805,0,2.871-0.246,4.018-0.82l0.902,4.102c-2.049,1.064-4.346,1.639-7.215,1.639c-2.133,0-3.773-0.41-5.33-1.146c-2.871-1.395-3.938-4.02-3.938-8.119v-28.045h-5.33v-4.838h5.33c0-3.525,0.492-9.02,0.656-10.332l6.725-1.475c-0.164,1.311-0.82,6.969-0.82,11.807h10.25L511.057,109.337z"/></g><path class="outline" d="M9.538,0C4.272,0,0.002,4.271,0.002,9.54V172.152C0,176.729,4.272,181,9.538,181H114.46c5.266,0,9.537-4.271,9.537-9.539V9.538C124,4.271,119.726,0,114.46,0"/><path fill="#00963E" d="M111.575,4.992H12.423c-4.977,0-9.013,4.036-9.013,9.014v60.802c7.782-5.92,17.521-14.199,35.091-9.864C53.64,68.681,56.94,80.351,80.888,93.609c14.66,8.115,28.414,1.853,39.703-4.703v-74.9C120.591,9.028,116.552,4.992,111.575,4.992"/><path fill="#0058A3" d="M88.628,120.735c-4.939-0.604-8.781-2.312-12.557-4.761c-8.386-5.178-16.433-13.646-33.542-22.528c-13.63-6.622-26.924-1.573-39.106,5.37l-0.014,0.007v68.171c0,4.978,4.036,9.014,9.014,9.014h99.152c4.977,0,9.014-4.036,9.014-9.014v-55.576C110.007,117.484,99.847,122.412,88.628,120.735"/><path fill="#FFFFFF" d="M80.888,93.609C56.941,80.352,53.641,68.682,38.5,64.944c-17.569-4.335-27.308,3.944-35.091,9.864l0.017,12.266L3.424,98.816c12.182-6.944,25.657-12.352,39.107-5.37c17.107,8.882,25.154,17.349,33.541,22.528c3.82,2.359,7.711,4.035,12.558,4.761c11.217,1.676,21.377-3.253,31.961-9.318l-0.029-10.847l0.029-11.665C109.302,95.463,95.548,101.725,80.888,93.609"/></svg>';
NK.functions.addControlToContext(new OpenLayers.Control.Logo(options), context);

}(controlContext, container));
}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "search-panel";



  container.className = className;
  parentContainer.appendChild(container);



	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	
        options.coordinates = "http://norgeskart.no/ws/trans.py";
        options.searchUrl = "https://ws.geonorge.no/SKWS3Index/ssr/sok";
        options.streetAddressesSearchUrl = "http://norgeskart.no/ws/veg.py";
        options.addressSearchUrl = "http://norgeskart.no/ws/adr.py";
        options.propertySearchUrl = "http://norgeskart.no/ws/eie.py";
NK.functions.addControlToContext(new OpenLayers.Control.Search(options), context);

}(controlContext, container));
}(controlContext, container, collect));

}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;
	className = "minified toolbar";

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
  	className = "minified";
	}


  container = document.createElement("div");
    container.id = "secondary-toolbar";

        var header = document.createElement("button");

      header.className = "panel-name";
      var name = document.createElement('span');
      name.innerHTML = "Verkt&oslash;y";

        header.innerHTML = OpenLayers.Util.hideFromOldIE('<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="27px" height="27px" viewBox="0 0 27 27" class="icon tools" preserveAspectRatio="xMidYMid meet"><path d="M7.551,12.259c0.006,0.007,0.012,0.014,0.018,0.021l2.719,2.81l0.949-0.98l-1.024-1.056L9.75,12.574l2.373-2.452l0.313,0.036c0.08,0.009,0.162,0.014,0.243,0.014c0.164,0,0.324-0.021,0.48-0.057L11.412,8.31c-0.035-0.037-0.073-0.069-0.11-0.103c0.539-2,0.048-4.233-1.474-5.806C8.317,0.841,6.176,0.33,4.251,0.867l3.261,3.369L6.656,7.537L3.461,8.421L0.2,5.052c-0.52,1.989-0.025,4.201,1.485,5.762C3.272,12.453,5.554,12.934,7.551,12.259z M17.188,14.275c-0.054,0.242-0.067,0.494-0.041,0.748l0.035,0.324l-0.223,0.229l-1.688,1.743L14.809,17.8l-1.487-1.536l-0.949,0.979l8.609,8.894c0.529,0.549,1.227,0.822,1.922,0.822s1.391-0.273,1.921-0.822c1.062-1.096,1.062-2.873,0-3.97L17.188,14.275z M23.833,25.216l-1.365,0.378l-1.106-1.145l0.365-1.41l1.365-0.379l1.107,1.145L23.833,25.216z M13.332,15.316l1.486,1.535l1.688-1.742c-0.092-0.851,0.177-1.733,0.808-2.385c0.631-0.652,1.486-0.929,2.31-0.834l7.377-7.622L22.867,0L15.49,7.622c0.092,0.85-0.178,1.734-0.809,2.386c-0.631,0.651-1.486,0.928-2.309,0.834l-1.688,1.743l1.487,1.536l-7.29,7.531l-0.267-0.275L3.218,22.54l-2.354,3.84l0.601,0.621l3.717-2.433l1.127-1.445l-0.268-0.275L13.332,15.316z"/></svg>');

      header.appendChild(name);
      container.appendChild(header);
      OpenLayers.Event.observe(header, 'click', OpenLayers.Function.bind(function (evt) {
        if (OpenLayers.Element.hasClass(this,'minified')) {
          OpenLayers.Element.removeClass(this, 'minified');
        } else {
          OpenLayers.Element.addClass(this, 'minified');
          map.getControlsByClass('OpenLayers.Control.Draw')[0].hideControls(true);
          map.getControlsByClass('OpenLayers.Control.OverlayGroupPanel')[0].hideControls(true);
          map.getControlsByClass('OpenLayers.Control.HeightProfile')[0].hideControls(true);
          map.getControlsByClass('OpenLayers.Control.Transformations')[0].hideControls(true);
        }
      }, container));


  container.className = className;
  parentContainer.appendChild(container);



	(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "tools-panel";



  container.className = className;
  parentContainer.appendChild(container);



	

(function (context, container) {

	(function() {
var translations = {};

translations['Drawing'] = 'Tegne og m\u00E5le';
translations['Drawing tool'] = 'Tegne og m\u00E5le';
translations['Draw point'] = 'Tegn punkt';
translations['Draw line'] = 'Tegn linje';
translations['Draw polygon'] = 'Tegn areal';
translations['Draw label'] = 'Legg tekst til elementer i tegningen';
translations['Undo'] = 'Angre';
translations['Upload'] = 'Last opp';
translations['Upload files in GPX format. More to come.'] = 'Last opp filer i formatet GPX.';
translations['Download'] = 'Last ned';
translations['Download drawing in GeoJSON format. More options to come.'] = 'Last ned tegningen i formatet GeoJSON.';
translations['Save'] = 'Lagre';
translations['Longitude'] = 'Lengdegrad';
translations['Latitude'] = 'Breddegrad';
translations['Length'] = 'Lengde';
translations['Circumference'] = 'Omkrets';
translations['Area'] = 'Areal';
translations['Measures'] = 'M&aring;l';
translations['Cancel'] = 'Avbryt';
translations['Add text'] = 'Legg til tekst';
translations['Update'] = 'Oppdat&eacute;r';

OpenLayers.Util.extend(OpenLayers.Lang['nb'], translations);
}());


	var options = {};
	if (container) {
		options.div = container;
	}
	NK.styles = NK.styles || {};
NK.styles.track = NK.styles.track = new OpenLayers.StyleMap({
	'default': new OpenLayers.Style({
	  strokeWidth: 5,
	  strokeColor  : "#0058a3",
	  fillOpacity: 0.4,
	  fillColor: "#0058a3",
	  graphicName: 'circle',
	  pointRadius: 6,
	  fontColor: "#0058a3",
	  fontSize: "16px",
	  fontFamily: "Arial, sans-serif",
	  fontWeight: "normal",
	  labelAlign: "${getLabelAlign}",
	  label: "${getLabel}",
	  labelXOffset: "${getLabelXOffset}",
	  labelYOffset: 0,
	  labelOutlineColor: "white",
	  labelOutlineWidth: 3	  
	},
	{
		context: {
			getLabel: function (feature) {
				return feature.attributes.label || '';
			},
			getLabelXOffset: function (feature) {
				return (feature.geometry.CLASS_NAME === 'OpenLayers.Geometry.Point') ? 10 : 0;
			},
			getLabelAlign: function (feature) {
				return (feature.geometry.CLASS_NAME === 'OpenLayers.Geometry.Point') ? 'lm' : 'cm';
			}

		}
	}),
	'temporary': new OpenLayers.Style({
	  strokeWidth: 5,
	  strokeColor  : "#0058a3",
	  fillOpacity: 0.4,
	  strokeDashstyle: "${getStrokeDashStyle}",
	  fillColor: "#0058a3",
	  pointRadius: 6
	},
	{
		context: {
			getStrokeDashStyle: function (feature) {
				return (feature.geometry.CLASS_NAME === 'OpenLayers.Geometry.Point') ? 'solid' : 'dash';
			}
		}
	}),
	'select': new OpenLayers.Style({
	  strokeWidth: 6,
	  strokeColor  : "#f058a3",
	  fillOpacity: 0.4,
	  fillColor: "#f058a3",
	  pointRadius: 5,
	  cursor: 'text',
	  fontColor: "#0058a3",
	  fontSize: "16px",
	  fontFamily: "Arial, sans-serif",
	  fontWeight: "normal",
	  labelAlign: "${getLabelAlign}",
	  label: "${getLabel}",
	  labelXOffset: "${getLabelXOffset}",
	  labelYOffset: 0,
	  labelOutlineColor: "white",
	  labelOutlineWidth: 3	  
	},
	{
		context: {
			getLabel: function (feature) {
				return feature.attributes.label || '';
			},
			getLabelXOffset: function (feature) {
				return (feature.geometry.CLASS_NAME === 'OpenLayers.Geometry.Point') ? 10 : 0;
			},
			getLabelAlign: function (feature) {
				return (feature.geometry.CLASS_NAME === 'OpenLayers.Geometry.Point') ? 'lm' : 'cm';
			}

		}
	})
});





options.autoActivate = true;
options.activeDrawControl = 'point';

options.JSONDataStorageUrl = '/ws/upload-json.py';

	options.styleName = 'track';
	if (NK.styles && NK.styles[options.styleName]) {
		options.styleMap = NK.styles[options.styleName];
	}

var control = new OpenLayers.Control.Draw(options);
NK.functions.addControlToContext(control, context);

}(controlContext, container));


(function (context, container) {

	(function() {
var translations = {};

translations['Height profile'] = 'H\u00F8ydeprofil';
translations['Make a height profile'] = 'Lage h\u00F8ydeprofil';
translations['Click in the map to draw a line.'] = 'Klikk p&aring; steder i kartet for &aring; tegne opp en linje.';
translations['Double click to finish'] = 'Dobbeltklikk for &aring; avslutte';
translations['Use some other format'] = 'Bruk et annet format';
translations['Show height profile'] = 'Vis h&oslash;ydeprofil';
translations['Popular routes'] = 'Popul&aelig;re h&oslash;ydeprofiler';
translations['Birkebeinerrennet'] = 'Birkebeinerrennet';
translations['Besseggen'] = 'Besseggen';
translations['Norseman'] = 'Norseman';
translations['An error occured.'] = 'Det har skjedd en feil.';
translations['Unable to read track from file.'] = 'Filen inneholder ingen GPX-data.';
translations['Upload GPX file'] = 'Last opp en GPX-fil';
translations['Choose File'] = 'Velg fil';
translations['Enter WKT geometry data'] = 'Lim inn et WKT LINESTRING-uttrykk';
translations['Generating height profile visualization'] = 'Genererer h&oslash;ydeprofil-visualisering';
translations['Your height profile'] = 'Din h&oslash;ydeprofil';
translations['Close'] = 'Lukk';
translations['Open print friendly'] = '&Aring;pne utskriftsvennlig';

OpenLayers.Util.extend(OpenLayers.Lang['nb'], translations);
}());


	var options = {};
	if (container) {
		options.div = container;
	}
	

options.heightProfileServiceUrl = 'http://openwps.statkart.no/skwms1/wps.elevation';

options.gpxStorageUrl = '/ws/upload-gpx.py';

	var trackStyleName = 'track';
	if (NK.styles && NK.styles[trackStyleName]) {
		options.trackStyleMap = NK.styles[trackStyleName];
	}

	options.gpxTracks = options.gpxTracks || [];
options.gpxTracks.push({
	'name': 'Rallarvegen Haugast&oslash;l - Fl&aring;m',
	'url': '/xml/gpx/rallarvegen.gpx'
});

options.gpxTracks = options.gpxTracks || [];
options.gpxTracks.push({
	'name': 'Birkebeinerrittet',
	'url': '/xml/gpx/birkebeinerrittet.gpx'
});

options.gpxTracks = options.gpxTracks || [];
options.gpxTracks.push({
	'name': 'Birkebeinerrennet 2012',
	'url': '/xml/gpx/birkebeinerrennet-2012.gpx'
});


var control = new OpenLayers.Control.HeightProfile(options);
NK.functions.addControlToContext(control, context);
}(controlContext, container));


(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	
	options.url = "/ws/trans.py";

var control = new OpenLayers.Control.Transformations(options);
NK.functions.addControlToContext(control, context);
}(controlContext, container));
}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "services-panel";

        var header = document.createElement("div");

      header.className = "panel-name";
      var name = document.createElement('span');
      name.innerHTML = "Tjenester";


      header.appendChild(name);
      container.appendChild(header);
      OpenLayers.Event.observe(header, 'click', OpenLayers.Function.bind(function (evt) {
        if (OpenLayers.Element.hasClass(this,'minified')) {
          OpenLayers.Element.removeClass(this, 'minified');
        } else {
          OpenLayers.Element.addClass(this, 'minified');
          map.getControlsByClass('OpenLayers.Control.Draw')[0].hideControls(true);
          map.getControlsByClass('OpenLayers.Control.OverlayGroupPanel')[0].hideControls(true);
          map.getControlsByClass('OpenLayers.Control.HeightProfile')[0].hideControls(true);
          map.getControlsByClass('OpenLayers.Control.Transformations')[0].hideControls(true);
        }
      }, container));


  container.className = className;
  parentContainer.appendChild(container);



	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	

	options.group = 'tjenester.fakta';
	options.buttonText = 'Fakta';
options.title = "Fakta";


var control = new OpenLayers.Control.OverlayGroupPanel(options);
NK.functions.addControlToContext(control, context);
}(controlContext, container));
}(controlContext, container, collect));

}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "overview-container-panel";



  container.className = className;
  parentContainer.appendChild(container);



	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	


NK.styles = NK.styles || {};
NK.styles.omriss = new OpenLayers.StyleMap(
	{
	  'default': new OpenLayers.Style(
	    {
	      strokeWidth: 0,
	      strokeColor: "#606161",
	      strokeOpacity: 0.5,
	      fillOpacity: 1,
	      fillColor: "white"
	    }
	  )
	}
);


OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Show big overview map': 'Vis stort oversiktskart',
  'Show small overview map': 'Vis lite oversiktskart'
});

(function (M, MP, P) {
  var layer,
      requestHandler,
      control,
      detailedLayer;

  var norgeExtent = new OpenLayers.Bounds(-76856, 6453900, 1114892, 7939873);

  layer = new OpenLayers.Layer.Vector(
    "omriss",
    {
      shortid: "omriss.norge.500m", 
      styleMap: NK.styles.omriss, 
      visibility: true
    }
  );

  requestHandler = function (request) {
    var geojson_format,
        features;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['32633'] 
    });


    features = geojson_format.read(request.responseText);

    layer.addFeatures(features);

    for (i = 0, j = M.layers.length; i < j; i += 1) {
      if (M.layers[i].shortid && M.layers[i].shortid === 'enkel') {
        detailedLayer = M.layers[i].clone();
        break;
      }
    }

  	options.maximized = true;
  	options.maximizeTitle = OpenLayers.Lang.translate('Show big overview map');
  	options.minimizeTitle = OpenLayers.Lang.translate('Show small overview map');
    options.minRatio = 32;
    options.maxRatio = 32;
    options.size = {w: 80, h: 90};
    options.autoPan = true;
    options.minRectSize = 5;

    options.mapOptions = OpenLayers.Util.extend(NK.mapOptions, {
      numZoomLevels: NK.zoomLevels,
      restrictedExtent: norgeExtent,
      controls: [],
      baseLayer: layer
    });

    if (detailedLayer) {
      options.layers = [layer, detailedLayer];
    } else {
      options.layers = [layer];
    }

    control = new OpenLayers.Control.OverviewMapExpandable(options);
  	NK.functions.addControlToContext(control, context);

  };

  OpenLayers.Request.GET({
    url: "/json/norge/500m.geojson",
    callback: requestHandler
  });

}(map, mapProj, proj));


}(controlContext, container));
}(controlContext, container, collect));



  // initialize URL update state
  if (NK.functions.storeInitialLayerVisibility) {
    NK.functions.storeInitialLayerVisibility();
  }

  var mapPosition = {x: null, y: null};
  if (NK.functions.setMapStateFromURL) {
    mapPosition = NK.functions.setMapStateFromURL();
  }

  // decide which position to use
  if (!(mapPosition.x && mapPosition.y)) {
    map.setCenter(NK.defaultCenter, NK.defaultZoom);

    if (NK.geolocator) {
      NK.geolocator.activate();
    } 
  }

  if (NK.functions.postMessage) {
    (function () {
      var vectorLayers,
          layer,
          feature,
          vectorLayerData = [],
          vectorFeatureData = [],
          i, 
          j,
          k,
          l,
          message;

      vectorLayers = map.getLayersByClass("OpenLayers.Layer.Vector").slice();

      for (i = 0, j = vectorLayers.length; i < j; i += 1) {
        layer = vectorLayers[i];
        vectorLayerData.push({shortid: layer.shortid, name: layer.name, visibility: layer.visibility});

        if (layer.visibility && layer.features && layer.features.length) {

          for (k = 0, l = layer.features.length; k < l; k += 1) {
            feature = layer.features[k];
            vectorFeatureData.push({
              "feature": feature.fid,
              "attributes": feature.attributes
            });
          }

        }
      }

      message = {
        "type": "mapInitialized",
        "vectorLayers": vectorLayerData
      };

      if (vectorFeatureData.length > 0) {
        message.visibleLayerFeatures = vectorFeatureData;
      }

      NK.functions.postMessage(message);
    }());

  }
  map.addControl(new OpenLayers.Control.Attribution());

};
// end init()


var addEvent = function(event, handler) {
  var listen = window.addEventListener || window.attachEvent;
  if (window.addEventListener) {
    listen(event, handler, false);
  } else {
    listen("on" + event, handler);
  }
};

var cb = function(response, status, request) {
  NK.gkToken = request.responseText.replace(/[\"\r\n]/g, '');
};
var startTicket = function(response, status, request) {
  NK.encTicket = request.responseText.replace(/[\"\r\n]/g, '');
  NK.init();
};

var initializeToken = function () {
  $.ajax({
    url: NK.ticketService,
    success: startTicket,
    type: 'GET'
  });
  $.ajax({
    url: NK.tokenService, 
    success: cb,
    type: 'GET'
  });
};
addEvent('load', initializeToken);


"use strict";

var NK = NK || {};
NK.mapEventListeners = {};

var gkopen, 
    gkopen_wmts,
    proj,
    mapProj,
    mapBounds,
    xdmsocket,
    initLayers,
    postEvent,
    map;

gkopen = "http://opencache.statkart.no/gatekeeper/gk/gk.open";
gkopen_wmts = "http://opencache.statkart.no/gatekeeper/gk/gk.open_wmts";

NK.gkToken = "unInitialized";
NK.encTicket = "unInitialized";

NK.tokenService = "http://norgeskart.no/ws/gkt.py";

NK.ticketService = "http://norgeskart.no/ws/esk.py?wms.ecc_enc";

NK.baseProjection = "32633";
NK.baseProjection = "32633";

NK.tokenLastUpdated = new Date(0);
NK.ticketLastUpdated = new Date(0);
NK.tokenUpdatePaused = false;
NK.ticketUpdatePaused = false;


NK.tokenError = {
  PAUSE_MINUTES: 2,
  RELOAD_LIMIT_SECONDS: 15,
  messagePopup: null,
  pauseTimeRemainingElement: null,
  pauseTimeRemainingText: null,
  pauseTimer: null,
  pauseCountdownTimer: null
};
NK.ticketError = {
  PAUSE_MINUTES: 2,
  RELOAD_LIMIT_SECONDS: 15,
  messagePopup: null,
  pauseTimeRemainingElement: null,
  pauseTimeRemainingText: null,
  pauseTimer: null,
  pauseCountdownTimer: null
};



NK.mapservers = {};
NK.mapservers.wmts = [
  "http://gatekeeper1.geonorge.no/BaatGatekeeper/gk/gk.cache_wmts",
  "http://gatekeeper2.geonorge.no/BaatGatekeeper/gk/gk.cache_wmts",
  "http://gatekeeper3.geonorge.no/BaatGatekeeper/gk/gk.cache_wmts"
];
NK.zoomLevels = 18;

NK.functions = NK.functions || {};

NK.functions.resetTokenError = function () {
  if (NK.tokenError.pauseTimeRemainingElement) {
    NK.tokenError.pauseTimeRemainingElement.parentNode.removeChild(NK.tokenError.pauseTimeRemainingElement);
    NK.tokenError.pauseTimeRemainingElement = null;
  }
  if (NK.tokenError.messagePopup) {
    NK.tokenError.messagePopup.parentNode.removeChild(NK.tokenError.messagePopup);
    NK.tokenError.messagePopup = null;
  }
  if (NK.tokenError.pauseTimer) {
    clearTimeout(NK.tokenError.pauseTimer);
    NK.tokenError.pauseTimer = null;
  }
  if (NK.tokenError.pauseCountdownInterval) {
    clearInterval(NK.tokenError.pauseCountdownInterval);
    NK.tokenError.pauseCountdownInterval = null;
  }
};

NK.functions.resetTicketError = function () {
  if (NK.ticketError.pauseTimeRemainingElement) {
    NK.ticketError.pauseTimeRemainingElement.parentNode.removeChild(NK.ticketError.pauseTimeRemainingElement);
    NK.ticketError.pauseTimeRemainingElement = null;
  }
  if (NK.ticketError.messagePopup) {
    NK.ticketError.messagePopup.parentNode.removeChild(NK.ticketError.messagePopup);
    NK.ticketError.messagePopup = null;
  }
  if (NK.ticketError.pauseTimer) {
    clearTimeout(NK.ticketError.pauseTimer);
    NK.ticketError.pauseTimer = null;
  }
  if (NK.ticketError.pauseCountdownInterval) {
    clearInterval(NK.ticketError.pauseCountdownInterval);
    NK.ticketError.pauseCountdownInterval = null;
  }
};

NK.functions.updateToken = function (request) {
  var i, 
      j, 
      reloadLimit;

  reloadLimit = new Date(Date.now() - NK.tokenError.RELOAD_LIMIT_SECONDS * 1000);

  NK.gkToken = request.responseText.replace(/[\"\r\n]/g, '');

  if (NK.tokenLastUpdated < reloadLimit) { // was token updated less than RELOAD_LIMIT_SECONDS ago?
    if (!NK.tokenUpdatePaused) {
      NK.functions.resetTokenError();
      NK.tokenLastUpdated = new Date();

      for (i = 0, j = map.layers.length; i < j; i += 1) {
        if (map.layers[i].params && map.layers[i].params.gkt) {
          map.layers[i].params.gkt = NK.gkToken;
          map.layers[i].redraw();
        }
      }
    }
  } else {
    NK.functions.pauseTokenUpdate();
  }
};
NK.functions.updateTicket = function (request) {
  var i,
    j,
    reloadLimit;

  reloadLimit = new Date(Date.now() - NK.ticketError.RELOAD_LIMIT_SECONDS * 1000);

  NK.encTicket = request.responseText.replace(/[\"\r\n]/g, '');

  if (NK.tokenLastUpdated < reloadLimit) { // was token updated less than RELOAD_LIMIT_SECONDS ago?
    if (!NK.ticketUpdatePaused) {
      NK.functions.resetTicketError();
      NK.ticketLastUpdated = new Date();

      for (i = 0, j = map.layers.length; i < j; i += 1) {
        if (map.layers[i].params && map.layers[i].params.ticket) {
          map.layers[i].params.ticket = NK.encTicket;
          map.layers[i].redraw();
        }
      }
    }
  } else {
    NK.functions.pauseTicketUpdate();
  }
};

NK.functions.pauseTokenUpdate = function () {
  if (!NK.tokenUpdatePaused) {
    NK.tokenUpdatePaused = true;

    NK.functions.log(OpenLayers.Lang.translate('Server error') +" - "+ OpenLayers.Lang.translate('An error has occured.'));

    NK.tokenError.pauseTimer = setTimeout(function () {
      NK.tokenUpdatePaused = false;
      NK.functions.getNewToken();
    },  60 * parseInt(NK.tokenError.PAUSE_MINUTES, 10) * 1000);

    NK.tokenError.pauseCountdownInterval = setInterval(function () {
      var content, timeLeft;
      if (NK.tokenError.pauseTimeRemainingElement) {
        content = NK.tokenError.pauseTimeRemainingElement.innerHTML;
        timeLeft = (parseInt(content, 10) - 1);
        NK.tokenError.pauseTimeRemainingElement.innerHTML = timeLeft.toString();
        if (timeLeft === 1) {
          if (NK.tokenError.pauseTimeRemainingText.textContent) {
            NK.tokenError.pauseTimeRemainingText.textContent = ' ' + OpenLayers.Lang.translate('minute.');
          } else {
            // old IE...
            NK.tokenError.pauseTimeRemainingText.innerText = ' ' + OpenLayers.Lang.translate('minute.');
          }
        }
      }
    }, 60 * 1000);
  }
};
NK.functions.pauseTicketUpdate = function () {
  if (!NK.ticketUpdatePaused) {
    NK.ticketUpdatePaused = true;

    NK.functions.log(OpenLayers.Lang.translate('Server error') +" - "+ OpenLayers.Lang.translate('An error has occured.'));

    NK.ticketError.pauseTimer = setTimeout(function () {
      NK.ticketUpdatePaused = false;
      NK.functions.getNewTicket();
    },  60 * parseInt(NK.ticketError.PAUSE_MINUTES, 10) * 1000);

    NK.ticketError.pauseCountdownInterval = setInterval(function () {
      var content, timeLeft;
      if (NK.ticketError.pauseTimeRemainingElement) {
        content = NK.ticketError.pauseTimeRemainingElement.innerHTML;
        timeLeft = (parseInt(content, 10) - 1);
        NK.ticketError.pauseTimeRemainingElement.innerHTML = timeLeft.toString();
        if (timeLeft === 1) {
          if (NK.ticketError.pauseTimeRemainingText.textContent) {
            NK.ticketError.pauseTimeRemainingText.textContent = ' ' + OpenLayers.Lang.translate('minute.');
          } else {
            // old IE...
            NK.ticketError.pauseTimeRemainingText.innerText = ' ' + OpenLayers.Lang.translate('minute.');
          }
        }
      }
    }, 60 * 1000);
  }
};

NK.functions.getNewToken = function () {
  if (NK.gkToken !== null) {
    NK.gkToken = null;
    OpenLayers.Request.GET({url: NK.tokenService, success: NK.functions.updateToken});
  }
};
NK.functions.getNewTicket = function () {
  if (NK.encTicket !== null) {
    NK.encTicket = null;
    OpenLayers.Request.GET({url: NK.ticketService, success: NK.functions.updateTicket});
  }
};

var closePopupCallBack = function () {
  var itemIndex;
  for (itemIndex = 0; itemIndex < map.popups.length; itemIndex++) {
    map.popups[itemIndex].hide();
  }
  this.hide();
};



NK.init = function () {

  var prmstr,
      prmarr,
      params,
      tmparr,
      i,
      j;

  if (!OpenLayers || !Proj4js) {
    setTimeout(NK.init, 100);
    return;
  }

  Proj4js.defs["EPSG:4326"] ="+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";
  Proj4js.defs["EPSG:32631"]="+proj=utm +zone=31 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32632"]="+proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32633"]="+proj=utm +zone=33 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32634"]="+proj=utm +zone=34 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32635"]="+proj=utm +zone=35 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32636"]="+proj=utm +zone=36 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:25831"]="+proj=utm +zone=31 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25832"]="+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25833"]="+proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25834"]="+proj=utm +zone=34 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25835"]="+proj=utm +zone=35 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25836"]="+proj=utm +zone=36 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:3575"] ="+proj=laea +lat_0=90 +lon_0=10 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:3034"] ="+proj=lcc +lat_1=35 +lat_2=65 +lat_0=52 +lon_0=10 +x_0=4000000 +y_0=2800000 +ellps=GRS80 +units=m +no_defs";

  NK.projections = proj = {  
    //pregenerated projection objects
    "32633": new OpenLayers.Projection('EPSG:32633'),
    "32631": new OpenLayers.Projection('EPSG:32631'),
    "32632": new OpenLayers.Projection('EPSG:32632'),
    "32634": new OpenLayers.Projection('EPSG:32634'),
    "32635": new OpenLayers.Projection('EPSG:32635'),
    "32636": new OpenLayers.Projection('EPSG:32636'),
    "25831": new OpenLayers.Projection('EPSG:25831'),
    "25832": new OpenLayers.Projection('EPSG:25832'),
    "25833": new OpenLayers.Projection('EPSG:25833'),
    "25834": new OpenLayers.Projection('EPSG:25834'),
    "25835": new OpenLayers.Projection('EPSG:25835'),
    "25836": new OpenLayers.Projection('EPSG:25836'),
    "4326" : new OpenLayers.Projection('EPSG:4326'),
    "3034" : new OpenLayers.Projection('EPSG:3034'),
    "3575" : new OpenLayers.Projection('EPSG:3575')
  };

  mapProj = proj[NK.baseProjection];
  mapBounds = new OpenLayers.Bounds(-2500000.0,3500000.0,3045984.0,9045984.0);

  OpenLayers.Util.onImageLoadErrorColor = 'transparent';
  OpenLayers.ImgPath = 'img/';

  OpenLayers.Lang.setCode('nb');

  // extract URL parameters into dictionary
  prmstr = window.location.search.substr(1);
  prmarr = prmstr.split ("&");
  params = {};

  for (i = 0, j = prmarr.length; i < j; i += 1) {
    tmparr = prmarr[i].split("=");
    params[tmparr[0]] = tmparr[1];
  }

  // Create map canvas

  if (!!params.proj) {
    mapProj = proj[params.proj]; 
  }
var options = {
};

  NK.mapOptions = {
    projection: mapProj,
    displayProjection: mapProj,
    maxExtent:  mapBounds,
    units: "m",
    maxResolution: 21664.0,
  //      minResolution: 0.165283203125,
    numZoomLevels: NK.zoomLevels,
  theme: 'theme/norgeskart/style.css'
  };

  map = new OpenLayers.Map( 
    'map', 
    OpenLayers.Util.extend(NK.mapOptions, {
      controls: [], //defined later
      numZoomLevels: NK.zoomLevels,
      eventListeners: NK.mapEventListeners
    })
  );

  // Default placement and zoom of the map
  NK.defaultCenter = new OpenLayers.LonLat(378604,7226208);
NK.defaultZoom = 5;



  // Base layers
  var matrixIds,
    wmts,
    i;

matrixIds = new Array(NK.zoomLevels);

for (i = 0; i <= NK.zoomLevels; ++i) {
  matrixIds[i] = {};
  matrixIds[i].identifier = mapProj + ":" + i;
} 

wmts = new OpenLayers.Layer.WMTS({
  name: "Europa",
  url: NK.mapservers.wmts,
  layer: "egk",
  matrixSet: mapProj,
  matrixIds: matrixIds,
  format: "image/png",
  requestEncoding: "kvp",
  style: "default",
  shortid: "europa", 
  visibility: 0, 
  transitionEffect: 'resize',
  opacity: 1.0,
  params: {
    gkt: NK.gkToken
  }
});

if (wmts.params.GKT) {
  wmts.params.gkt = wmts.params.GKT;
  delete wmts.params.GKT; 
}

wmts.events.register("tileerror", wmts, function(arg) {
  NK.functions.getNewToken();
});

map.events.register('zoomend', wmts, function (evt) {
  this.setVisibility(map.getZoom() <= 6);
});

map.addLayers([wmts]);


  // Overlays
  
NK.addLayerType = NK.addLayerType || {};
NK.addLayerType.WMTS = (function (M, MP) {
  var matrixIds = [],
      i;

  for (i = 0; i <= NK.zoomLevels; ++i) {
    matrixIds[i] = {};
    matrixIds[i].identifier = MP + ":" + i;
  } 

  return function (id, name, url, layer, options) {
    var layer, 
        layerOptions;
    var myMatrixIds = matrixIds;

    if (!!options.customProj) {
      var myMatrixIds = [],
        i;

      for (i = 0; i <= NK.zoomLevels; ++i) {
        myMatrixIds[i] = {};
        if (!!options.shortMatrixIds) {
          myMatrixIds[i].identifier = "" + i;
        } else {
          myMatrixIds[i].identifier = options.customProj + ":" + i;
        }
      } 
    } 

    layerOptions = {
      'name': name,
      'url': url,
      'layer': layer,
      'matrixSet': options.customProj || MP,
      'matrixIds': myMatrixIds,
      'format': "image/png",
      'requestEncoding': "kvp",
      'style': "default",
      'shortid': id, 
      'isBaseLayer': false,
      'linkedTo': options.linkedTo || null,
      'transitionEffect': 'resize',
      'displayOutsideMaxExtent': false,
      'buffer': 1
    };

    if (!!options.attribution) {
      layerOptions['attribution'] = options.attribution;
    }
    if (!!options.extent) {
      var c = options.extent.split(",");
      var customBounds = new OpenLayers.Bounds(c);
      layerOptions['tileFullExtent'] = customBounds;
    }
    if (!!options.tileorigin) {
      var c = options.tileorigin.split(",");
      var origin = new OpenLayers.LonLat(c);
      layerOptions['tileOrigin'] = origin;
    }
    if (!!options.databbox) {
      var c = options.databbox.split(",");
      var customBounds = new OpenLayers.Bounds(c);
      layerOptions['maxExtent'] = customBounds;
      layerOptions['visibility'] = 1;
    }

    layerOptions.displayInLayerSwitcher = !!(options.displayInLayerSwitcher) ? 1 : 0;
    layerOptions.visibility = !!(options.visibility) ? 1 : 0;

    if (!!options.params) {
      layerOptions.params = options.params;
    }

    layer = new OpenLayers.Layer.WMTS(layerOptions);

    if (options.layerGroup) {
      layer = OpenLayers.Util.extend(layer, {
        'layerGroup': options.layerGroup
      });
    }

    if (layer.params.GKT) {
      layer.params.gkt = layer.params.GKT;
      delete layer.params.GKT; 
    }

    if (options.visible) {
      NK.defaultVisibleLayers = NK.defaultVisibleLayers || [];
      NK.defaultVisibleLayers.push(id);
    }

    if (options.linkedTo) {
      layer.events.register("visibilitychanged", layer, function(arg) {
        map.getLayersBy("shortid",options.linkedTo)[0].setVisibility(layer.getVisibility());
      });
    }

    layer.events.register("tileerror", layer, function(arg) {
      NK.functions.getNewToken();
    });

    M.addLayers([layer]);

    return layer;
  };
}(map, mapProj));



(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = false;

    options.visibility = true;

    options.layerGroup = "modus";

    options.params = { 'gkt': NK.gkToken };








  var layer = NK.addLayerType.WMTS('toporaster', 'Terreng&shy;modell', url, 'toporaster2', options);

}());


(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;


    options.layerGroup = "sjo";

    options.params = { 'gkt': NK.gkToken };








  var layer = NK.addLayerType.WMTS('sjo', 'Hovedkart', url, 'sjokartraster', options);

}());



NK.functions = NK.functions || {};
NK.functions.vector = NK.functions.vector || {};

NK.functions.vector.markAllById = function (layer, intent, preserveIntent) {
  return function(element, evt) {
    if (preserveIntent && element.feature.renderIntent === preserveIntent) {
      return false;
    }
    // highlight all elements with the same element.feature.fid
    var ident = layer.getFeaturesByFid(element.feature.fid);
    $.each(ident, function (i, feature) {

      if (preserveIntent && feature.renderIntent === preserveIntent) {
        return false;
      } else {
        feature.renderIntent = intent;
        layer.drawFeature(feature);
      }
    });
  };
};

NK.functions.vector.addVectorHoverControls = function (map, layer, options) {
  var hoverCtrl,
      selectFeatureProperties;

  selectFeatureProperties = {
      hover: true,
      highlightOnly: true,
      renderIntent: "temporary"
  };

  if (options && options.groupByFid) {
    selectFeatureProperties.eventListeners = {
        beforefeaturehighlighted: NK.functions.vector.markAllById(layer, "temporary", options.preserveIntent),
        featureunhighlighted: NK.functions.vector.markAllById(layer, "default", options.preserveIntent)
    };
  }

  hoverCtrl = new OpenLayers.Control.SelectFeature(
    layer,
    selectFeatureProperties
  );


  map.addControl(hoverCtrl);
  hoverCtrl.activate();
  return hoverCtrl;
};

NK.functions.vector.addVectorControls = function (map, layer, options) {
  var controls = {};

  controls.hover = NK.functions.vector.addVectorHoverControls(map, layer, options);

  return controls;
};




NK.styles = NK.styles || {};
NK.styles.dekning = NK.styles.dekning || {};
NK.styles.dekning.land = new OpenLayers.StyleMap(
	{
	  'default': new OpenLayers.Style(
	    {
	      strokeWidth: 2,
	      strokeColor  : "#484",
	      fillOpacity: 0.1, 
	      label : "${nr}",
	      fontColor: "#8a8",
	      fontSize: "12px",
	      fontFamily: "Courier New, monospace",
	      fontWeight: "bold",
	      labelAlign: "cm",
	      labelOutlineColor: "white",
	      labelOutlineWidth: 5
	    },
	    {
	      rules: [
	        new OpenLayers.Rule({
	          maxScaleDenominator: 5000000,
	          symbolizer: {
	            label: "${nr}"
	          }
	        }),
	        new OpenLayers.Rule({
	          minScaleDenominator: 5000000,
	          symbolizer: {
	            label: ""
	          }
	        }),
	        new OpenLayers.Rule({
	          filter: new OpenLayers.Filter.Comparison({
	            type: OpenLayers.Filter.Comparison.LIKE,
	            property: "u",
	            value: "2013"
	          }),
	          symbolizer: {
	            strokeColor  : "#844",
	            fontColor: "#a88"
	          }
	        })
	      ]
	    }
	  ),
	  'temporary': new OpenLayers.Style(
			{
		      strokeWidth: 3,
		      strokeColor  : "#ada",
		      fontColor: "#ada",
		      fillOpacity: 0.1
			},
			{
				rules: [
			        new OpenLayers.Rule({
			        	symbolizer: {
					        strokeColor  : "#ada",
					        fontColor: "#ada"
				        }
				    }),
			        new OpenLayers.Rule({
						filter: new OpenLayers.Filter.Comparison({
							type: OpenLayers.Filter.Comparison.LIKE,
							property: "u",
							value: "2013"
						}),
						symbolizer: {
							strokeColor  : "#daa",
							fontColor: "#daa"
						}
			    })
				]
			}
	  )
	}
);



(function (M, MP, P) {
  var layer,
      selectControl,
      onPopupClose = null,
      onFeatureUnselect,
      onFeatureSelect,
      generatePopupMarkup,
      requestHandler;

  // dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Landkart 1:50000",
    {
      shortid: "dekning.plast", 
      styleMap: NK.styles.dekning.land, 
      visibility: 1,
      layerGroup: "dekning",
      preferredBackground: "toporaster"
    }
  );

  M.addLayer(layer);

  requestHandler = function (request) {
    var geojson_format,
        features,
        feature, 
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['32633'] 
    });

    features = geojson_format.read(request.responseText);

    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        feature.attributes.nr = feature.fid;
      }
    }
    layer.addFeatures(features);
  };

  OpenLayers.Request.GET({
    url: "/json/dekning/land/n50/plast.json",
    callback: requestHandler
  });

  onPopupClose = function (evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  };

  generatePopupMarkup = function (feature) {
    var a  = feature.attributes;
      var markup = '<article>';
      if (a.n && a.n !== 'NULL') {
        markup += '<h1 class="h">' + a.n + '</h1>';
      }
      if (a.nr) {
        markup += '<p>' + OpenLayers.Lang.translate('Map number') + ': ' + a.nr + '</p>';
      }
      if (a.k) {
        markup += '<div class="municipalities">' + OpenLayers.Lang.translate('Municipalities') + ': <span>' + a.k.split(',').join(',</span><span>') + '</span></div>';
      }
      if (a.u) {
        markup += '<p>' + OpenLayers.Lang.translate('Updated') + ': ' + a.u + '</p>';
      }
      if (a.e) {
        markup += '<p>' + OpenLayers.Lang.translate('EAN-number') + ': ' + a.e + '</p>';
      }
      markup += '</article>';
      return markup;
  };

  onFeatureUnselect = function (feature) {
      if (feature === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      if (feature.popup) {
        M.removePopup(feature.popup);
        feature.popup.destroy();
        feature.popup = null;
      }
  };

  onFeatureSelect = function (feature) {
      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        var message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };
        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {
        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;
        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
    }
  };

  NK.functions.vector.addVectorHoverControls(M, layer);

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect,
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);


OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Map number': 'Kartblad',
  'Latest print': 'Siste trykk',
  'Datum': 'Datum',
  'Municipalities': 'Kommuner',
  'EAN-number': 'EAN-nummer',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Updated': 'Sist oppdatert',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});


}(map, mapProj, proj));

(function (M, MP, P){
  var styleMap,
      layer,
      dataResponseHandler,
      highlightAllById,
      unhighlightAllById,
      selectControl;

    styleMap = new OpenLayers.StyleMap({
    'default': new OpenLayers.Style(
      {
        strokeWidth: 2,
        strokeColor  :"#844",
        fillOpacity: 0.1, 
        strokeOpacity: 1,

        label : "${nr}",
        fontColor: "#a88",
        fontSize: "12px",
        fontFamily: "Courier New, monospace",
        fontWeight: "bold",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 5
      }, 
      {
        rules: [
          new OpenLayers.Rule({
            maxScaleDenominator: 2500000,
            symbolizer: {
              label: "${nr}"
            }
          }),
          new OpenLayers.Rule({
            minScaleDenominator: 2500000,
            symbolizer: {
              label: ""
            }
          })       
        ]
      }
    ),
    'temporary': {
      strokeWidth: 6,
      strokeColor  : "#daa",
      fontColor: "#daa",
      fillOpacity: 0.1
    }
  });
  

  
	styleMap.styles['default'].defaultStyle.strokeColor = "#484";
	styleMap.styles['default'].defaultStyle.fontColor = "#8a8";
	styleMap.styles.temporary.defaultStyle.strokeColor = "#ada";
	styleMap.styles.temporary.defaultStyle.fontColor = "#ada";


  //dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Hoved&shy;kart sj&oslash;",
    {
      shortid: "dekning.sjo",
      styleMap: styleMap,
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "sjo"
    }
  );

  dataResponseHandler = function(request) {
    var geojson_format, 
        features,
        feature,
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['4326'] 
    });
    features = geojson_format.read(request.responseText);
    features = features.sort(function (a,b) {
       // sort by area
      return b.geometry.getArea() - a.geometry.getArea();
    });
    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        if (feature.fid.length < 4) {
          feature.attributes.nr = feature.fid;
          feature.attributes.vignett = '';
        } else {
          feature.attributes.nr = '';
          feature.attributes.vignett = feature.fid;
          feature.fid = feature.fid.slice(0, 3);
        }
      }
    }
    layer.addFeatures(features);
  };

  M.addLayer(layer);

  OpenLayers.Request.GET({
    url: "/json/dekning/sjo/hovedserie_ny.json",
    callback: dataResponseHandler
  });

  highlightAllById = function(element) {
    // highlight all elements with the same element.feature.fid;
    var ident = layer.getFeaturesByFid (element.feature.fid);
    $.each(ident, function(i, feature) {
      feature.renderIntent = "temporary";
      layer.drawFeature(feature);
    });
  };

  // un-highlight all elements with the same element.feature.fid;
  unhighlightAllById = function(element) {
    var ident = layer.getFeaturesByFid (element.feature.fid);

    $.each(ident, function(i, feature) {
      feature.renderIntent = "default";
      layer.drawFeature(feature);
    });
  };

  var highlightDekningCtrl = new OpenLayers.Control.SelectFeature(layer, {
    hover: true,
    multiple: true,
    highlightOnly: true,
    renderIntent: "temporary",
    eventListeners: {
        beforefeaturehighlighted: highlightAllById,
        featureunhighlighted: unhighlightAllById
    },
    autoActivate: true
  });
  map.addControl(highlightDekningCtrl);
  
  function onPopupClose(evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  }

  function projectionName(projectionNumber) {
    switch (projectionNumber) {
      case '8':
        return 'Mercator';
      case '16':
        return 'Gauss Kr\u00FCger';
      default:
        return '';  
    }
  }

  var datumNames = {
    '2': 'WGS84'
    // TODO: values for ED50 and NGO (see http://kartverket.no/en/Kart/Nautical-Charts/Nautical-Charts/) 
  };

  function generatePopupMarkup (feature) {
    var a  = feature.attributes;
    var mainMapFeature, i, j;
      var markup = '<article>';
      if (!!a.n) {
        markup += '<h1 class="h">' + feature.fid + " " + a.n + '</h1>';
      }
      if (a.vignett) {
        var mainMapNumber = a.vignett.slice(0, 3);
        for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
          if (feature.layer.features[i].attributes.nr === mainMapNumber) {
            mainMapFeature = feature.layer.features[i];
          }
        }
        if (mainMapFeature) {
          if (mainMapFeature.attributes.s !== a.s) {
            markup += OpenLayers.Lang.translate('Special in map');
          } else {
            markup += OpenLayers.Lang.translate('Vignette in map');
          }
           markup += ' ' + mainMapFeature.attributes.nr + ' ' + mainMapFeature.attributes.n;
        }
      }
      if (a.f) {
        markup += '<p>' + OpenLayers.Lang.translate('Current edition') + ': ' + a.f + '</p>';
      }
      if (a.g) {
        markup += '<p>' + OpenLayers.Lang.translate('Latest print') + ': ' + a.g + '</p>';
      }
      if (a.s) {
        markup += '<p>' + OpenLayers.Lang.translate('Scale') + ' ' + a.s + '</p>';
      }
      if (a.p) {
        markup += '<p>' + OpenLayers.Lang.translate('Projection') + ': ' + a.p + '</p>';
      }
      if (a.d) {
        markup += '<p>' + OpenLayers.Lang.translate('Datum') + ': ' + a.d + '</p>';
      }
      markup += '</article>';
      return markup;
  }

  function onFeatureSelect (feature) {
    var i, 
        j, 
        mainMapNumber,
        message,
        vignettes = [],
        specials = [],
        a;

      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };

        if (feature.attributes.vignett) {
            mainMapNumber = feature.attributes.vignett.slice(0, 3);
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              if (feature.layer.features[i].attributes.nr === mainMapNumber) {
                message.mainMapFeature = feature.layer.features[i].attributes;
              }
            }
        } else {
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              a = feature.layer.features[i].attributes;
              if (a.vignett && a.vignett.indexOf(feature.attributes.nr) === 0) {
                // feature[i] is a special or vignette in the selected map
                
                if (feature.attributes.s === a.s) {
                  vignettes.push(a);
                } else {
                  specials.push(a);
                }
              }
            }
            if (specials.length > 0) {
              message.specials = specials;
            }
            if (vignettes.length > 0) {
              message.vignettes = vignettes;
            }
        }

        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {

        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;

        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
      }
  }
  
  function onFeatureUnselect (feature) {
      if (feature.popup === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      M.removePopup(feature.popup);
      feature.popup.destroy();
      feature.popup = null;

  }

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect, 
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);

OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Current edition': 'Gyldig utgave',
  'Latest print': 'Siste trykk md/&aring;r',
  'Datum': 'Datum',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});

}(map, mapProj, proj));

(function (M, MP, P){
  var styleMap,
      layer,
      dataResponseHandler,
      highlightAllById,
      unhighlightAllById,
      selectControl;

    styleMap = new OpenLayers.StyleMap({
    'default': new OpenLayers.Style(
      {
        strokeWidth: 2,
        strokeColor  :"#844",
        fillOpacity: 0.1, 
        strokeOpacity: 1,

        label : "${nr}",
        fontColor: "#a88",
        fontSize: "12px",
        fontFamily: "Courier New, monospace",
        fontWeight: "bold",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 5
      }, 
      {
        rules: [
          new OpenLayers.Rule({
            maxScaleDenominator: 2500000,
            symbolizer: {
              label: "${nr}"
            }
          }),
          new OpenLayers.Rule({
            minScaleDenominator: 2500000,
            symbolizer: {
              label: ""
            }
          })       
        ]
      }
    ),
    'temporary': {
      strokeWidth: 6,
      strokeColor  : "#daa",
      fontColor: "#daa",
      fillOpacity: 0.1
    }
  });
  

  


  //dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Havne&shy;kart",
    {
      shortid: "dekning.sjo.hv",
      styleMap: styleMap,
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "sjo"
    }
  );

  dataResponseHandler = function(request) {
    var geojson_format, 
        features,
        feature,
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['4326'] 
    });
    features = geojson_format.read(request.responseText);
    features = features.sort(function (a,b) {
       // sort by area
      return b.geometry.getArea() - a.geometry.getArea();
    });
    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        if (feature.fid.length < 4) {
          feature.attributes.nr = feature.fid;
          feature.attributes.vignett = '';
        } else {
          feature.attributes.nr = '';
          feature.attributes.vignett = feature.fid;
          feature.fid = feature.fid.slice(0, 3);
        }
      }
    }
    layer.addFeatures(features);
  };

  M.addLayer(layer);

  OpenLayers.Request.GET({
    url: "/json/dekning/sjo/havnekart_ny.json",
    callback: dataResponseHandler
  });

  highlightAllById = function(element) {
    // highlight all elements with the same element.feature.fid;
    var ident = layer.getFeaturesByFid (element.feature.fid);
    $.each(ident, function(i, feature) {
      feature.renderIntent = "temporary";
      layer.drawFeature(feature);
    });
  };

  // un-highlight all elements with the same element.feature.fid;
  unhighlightAllById = function(element) {
    var ident = layer.getFeaturesByFid (element.feature.fid);

    $.each(ident, function(i, feature) {
      feature.renderIntent = "default";
      layer.drawFeature(feature);
    });
  };

  var highlightDekningCtrl = new OpenLayers.Control.SelectFeature(layer, {
    hover: true,
    multiple: true,
    highlightOnly: true,
    renderIntent: "temporary",
    eventListeners: {
        beforefeaturehighlighted: highlightAllById,
        featureunhighlighted: unhighlightAllById
    },
    autoActivate: true
  });
  map.addControl(highlightDekningCtrl);
  
  function onPopupClose(evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  }

  function projectionName(projectionNumber) {
    switch (projectionNumber) {
      case '8':
        return 'Mercator';
      case '16':
        return 'Gauss Kr\u00FCger';
      default:
        return '';  
    }
  }

  var datumNames = {
    '2': 'WGS84'
    // TODO: values for ED50 and NGO (see http://kartverket.no/en/Kart/Nautical-Charts/Nautical-Charts/) 
  };

  function generatePopupMarkup (feature) {
    var a  = feature.attributes;
    var mainMapFeature, i, j;
      var markup = '<article>';
      if (!!a.n) {
        markup += '<h1 class="h">' + feature.fid + " " + a.n + '</h1>';
      }
      if (a.vignett) {
        var mainMapNumber = a.vignett.slice(0, 3);
        for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
          if (feature.layer.features[i].attributes.nr === mainMapNumber) {
            mainMapFeature = feature.layer.features[i];
          }
        }
        if (mainMapFeature) {
          if (mainMapFeature.attributes.s !== a.s) {
            markup += OpenLayers.Lang.translate('Special in map');
          } else {
            markup += OpenLayers.Lang.translate('Vignette in map');
          }
           markup += ' ' + mainMapFeature.attributes.nr + ' ' + mainMapFeature.attributes.n;
        }
      }
      if (a.f) {
        markup += '<p>' + OpenLayers.Lang.translate('Current edition') + ': ' + a.f + '</p>';
      }
      if (a.g) {
        markup += '<p>' + OpenLayers.Lang.translate('Latest print') + ': ' + a.g + '</p>';
      }
      if (a.s) {
        markup += '<p>' + OpenLayers.Lang.translate('Scale') + ' ' + a.s + '</p>';
      }
      if (a.p) {
        markup += '<p>' + OpenLayers.Lang.translate('Projection') + ': ' + a.p + '</p>';
      }
      if (a.d) {
        markup += '<p>' + OpenLayers.Lang.translate('Datum') + ': ' + a.d + '</p>';
      }
      markup += '</article>';
      return markup;
  }

  function onFeatureSelect (feature) {
    var i, 
        j, 
        mainMapNumber,
        message,
        vignettes = [],
        specials = [],
        a;

      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };

        if (feature.attributes.vignett) {
            mainMapNumber = feature.attributes.vignett.slice(0, 3);
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              if (feature.layer.features[i].attributes.nr === mainMapNumber) {
                message.mainMapFeature = feature.layer.features[i].attributes;
              }
            }
        } else {
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              a = feature.layer.features[i].attributes;
              if (a.vignett && a.vignett.indexOf(feature.attributes.nr) === 0) {
                // feature[i] is a special or vignette in the selected map
                
                if (feature.attributes.s === a.s) {
                  vignettes.push(a);
                } else {
                  specials.push(a);
                }
              }
            }
            if (specials.length > 0) {
              message.specials = specials;
            }
            if (vignettes.length > 0) {
              message.vignettes = vignettes;
            }
        }

        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {

        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;

        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
      }
  }
  
  function onFeatureUnselect (feature) {
      if (feature.popup === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      M.removePopup(feature.popup);
      feature.popup.destroy();
      feature.popup = null;

  }

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect, 
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);

OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Current edition': 'Gyldig utgave',
  'Latest print': 'Siste trykk md/&aring;r',
  'Datum': 'Datum',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});

}(map, mapProj, proj));

(function (M, MP, P){
  var styleMap,
      layer,
      dataResponseHandler,
      highlightAllById,
      unhighlightAllById,
      selectControl;

    styleMap = new OpenLayers.StyleMap({
    'default': new OpenLayers.Style(
      {
        strokeWidth: 2,
        strokeColor  :"#844",
        fillOpacity: 0.1, 
        strokeOpacity: 1,

        label : "${nr}",
        fontColor: "#a88",
        fontSize: "12px",
        fontFamily: "Courier New, monospace",
        fontWeight: "bold",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 5
      }, 
      {
        rules: [
          new OpenLayers.Rule({
            maxScaleDenominator: 2500000,
            symbolizer: {
              label: "${nr}"
            }
          }),
          new OpenLayers.Rule({
            minScaleDenominator: 2500000,
            symbolizer: {
              label: ""
            }
          })       
        ]
      }
    ),
    'temporary': {
      strokeWidth: 6,
      strokeColor  : "#daa",
      fontColor: "#daa",
      fillOpacity: 0.1
    }
  });
  

  
styleMap.styles['default'].defaultStyle.strokeColor = "#844";
styleMap.styles['default'].defaultStyle.fontColor = "#aa8";
styleMap.styles.temporary.defaultStyle.strokeColor = "#dda";
styleMap.styles.temporary.defaultStyle.fontColor = "#dda";


  //dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Kyst&shy;kart",
    {
      shortid: "dekning.sjo.ky",
      styleMap: styleMap,
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "sjo"
    }
  );

  dataResponseHandler = function(request) {
    var geojson_format, 
        features,
        feature,
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['4326'] 
    });
    features = geojson_format.read(request.responseText);
    features = features.sort(function (a,b) {
       // sort by area
      return b.geometry.getArea() - a.geometry.getArea();
    });
    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        if (feature.fid.length < 4) {
          feature.attributes.nr = feature.fid;
          feature.attributes.vignett = '';
        } else {
          feature.attributes.nr = '';
          feature.attributes.vignett = feature.fid;
          feature.fid = feature.fid.slice(0, 3);
        }
      }
    }
    layer.addFeatures(features);
  };

  M.addLayer(layer);

  OpenLayers.Request.GET({
    url: "/json/dekning/sjo/kystkart_ny.json",
    callback: dataResponseHandler
  });

  highlightAllById = function(element) {
    // highlight all elements with the same element.feature.fid;
    var ident = layer.getFeaturesByFid (element.feature.fid);
    $.each(ident, function(i, feature) {
      feature.renderIntent = "temporary";
      layer.drawFeature(feature);
    });
  };

  // un-highlight all elements with the same element.feature.fid;
  unhighlightAllById = function(element) {
    var ident = layer.getFeaturesByFid (element.feature.fid);

    $.each(ident, function(i, feature) {
      feature.renderIntent = "default";
      layer.drawFeature(feature);
    });
  };

  var highlightDekningCtrl = new OpenLayers.Control.SelectFeature(layer, {
    hover: true,
    multiple: true,
    highlightOnly: true,
    renderIntent: "temporary",
    eventListeners: {
        beforefeaturehighlighted: highlightAllById,
        featureunhighlighted: unhighlightAllById
    },
    autoActivate: true
  });
  map.addControl(highlightDekningCtrl);
  
  function onPopupClose(evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  }

  function projectionName(projectionNumber) {
    switch (projectionNumber) {
      case '8':
        return 'Mercator';
      case '16':
        return 'Gauss Kr\u00FCger';
      default:
        return '';  
    }
  }

  var datumNames = {
    '2': 'WGS84'
    // TODO: values for ED50 and NGO (see http://kartverket.no/en/Kart/Nautical-Charts/Nautical-Charts/) 
  };

  function generatePopupMarkup (feature) {
    var a  = feature.attributes;
    var mainMapFeature, i, j;
      var markup = '<article>';
      if (!!a.n) {
        markup += '<h1 class="h">' + feature.fid + " " + a.n + '</h1>';
      }
      if (a.vignett) {
        var mainMapNumber = a.vignett.slice(0, 3);
        for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
          if (feature.layer.features[i].attributes.nr === mainMapNumber) {
            mainMapFeature = feature.layer.features[i];
          }
        }
        if (mainMapFeature) {
          if (mainMapFeature.attributes.s !== a.s) {
            markup += OpenLayers.Lang.translate('Special in map');
          } else {
            markup += OpenLayers.Lang.translate('Vignette in map');
          }
           markup += ' ' + mainMapFeature.attributes.nr + ' ' + mainMapFeature.attributes.n;
        }
      }
      if (a.f) {
        markup += '<p>' + OpenLayers.Lang.translate('Current edition') + ': ' + a.f + '</p>';
      }
      if (a.g) {
        markup += '<p>' + OpenLayers.Lang.translate('Latest print') + ': ' + a.g + '</p>';
      }
      if (a.s) {
        markup += '<p>' + OpenLayers.Lang.translate('Scale') + ' ' + a.s + '</p>';
      }
      if (a.p) {
        markup += '<p>' + OpenLayers.Lang.translate('Projection') + ': ' + a.p + '</p>';
      }
      if (a.d) {
        markup += '<p>' + OpenLayers.Lang.translate('Datum') + ': ' + a.d + '</p>';
      }
      markup += '</article>';
      return markup;
  }

  function onFeatureSelect (feature) {
    var i, 
        j, 
        mainMapNumber,
        message,
        vignettes = [],
        specials = [],
        a;

      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };

        if (feature.attributes.vignett) {
            mainMapNumber = feature.attributes.vignett.slice(0, 3);
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              if (feature.layer.features[i].attributes.nr === mainMapNumber) {
                message.mainMapFeature = feature.layer.features[i].attributes;
              }
            }
        } else {
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              a = feature.layer.features[i].attributes;
              if (a.vignett && a.vignett.indexOf(feature.attributes.nr) === 0) {
                // feature[i] is a special or vignette in the selected map
                
                if (feature.attributes.s === a.s) {
                  vignettes.push(a);
                } else {
                  specials.push(a);
                }
              }
            }
            if (specials.length > 0) {
              message.specials = specials;
            }
            if (vignettes.length > 0) {
              message.vignettes = vignettes;
            }
        }

        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {

        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;

        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
      }
  }
  
  function onFeatureUnselect (feature) {
      if (feature.popup === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      M.removePopup(feature.popup);
      feature.popup.destroy();
      feature.popup = null;

  }

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect, 
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);

OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Current edition': 'Gyldig utgave',
  'Latest print': 'Siste trykk md/&aring;r',
  'Datum': 'Datum',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});

}(map, mapProj, proj));

(function (M, MP, P){
  var styleMap,
      layer,
      dataResponseHandler,
      highlightAllById,
      unhighlightAllById,
      selectControl;

    styleMap = new OpenLayers.StyleMap({
    'default': new OpenLayers.Style(
      {
        strokeWidth: 2,
        strokeColor  :"#844",
        fillOpacity: 0.1, 
        strokeOpacity: 1,

        label : "${nr}",
        fontColor: "#a88",
        fontSize: "12px",
        fontFamily: "Courier New, monospace",
        fontWeight: "bold",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 5
      }, 
      {
        rules: [
          new OpenLayers.Rule({
            maxScaleDenominator: 2500000,
            symbolizer: {
              label: "${nr}"
            }
          }),
          new OpenLayers.Rule({
            minScaleDenominator: 2500000,
            symbolizer: {
              label: ""
            }
          })       
        ]
      }
    ),
    'temporary': {
      strokeWidth: 6,
      strokeColor  : "#daa",
      fontColor: "#daa",
      fillOpacity: 0.1
    }
  });
  

  
styleMap.styles['default'].defaultStyle.strokeColor = "#448";
styleMap.styles['default'].defaultStyle.fontColor = "#88a";
styleMap.styles.temporary.defaultStyle.strokeColor = "#aad";
styleMap.styles.temporary.defaultStyle.fontColor = "#aad";


  //dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Overseilingskart",
    {
      shortid: "dekning.sjo.fi",
      styleMap: styleMap,
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "sjo"
    }
  );

  dataResponseHandler = function(request) {
    var geojson_format, 
        features,
        feature,
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['4326'] 
    });
    features = geojson_format.read(request.responseText);
    features = features.sort(function (a,b) {
       // sort by area
      return b.geometry.getArea() - a.geometry.getArea();
    });
    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        if (feature.fid.length < 4) {
          feature.attributes.nr = feature.fid;
          feature.attributes.vignett = '';
        } else {
          feature.attributes.nr = '';
          feature.attributes.vignett = feature.fid;
          feature.fid = feature.fid.slice(0, 3);
        }
      }
    }
    layer.addFeatures(features);
  };

  M.addLayer(layer);

  OpenLayers.Request.GET({
    url: "/json/dekning/sjo/overseilingskart_ny.json",
    callback: dataResponseHandler
  });

  highlightAllById = function(element) {
    // highlight all elements with the same element.feature.fid;
    var ident = layer.getFeaturesByFid (element.feature.fid);
    $.each(ident, function(i, feature) {
      feature.renderIntent = "temporary";
      layer.drawFeature(feature);
    });
  };

  // un-highlight all elements with the same element.feature.fid;
  unhighlightAllById = function(element) {
    var ident = layer.getFeaturesByFid (element.feature.fid);

    $.each(ident, function(i, feature) {
      feature.renderIntent = "default";
      layer.drawFeature(feature);
    });
  };

  var highlightDekningCtrl = new OpenLayers.Control.SelectFeature(layer, {
    hover: true,
    multiple: true,
    highlightOnly: true,
    renderIntent: "temporary",
    eventListeners: {
        beforefeaturehighlighted: highlightAllById,
        featureunhighlighted: unhighlightAllById
    },
    autoActivate: true
  });
  map.addControl(highlightDekningCtrl);
  
  function onPopupClose(evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  }

  function projectionName(projectionNumber) {
    switch (projectionNumber) {
      case '8':
        return 'Mercator';
      case '16':
        return 'Gauss Kr\u00FCger';
      default:
        return '';  
    }
  }

  var datumNames = {
    '2': 'WGS84'
    // TODO: values for ED50 and NGO (see http://kartverket.no/en/Kart/Nautical-Charts/Nautical-Charts/) 
  };

  function generatePopupMarkup (feature) {
    var a  = feature.attributes;
    var mainMapFeature, i, j;
      var markup = '<article>';
      if (!!a.n) {
        markup += '<h1 class="h">' + feature.fid + " " + a.n + '</h1>';
      }
      if (a.vignett) {
        var mainMapNumber = a.vignett.slice(0, 3);
        for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
          if (feature.layer.features[i].attributes.nr === mainMapNumber) {
            mainMapFeature = feature.layer.features[i];
          }
        }
        if (mainMapFeature) {
          if (mainMapFeature.attributes.s !== a.s) {
            markup += OpenLayers.Lang.translate('Special in map');
          } else {
            markup += OpenLayers.Lang.translate('Vignette in map');
          }
           markup += ' ' + mainMapFeature.attributes.nr + ' ' + mainMapFeature.attributes.n;
        }
      }
      if (a.f) {
        markup += '<p>' + OpenLayers.Lang.translate('Current edition') + ': ' + a.f + '</p>';
      }
      if (a.g) {
        markup += '<p>' + OpenLayers.Lang.translate('Latest print') + ': ' + a.g + '</p>';
      }
      if (a.s) {
        markup += '<p>' + OpenLayers.Lang.translate('Scale') + ' ' + a.s + '</p>';
      }
      if (a.p) {
        markup += '<p>' + OpenLayers.Lang.translate('Projection') + ': ' + a.p + '</p>';
      }
      if (a.d) {
        markup += '<p>' + OpenLayers.Lang.translate('Datum') + ': ' + a.d + '</p>';
      }
      markup += '</article>';
      return markup;
  }

  function onFeatureSelect (feature) {
    var i, 
        j, 
        mainMapNumber,
        message,
        vignettes = [],
        specials = [],
        a;

      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };

        if (feature.attributes.vignett) {
            mainMapNumber = feature.attributes.vignett.slice(0, 3);
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              if (feature.layer.features[i].attributes.nr === mainMapNumber) {
                message.mainMapFeature = feature.layer.features[i].attributes;
              }
            }
        } else {
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              a = feature.layer.features[i].attributes;
              if (a.vignett && a.vignett.indexOf(feature.attributes.nr) === 0) {
                // feature[i] is a special or vignette in the selected map
                
                if (feature.attributes.s === a.s) {
                  vignettes.push(a);
                } else {
                  specials.push(a);
                }
              }
            }
            if (specials.length > 0) {
              message.specials = specials;
            }
            if (vignettes.length > 0) {
              message.vignettes = vignettes;
            }
        }

        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {

        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;

        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
      }
  }
  
  function onFeatureUnselect (feature) {
      if (feature.popup === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      M.removePopup(feature.popup);
      feature.popup.destroy();
      feature.popup = null;

  }

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect, 
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);

OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Current edition': 'Gyldig utgave',
  'Latest print': 'Siste trykk md/&aring;r',
  'Datum': 'Datum',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});

}(map, mapProj, proj));


  var removePopups = function () {
    var popup, p;

    for (p in map.popups) {
      if (map.popups.hasOwnProperty(p)) {
        popup = map.popups[p];

        map.removePopup(popup);
      }
    }
  };

  map.events.register('changelayer', map, removePopups);

  // Add controls at the end, to keep focus
  var controlContext = map;
  var container = null;
  var collect = null;

  
NK.functions = NK.functions || {};

/**
 *  used by controls templates to place controls in the correct context
 *
 */
NK.functions.addControlToContext = function (control, context) {
  // utility method to add control to map or panel

  if (context.addControl) {
    // context is a map
    context.addControl(control);
  } else if (context.addControls) {
    // context is a panel
    context.addControls([control]);
  }
};




(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	
options.dragPanOptions = {enableKinetic: false};
NK.functions.addControlToContext(new OpenLayers.Control.Navigation(options), context);
NK.functions.addControlToContext(new OpenLayers.Control.TouchNavigation(options), context);
NK.functions.addControlToContext(new OpenLayers.Control.KeyboardDefaults(options), context);
NK.functions.addControlToContext(new OpenLayers.Control.MousePosition({
	draw: function() {
		return this.div;
	}, 
	redraw: function(evt) {
		if (evt) {
			this.lastXy = evt.xy;
		}
	}
}), context);

}(controlContext, container));
(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "embed-basic-toolbar";



  container.className = className;
  parentContainer.appendChild(container);



	(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "zoom-panel";



  container.className = className;
  parentContainer.appendChild(container);



	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	

NK.functions.addControlToContext(new OpenLayers.Control.ZoomBarWithButtons( options ), context);

}(controlContext, container));
}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "pan-panel";



  container.className = className;
  parentContainer.appendChild(container);



	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	
options.createControlMarkup = function(control) {
	var button, 
		span;

	button = document.createElement('button');

	if (control.text) {
		span = document.createElement('span');
		span.innerHTML = control.text;
		button.appendChild(span);
	}
	return button;
};

NK.functions.addControlToContext(new OpenLayers.Control.PanPanel(options), context);

}(controlContext, container));
}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "collapse-toolbar-panel";



  container.className = className;
  parentContainer.appendChild(container);



	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	
var buttons = {};
buttons.on = document.createElement('button');
buttons.on.innerHTML = "vis verkt&oslash;y";
buttons.on.setAttribute('class', 'collapse-toolbar-toggle on');
buttons.off = document.createElement('button');
buttons.off.innerHTML = "skjul verkt&oslash;y";
buttons.off.setAttribute('class', 'collapse-toolbar-toggle off');

(function () {
	var collapseToolbar,
		showCollapsedToolbar;

	collapseToolbar = function (evt) {
		var element = this;
		while (!OpenLayers.Element.hasClass(element, 'toolbar')) {
			element = element.parentNode;
		}
		OpenLayers.Element.addClass(element, 'collapsed');
		return false;
	};

	showCollapsedToolbar = function (evt) {
		var element = this;
		while (!OpenLayers.Element.hasClass(element, 'toolbar')) {
			element = element.parentNode;
		}
		OpenLayers.Element.removeClass(element, 'collapsed');
		return false;
	};

	buttons.off.addEventListener('click', collapseToolbar, false);
	buttons.on.addEventListener('click', showCollapsedToolbar, false);
}());
container.appendChild(buttons.off);
container.appendChild(buttons.on);

}(controlContext, container));
}(controlContext, container, collect));

}(controlContext, container, collect));



  // initialize URL update state
  if (NK.functions.storeInitialLayerVisibility) {
    NK.functions.storeInitialLayerVisibility();
  }

  var mapPosition = {x: null, y: null};
  if (NK.functions.setMapStateFromURL) {
    mapPosition = NK.functions.setMapStateFromURL();
  }

  // decide which position to use
  if (!(mapPosition.x && mapPosition.y)) {
    map.setCenter(NK.defaultCenter, NK.defaultZoom);

    if (NK.geolocator) {
      NK.geolocator.activate();
    } 
  }

  if (NK.functions.postMessage) {
    (function () {
      var vectorLayers,
          layer,
          feature,
          vectorLayerData = [],
          vectorFeatureData = [],
          i, 
          j,
          k,
          l,
          message;

      vectorLayers = map.getLayersByClass("OpenLayers.Layer.Vector").slice();

      for (i = 0, j = vectorLayers.length; i < j; i += 1) {
        layer = vectorLayers[i];
        vectorLayerData.push({shortid: layer.shortid, name: layer.name, visibility: layer.visibility});

        if (layer.visibility && layer.features && layer.features.length) {

          for (k = 0, l = layer.features.length; k < l; k += 1) {
            feature = layer.features[k];
            vectorFeatureData.push({
              "feature": feature.fid,
              "attributes": feature.attributes
            });
          }

        }
      }

      message = {
        "type": "mapInitialized",
        "vectorLayers": vectorLayerData
      };

      if (vectorFeatureData.length > 0) {
        message.visibleLayerFeatures = vectorFeatureData;
      }

      NK.functions.postMessage(message);
    }());

  }
  map.addControl(new OpenLayers.Control.Attribution());

};
// end init()


var addEvent = function(event, handler) {
  var listen = window.addEventListener || window.attachEvent;
  if (window.addEventListener) {
    listen(event, handler, false);
  } else {
    listen("on" + event, handler);
  }
};

var cb = function(response, status, request) {
  NK.gkToken = request.responseText.replace(/[\"\r\n]/g, '');
};
var startTicket = function(response, status, request) {
  NK.encTicket = request.responseText.replace(/[\"\r\n]/g, '');
  NK.init();
};

var initializeToken = function () {
  $.ajax({
    url: NK.ticketService,
    success: startTicket,
    type: 'GET'
  });
  $.ajax({
    url: NK.tokenService, 
    success: cb,
    type: 'GET'
  });
};
addEvent('load', initializeToken);


"use strict";

var NK = NK || {};
NK.mapEventListeners = {};

var gkopen, 
    gkopen_wmts,
    proj,
    mapProj,
    mapBounds,
    xdmsocket,
    initLayers,
    postEvent,
    map;

gkopen = "http://opencache.statkart.no/gatekeeper/gk/gk.open";
gkopen_wmts = "http://opencache.statkart.no/gatekeeper/gk/gk.open_wmts";

NK.gkToken = "unInitialized";
NK.encTicket = "unInitialized";

NK.tokenService = "http://norgeskart.no/ws/gkt.py";
NK.ticketService = "http://norgeskart.no/ws/esk.py?wms.ecc_enc";
NK.baseProjection = "32633";
NK.baseProjection = "32633";

NK.tokenLastUpdated = new Date(0);
NK.ticketLastUpdated = new Date(0);
NK.tokenUpdatePaused = false;
NK.ticketUpdatePaused = false;

  (function() {
var translations = {};

translations['Server error'] = 'Feil med tjenesten';
translations['An error has occured.'] = 'Ett eller flere kartlag vises ikke som de skal.';
translations['Reloading maps in'] = 'Pr&oslash;ver &aring; laste kartlagene p&aring; nytt om';
translations['minutes.'] = 'minutter.';
translations['minute.'] = 'minutt.';

OpenLayers.Util.extend(OpenLayers.Lang['nb'], translations);
}());


NK.tokenError = {
  PAUSE_MINUTES: 2,
  RELOAD_LIMIT_SECONDS: 15,
  messagePopup: null,
  pauseTimeRemainingElement: null,
  pauseTimeRemainingText: null,
  pauseTimer: null,
  pauseCountdownTimer: null
};
NK.ticketError = {
  PAUSE_MINUTES: 2,
  RELOAD_LIMIT_SECONDS: 15,
  messagePopup: null,
  pauseTimeRemainingElement: null,
  pauseTimeRemainingText: null,
  pauseTimer: null,
  pauseCountdownTimer: null
};



NK.mapservers = {};
NK.mapservers.wmts = [
  "http://gatekeeper1.geonorge.no/BaatGatekeeper/gk/gk.cache_wmts",
  "http://gatekeeper2.geonorge.no/BaatGatekeeper/gk/gk.cache_wmts",
  "http://gatekeeper3.geonorge.no/BaatGatekeeper/gk/gk.cache_wmts"
];
NK.zoomLevels = 18;

NK.functions = NK.functions || {};

NK.functions.resetTokenError = function () {
  if (NK.tokenError.pauseTimeRemainingElement) {
    NK.tokenError.pauseTimeRemainingElement.parentNode.removeChild(NK.tokenError.pauseTimeRemainingElement);
    NK.tokenError.pauseTimeRemainingElement = null;
  }
  if (NK.tokenError.messagePopup) {
    NK.tokenError.messagePopup.parentNode.removeChild(NK.tokenError.messagePopup);
    NK.tokenError.messagePopup = null;
  }
  if (NK.tokenError.pauseTimer) {
    clearTimeout(NK.tokenError.pauseTimer);
    NK.tokenError.pauseTimer = null;
  }
  if (NK.tokenError.pauseCountdownInterval) {
    clearInterval(NK.tokenError.pauseCountdownInterval);
    NK.tokenError.pauseCountdownInterval = null;
  }
};

NK.functions.resetTicketError = function () {
  if (NK.ticketError.pauseTimeRemainingElement) {
    NK.ticketError.pauseTimeRemainingElement.parentNode.removeChild(NK.ticketError.pauseTimeRemainingElement);
    NK.ticketError.pauseTimeRemainingElement = null;
  }
  if (NK.ticketError.messagePopup) {
    NK.ticketError.messagePopup.parentNode.removeChild(NK.ticketError.messagePopup);
    NK.ticketError.messagePopup = null;
  }
  if (NK.ticketError.pauseTimer) {
    clearTimeout(NK.ticketError.pauseTimer);
    NK.ticketError.pauseTimer = null;
  }
  if (NK.ticketError.pauseCountdownInterval) {
    clearInterval(NK.ticketError.pauseCountdownInterval);
    NK.ticketError.pauseCountdownInterval = null;
  }
};

NK.functions.updateToken = function (request) {
  var i, 
      j, 
      reloadLimit;

  reloadLimit = new Date(Date.now() - NK.tokenError.RELOAD_LIMIT_SECONDS * 1000);

  NK.gkToken = request.responseText.replace(/[\"\r\n]/g, '');

  if (NK.tokenLastUpdated < reloadLimit) { // was token updated less than RELOAD_LIMIT_SECONDS ago?
    if (!NK.tokenUpdatePaused) {
      NK.functions.resetTokenError();
      NK.tokenLastUpdated = new Date();

      for (i = 0, j = map.layers.length; i < j; i += 1) {
        if (map.layers[i].params && map.layers[i].params.gkt) {
          map.layers[i].params.gkt = NK.gkToken;
          map.layers[i].redraw();
        }
      }
    }
  } else {
    NK.functions.pauseTokenUpdate();
  }
};
NK.functions.updateTicket = function (request) {
  var i,
    j,
    reloadLimit;

  reloadLimit = new Date(Date.now() - NK.ticketError.RELOAD_LIMIT_SECONDS * 1000);

  NK.encTicket = request.responseText.replace(/[\"\r\n]/g, '');

  if (NK.tokenLastUpdated < reloadLimit) { // was token updated less than RELOAD_LIMIT_SECONDS ago?
    if (!NK.ticketUpdatePaused) {
      NK.functions.resetTicketError();
      NK.ticketLastUpdated = new Date();

      for (i = 0, j = map.layers.length; i < j; i += 1) {
        if (map.layers[i].params && map.layers[i].params.ticket) {
          map.layers[i].params.ticket = NK.encTicket;
          map.layers[i].redraw();
        }
      }
    }
  } else {
    NK.functions.pauseTicketUpdate();
  }
};

NK.functions.pauseTokenUpdate = function () {
  if (!NK.tokenUpdatePaused) {
    NK.tokenUpdatePaused = true;

    NK.functions.log(OpenLayers.Lang.translate('Server error') +" - "+ OpenLayers.Lang.translate('An error has occured.'));

    NK.tokenError.pauseTimer = setTimeout(function () {
      NK.tokenUpdatePaused = false;
      NK.functions.getNewToken();
    },  60 * parseInt(NK.tokenError.PAUSE_MINUTES, 10) * 1000);

    NK.tokenError.pauseCountdownInterval = setInterval(function () {
      var content, timeLeft;
      if (NK.tokenError.pauseTimeRemainingElement) {
        content = NK.tokenError.pauseTimeRemainingElement.innerHTML;
        timeLeft = (parseInt(content, 10) - 1);
        NK.tokenError.pauseTimeRemainingElement.innerHTML = timeLeft.toString();
        if (timeLeft === 1) {
          if (NK.tokenError.pauseTimeRemainingText.textContent) {
            NK.tokenError.pauseTimeRemainingText.textContent = ' ' + OpenLayers.Lang.translate('minute.');
          } else {
            // old IE...
            NK.tokenError.pauseTimeRemainingText.innerText = ' ' + OpenLayers.Lang.translate('minute.');
          }
        }
      }
    }, 60 * 1000);
  }
};
NK.functions.pauseTicketUpdate = function () {
  if (!NK.ticketUpdatePaused) {
    NK.ticketUpdatePaused = true;

    NK.functions.log(OpenLayers.Lang.translate('Server error') +" - "+ OpenLayers.Lang.translate('An error has occured.'));

    NK.ticketError.pauseTimer = setTimeout(function () {
      NK.ticketUpdatePaused = false;
      NK.functions.getNewTicket();
    },  60 * parseInt(NK.ticketError.PAUSE_MINUTES, 10) * 1000);

    NK.ticketError.pauseCountdownInterval = setInterval(function () {
      var content, timeLeft;
      if (NK.ticketError.pauseTimeRemainingElement) {
        content = NK.ticketError.pauseTimeRemainingElement.innerHTML;
        timeLeft = (parseInt(content, 10) - 1);
        NK.ticketError.pauseTimeRemainingElement.innerHTML = timeLeft.toString();
        if (timeLeft === 1) {
          if (NK.ticketError.pauseTimeRemainingText.textContent) {
            NK.ticketError.pauseTimeRemainingText.textContent = ' ' + OpenLayers.Lang.translate('minute.');
          } else {
            // old IE...
            NK.ticketError.pauseTimeRemainingText.innerText = ' ' + OpenLayers.Lang.translate('minute.');
          }
        }
      }
    }, 60 * 1000);
  }
};

NK.functions.getNewToken = function () {
  if (NK.gkToken !== null) {
    NK.gkToken = null;
    OpenLayers.Request.GET({url: NK.tokenService, success: NK.functions.updateToken});
  }
};
NK.functions.getNewTicket = function () {
  if (NK.encTicket !== null) {
    NK.encTicket = null;
    OpenLayers.Request.GET({url: NK.ticketService, success: NK.functions.updateTicket});
  }
};

var closePopupCallBack = function () {
  var itemIndex;
  for (itemIndex = 0; itemIndex < map.popups.length; itemIndex++) {
    map.popups[itemIndex].hide();
  }
  this.hide();
};

  var NK = NK || {};
NK.functions = NK.functions || {};

NK.functions.updateHistory = function (evt) {
  var center,
      zoom,
      i,
      layer,
      uid,
      search,
      searchInput;

  if (!!map) {
    center = map.getCenter();
    zoom   = map.getZoom();

    if (!!center && !!zoom) {
      uid = zoom + "/" + Math.round(center.lon) + "/" + Math.round(center.lat); 
      /* 1m precision ought to be enough for everyone --BG */

      if (!!NK.initLayers && !!map.layers) { 
        for (i in map.layers) {
          if (map.layers.hasOwnProperty(i)) {
            layer = map.layers[i];
            if (!layer.isBaseLayer) {
              if (!layer.isUrlDataLayer) {
                if (layer.visibility) {
                  if ($.inArray(layer.shortid, NK.initLayers) === -1 && typeof layer.shortid !== 'undefined') {
                    uid += "/+" + layer.shortid;
                  }
                } else {
                  if ($.inArray(layer.shortid, NK.initLayers) > -1 && typeof layer.shortid !== 'undefined') {
                    uid += "/-" + layer.shortid;
                  }
                }
              } else {
                if (layer.isDrawing) {
                  uid += '/l/drawing/' + encodeURIComponent(layer.url) + '/' + layer.epsgCode;
                } else {
                  uid += '/l/geojson/' + encodeURIComponent(layer.url) + '/' + layer.epsgCode;
                }
              }
            }
          }
        }
      }
    }
    searchInput = document.getElementById('searchInput');
    if (!!searchInput) {
      search = searchInput.value;
      if (history.replaceState) {
        if (!!search) {
          if (!!history.state) {
            if (history.state.hash != uid) {
              history.replaceState({'search': 'sok=' + search, 'hash': uid}, document.title, '?sok=' + encodeURIComponent(search) + '#' + uid);
            }
          } else {
            history.replaceState({'search': 'sok=' + search, 'hash': uid}, document.title, '?sok=' + encodeURIComponent(search) + '#' + uid);
          }
        } else {
          if (!!history.state) {
            if (history.state.hash != uid) {
              history.replaceState({'hash': uid}, document.title, '#' + uid);
            }
          } else {
            history.replaceState({'hash': uid}, document.title, '#' + uid);
          }
        }
      } else {
        window.location.hash = uid;
      }
    }
    NK.functions.updateScaleLine();
  }
};

NK.mapEventListeners = NK.mapEventListeners || {};
NK.mapEventListeners.moveend = NK.functions.updateHistory;
NK.mapEventListeners.zoomend = NK.functions.updateHistory;
NK.mapEventListeners.changelayer = NK.functions.updateHistory;
NK.mapEventListeners.changebaselayer = NK.functions.updateHistory;

NK.functions.updateScaleLine = function () {
    var layers, scaleLine;
    if (!!self.map){
        layers = self.map.getLayersByName("Sj&oslash;")[0];
        if (!!layers) {
            if(layers.getVisibility()) {
                //NK.functions.addControlToContext(new OpenLayers.Control.ScaleLine({bottomOutUnits:'nm '}));
                scaleLine = map.getControlsByClass('OpenLayers.Control.ScaleLine');
                if (scaleLine.length > 0){
                    scaleLine[0].bottomOutUnits = 'nm';
                    scaleLine[0].bottomInUnits = 'nm';
                    scaleLine[0].eBottom.style.visibility = "visible";
                }
            } else {
                scaleLine = map.getControlsByClass('OpenLayers.Control.ScaleLine');
                if (scaleLine.length > 0){
                    scaleLine[0].bottomOutUnits = '';
                    scaleLine[0].bottomInUnits = '';
                    scaleLine[0].eBottom.style.visibility = "hidden";
                }
            }
        }
    }
}


NK.styles = NK.styles || {};
NK.styles.labeledMarker = new OpenLayers.StyleMap(
	{
		'default': new OpenLayers.Style(
			{
				fillOpacity: 1, 
				label : '${getLabel}',
				fontColor: "#fff",
				fontSize: "12px",
				pointRadius: 0,
				fontFamily: "Arial, Courier New, monospace",
				fontWeight: "bold",
				fillColor: "transparent",
				labelAlign: "cm",
				labelXOffset: 11,
				labelYOffset: 33,
				graphicWidth: 44,
				graphicHeight: 56,
				graphicYOffset: -55,
				graphicXOffset: -11,
				externalGraphic: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAA5CAYAAACiXaIXAAAGqElEQVR4XtWZW2xURRjHv3PbW7vdC21XirBUSwFrsLUJaEKEkmLEhIYYX0pfIDE+aJr4YIwm8mRiYkiQR8XwICo1PpgIxoK9kEJt6qWxEohUpC2u7tJLtt3uLnvuxznhjFtncnJ23a6wX/LPNzObdH7z7zdnd+Ywhw4dgvsZ586dg2KDL2EyphTYrq4uA/5j8CWAOrWxDLoNBrFooyjoEmAZLKIPFDSdDaLPFAPPFwxLA7IEOPk5DZqXToDn4QsA5x2BaSdZnE2RYxjaAVYn2kW5zjsBE2IJcUSfcJwCNqVZGYvB7UJd5wsBJkFJEQsg61ongEkRGxIvpDinaWAalifEmdqxY8djfr//EY7j/IBCUZSFlZWV29evX/9tFaSKMxae0xpnset28LzDxsPAJKhgiW9tbX2yvr6+2+12P6NX1YU0dwh0zgWGAeBVshCSUtDY2DgvSdJQPB4/ixYwZa6HKCkMDHn37cuEL8BljoB1mbmtra29rq6uxxXa0CVG2iAViILGeRGsAToCNnSUrTYrZ+o9K9Pd0Zqr3Q0NDZ/FYrEzN27cuAUAMl0eGBC7be80Xcu0yxjY3dHR8Up1qP418eHdsLJuGxhggRLAeEzhfSCFWtDCtoM/ea2nqWqiJxKJvDMyMnKGhqYXgN2moB2AeQzc2dn5lmfdxqPZLV2gCtWOwLollFBmIBl8HNLeBtjAfnts37594eHh4ZMY0EaU27z9E4N2GU3S66mNHs1uexE0hi8OWM/3c0IIZjYchEbjq1f37NmTRI5/vPop4/QUYQmXgQD+B3rnzp27q4J1vdmmgyUB489lxgMzkWfBHwwfa25ubsQbm3j2MwQXhnYsD1NCOBw+LEY7QBOqSgW2xgDu8kFIBFohGo0eoaFp8GKg+V27du3lwtH9UvDRNQPG43d824Grru1paWnZSnwXMFh0eTi7zIdCoW4x0r62wLiPEOJVLYAehYdtygMcnKbgufXr14cFX81eORBdc2DD6i94NoPH43meKItCnaa1adOmJ1RfPejAlAXYlMIIkBOCAVQizTSwPTRj57bP59uqemvLBoyNuMsFIBAINNlsPoeNSLjOcVxA59zlA7b6MuMGQRDCNqci2mkHcQYwZQU2rM8cgoa2Ox5pmpZklFxZgc02b0igqmqKmL8gaCChRVGc5qSlsgKbYz4tDel0epoAXpVpaMNG+uzs7E+ubAJNoJcNmNNlqNaWAf1cnaLOjkiOThNnOi2RSCQ1MTPuyv5ZFmAz1ykxkMTclzIKc04C2BHaoM90oKZSqb6axZ/LAmzybRZ/hbm5uT5zLmJ++/KwOTlrWGNjYxfYpdkrnvTtNQVGI9Ag3QImu/DFLyjycxbvtEE6jaQsLy/31c6PAaPm1gzYo6WhWbwKqATPWudGtRBw1u5xR5ye1fHx8QF5+c4HDYlBRKGVDMzqMrRnL0NuJXn8Ggo8TyElwuIbTCenkeShoaETzNLs+WiiH1g1V5LDT2cGADLzpy9duvSRdcBVCGDCYefyMEhoDP5HLPapkZyBpjvnwX83VjTwQ/IsPJUZBC2VOD44OPgeAEj47xOlYQrsa5p2W6fdBtmU1+v1i6IIYjIBG+P9sHXhIgRyMUSp2gKzugIREzZ9EZqXLn89F5s+jBz+0AKWHeoZCrn3+Dc8ES6Xq5plWVA1DdKZDAjiTdiciUGT2wspIQIi6wOFcQFj6MAZCni0DITUeZAl8ZvFxcW+iYmJ74n/XqEbkIbGbuOTuQ20IQiC34Q2rFLA8IAk8EuAVgQsw9ybUddvZrPZdy9OTv6w6otDJaTRwPQGpKHt3QYC3OA5rgZDr5YZpvtgygzDUOLx+MvT09Oz9heQNHAx99O02zS4YYrluCCDnDQDZQyNQfGMgIw9gYCn6D1CX/cSDhMl6gBNg9OX3cjl4Gpg3DbD7DP38szU1NRJk528UCdB7WvY3nHilZzz64vO/fsvoNyJgbFW9yVJeuG70dEBh1+QhLM0cIHQzvAI+keU2ingfPvz4aGhI06HC6oESn9RRJcLhkcRJkHRGG5mkMtvWjVrBw1FwTo77aycKKZRqsZ9wvHXBwcG3neCwUaU+40tBnblgSlNIsdPIhgdyhwsFBdhsI9er8eDy6IioE8j4FH4n4LBG8pJzx04YKbdSFcIgCTSFisXHBf6+++r028TwA98eYwinUKCSoHWkHrNXDHQlsOTSPCgQ9dZ+S+kN/BgRThtAWcqCXoE6SwSVAp0NdJLSFBJ0J8g/V5p0KfgAYi/AQ0R+7KQtU9QAAAAAElFTkSuQmCC'
			},
			{
				context: {
					getLabel: function (feature) {
					console.dir(feature);
						return feature.attributes.label || '';
					}
				}
			}
		),
		'select': new OpenLayers.Style(
			{
				fillOpacity: 1
			}
		),
		'temporary': new OpenLayers.Style(
			{
				fillOpacity: 1
			}
		)		
	}
);



NK.functions.storeInitialLayerVisibility = function () {
  // store the initial layer visibility configuration
  var i, 
      layer;

  NK.initLayers = [];

  for (i in map.layers) {
    if (map.layers.hasOwnProperty(i)) {
      layer = map.layers[i];
      if (layer.visibility) {
        if ((!NK.defaultVisibleLayers || !$.inArray(layer.shortid, NK.defaultVisibleLayers)) && !layer.isUrlDataLayer) {
          NK.initLayers.push(layer.shortid);
        }
      }
    }
  }
};

NK.functions.setMapStateFromPopState = function (evt) {
  if (evt && evt.originalEvent && evt.originalEvent.state) {
    NK.functions.setMapState({'search': evt.originalEvent.state.search, 'hash': evt.originalEvent.state.hash});
  }
};

$(window).on('popstate', NK.functions.setMapStateFromPopState);

NK.functions.addLabeledMarker = function (params, number, okToHide) {
  var layers, 
      layer, 
      x, 
      y, 
      label,
      feature,
      popup,
      properties,xy, pWSG84, pUTM;

  layers = map.getLayersBy('shortid', 'pekere');
  if (layers.length > 0) {
    layer = layers[0];
  } else {
    layer = new OpenLayers.Layer.Vector("Mark&oslash;rer", {shortid: 'pekere', styleMap: NK.styles.labeledMarker});
    map.addLayer(layer);
  }

  x = params[0];
  y = params[1];

  if ((y > 0) && (y < 35) && (x > 50) && (x < 90)) {  /* we are dealing with WSG84 coordinates here */
    pWSG84 = new Proj4js.Proj('EPSG:4326');
    pUTM = new Proj4js.Proj('EPSG:' + NK.baseProjection);
    xy = Proj4js.transform(pWSG84, pUTM, new Proj4js.Point(y, x));
    x = xy.x;
    y = xy.y;
  }

properties = {};

  if ((params.length > 2) && (!!params[2])) {
    properties.popupText = decodeURIComponent(params[2]);
  }  
  if (number) {
    properties.nr = number;
  } else {
    properties.nr = '';
  }

  feature = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.Point(x, y), properties);

  popup = new OpenLayers.Popup.FramedSideAnchored(
    "nk-user-marker" + (number ? '-' + number : ''), 
    feature.geometry.getBounds().getCenterLonLat(),
    null,
    '<span class="label-text">' + feature.data.popupText + '</span>',
    null, 
    false, 
    null, //onPopupClose
    {x: 10, y: -65},
    'user-marker'
  );

  popup.autoSize = true;
  popup.panMapIfOutOfView = false;

  if (!okToHide || !!feature.data.popupText) {
    feature.popup = popup;
    map.addPopup(popup);
    popup.show();
  }

  layer.addFeatures([feature]);
  return feature;
};

NK.functions.parseParamsAndAddDataLayerFromUrl = function (params) {
  var type,
      url,
      epsgCode;

  type = params[0];
  url = decodeURIComponent(params[1]);
  epsgCode = params[2];

  switch (type) {
    case 'geojson':
      NK.functions.addGeoJsonLayer(url, epsgCode);
      break;
    case 'drawing':
      NK.functions.addGeoJsonLayer(url, epsgCode, {'isDrawing': true});
      break;
  }

};

NK.functions.addGeoJsonLayer = function (url, epsgCode, extensionProperties) {
  var mapProjection,
      formatOptions,
      geoJSONFormat,
      layerOptions,
      layer,
      correctEpsgCode,
      layerExtensions;

  formatOptions = {
    'internalProjection': map.getProjection(),
    'externalProjection': map.getProjection()
  };

  /* set external projection, if provided  */

  if (epsgCode && NK.projections[epsgCode]) {
    formatOptions.externalProjection = NK.projections[epsgCode];
    correctEpsgCode = epsgCode;
  } else {
    correctEpsgCode = NK.baseProjection;
  }

  geoJSONFormat = new OpenLayers.Format.GeoJSON(formatOptions);

  layerOptions = {
    shortid: 'urlDataLayer_' + NK.functions.urlDataLayerCounter, 
    protocol: new OpenLayers.Protocol.HTTP({
      'url': url,
      'format': geoJSONFormat
    }),
    strategies: [new OpenLayers.Strategy.Fixed({preload: true, autoActivate: true})],
    styleMap: NK.styles.track,
    projection: mapProjection,
    displayInLayerSwitcher: false,
    visibility: true
  };

  layer = new OpenLayers.Layer.Vector(
    'urlDataLayer_' + NK.functions.urlDataLayerCounter++,
    layerOptions
  );

  layerExtensions = {
    'isUrlDataLayer': true,
    'epsgCode': correctEpsgCode,
    'url': url
  };

  if (extensionProperties) {
    layerExtensions = OpenLayers.Util.extend(layerExtensions, extensionProperties); 
  }

  layer = OpenLayers.Util.extend(layer, layerExtensions);

  map.addLayers([layer]);
};

NK.functions.urlDataLayerCounter = 0;
NK.functions.setMapState = function (params) {
  var parms,
      zoom,
      mapx,
      mapy,
      xy,
      index,
      extra,
      setLayerVisibility,
      showLayerNamed,
      hideLayerNamed,
      highlight,
      search,
      searchArray,
      searchInputField,
      i, j, p,
      hash,
      labeledMarkerCount = 0,
      pWSG84,
      pUTM33;

  search = params.search;
  hash = params.hash;

  if (params.search) {
    search = search.replace('?', '');
    searchArray = search.split('&');
    for (i = 0, j = searchArray.length; i < j; i += 1) {
      p = searchArray[i].split('=');
      if (p[0] === 'sok') {
        p[1] = decodeURIComponent(p[1]);
        searchInputField = document.getElementById('searchInput');
        if (searchInputField) {
          searchInputField.value = p[1];
        }
        map.events.triggerEvent('searchForPhrase', {'phrase': p[1]});
      }
    }
  }

  if (!!hash) {
    parms = hash.split("/");
    if (parms.length >= 3) {
      zoom = parms[0];
      mapx = parms[1];
      mapy = parms[2];

      if ((mapy > 0) && (mapy < 35) && (mapx > 50) && (mapx < 90)) {  /* we are dealing with WSG84 coordinates here */
        pWSG84 = new Proj4js.Proj('EPSG:4326');   
        pUTM = new Proj4js.Proj('EPSG:'+NK.baseProjection);   
        xy = Proj4js.transform(pWSG84, pUTM, new Proj4js.Point(mapy, mapx));
        mapx = xy.x;
        mapy = xy.y;
      }
    }

    setLayerVisibility = function (layerName, visibility) {
      var i, 
          j,
          layer,
          layerSwitcherPresent;

      layerSwitcherPresent =  map.getControlsByClass('OpenLayers.Control.RasterOverlayLayerSwitcher').length > 0;

      for (i = 0, j = map.layers.length; i < j; i += 1) {
        layer = map.layers[i];
        if (layer.shortid === layerName) {
          if (layerSwitcherPresent && visibility && layer.displayInLayerSwitcher && !layer.isBaseLayer && (layer.CLASS_NAME === "OpenLayers.Layer.WMTS" || layer.CLASS_NAME === "OpenLayers.Layer.WMS")) {
              map.events.triggerEvent('rasterLayerChangeRequest', {'shortId': layerName});
          } else {
            layer.setVisibility(visibility);
          }
        }
      }         
    };

    showLayerNamed = function (layerName) {
      return setLayerVisibility(layerName, true);
    };
    
    hideLayerNamed = function (layerName) {
      return setLayerVisibility(layerName, false);
    };

    highlight = function (highlightParam) {
      var select, 
          layers,
          layer;

      select = highlightParam.slice(1).split("!");
      layers = map.getBy("layers", "shortid", select[0]);

      if (layers.length === 1) {
        layer = layers[0];

        /* set a new renderer rule to highlight elements with the given name */
        layer.styleMap.styles['default'].addRules([
          new OpenLayers.Rule({
            filter: new OpenLayers.Filter.FeatureId({
              fids: [select[1]]
            }),
            symbolizer: {
              strokeWidth: 3,
              strokeColor : "orange",
              graphicZIndex: 2,
              fillColor : "orange",
              fillOpacity: 0.1
            }
          }),
          new OpenLayers.Rule({
            elseFilter: true,
            symbolizer: {}
          })
        ]);

        layer.styleMap.styles.temporary.addRules([
          new OpenLayers.Rule({
            filter: new OpenLayers.Filter.FeatureId({
              fids: [select[1]]
            }),
            symbolizer: {
              strokeWidth: 3,
              strokeColor: "yellow",
              fillColor  : "orange",
              fillOpacity: 0.2,
              graphicZIndex: 100
            }
          }),
          new OpenLayers.Rule({
            elseFilter: true,
            symbolizer: {}
          })
        ]); 
      }
    };

    for (index = 3; index < parms.length; index += 1) {
      extra = parms[index];
      switch (extra.charAt(0)) {
        case '+':
          showLayerNamed(extra.slice(1));
          break;
        case '-':
          hideLayerNamed(extra.slice(1));
          break;
        case '!':
          highlight(extra);
          break;
        case 'm':
          setTimeout(
            (function (boundParameters, boundCounter){
              return function () {
                console.log('boundCounter: ' + boundCounter);
                NK.functions.addLabeledMarker(boundParameters, boundCounter, true);  
              };
            }(parms.slice(index + 1, index + 4), ++labeledMarkerCount)),
            500
          );
          index += 3;
          break;
        case 'l':
          NK.functions.parseParamsAndAddDataLayerFromUrl(parms.slice(index + 1, index + 4));
          index += 3;
          break;
      }
    }
    if (mapx && mapy && zoom) {
      map.setCenter(new OpenLayers.LonLat(mapx, mapy), zoom);
    }
  }
  var result = {
    'x': mapx,
    'y': mapy,
    'zoom': zoom
  };
  return result;
};

NK.functions.setMapStateFromURL = function () {
  // adjust layer visibility and pan/zoom based on hash, if available

  var hash,
      search;

  search = window.location.search;
  hash = window.location.href.split("#")[1]; // avoids window.location.hash because Firefox automatically decodes URI encoded hashes


  return NK.functions.setMapState({'search': search, 'hash': hash});
};


NK.functions = NK.functions || {};
NK.functions.vector = NK.functions.vector || {};

NK.functions.vector.markAllById = function (layer, intent, preserveIntent) {
  return function(element, evt) {
    if (preserveIntent && element.feature.renderIntent === preserveIntent) {
      return false;
    }
    // highlight all elements with the same element.feature.fid
    var ident = layer.getFeaturesByFid(element.feature.fid);
    $.each(ident, function (i, feature) {

      if (preserveIntent && feature.renderIntent === preserveIntent) {
        return false;
      } else {
        feature.renderIntent = intent;
        layer.drawFeature(feature);
      }
    });
  };
};

NK.functions.vector.addVectorHoverControls = function (map, layer, options) {
  var hoverCtrl,
      selectFeatureProperties;

  selectFeatureProperties = {
      hover: true,
      highlightOnly: true,
      renderIntent: "temporary"
  };

  if (options && options.groupByFid) {
    selectFeatureProperties.eventListeners = {
        beforefeaturehighlighted: NK.functions.vector.markAllById(layer, "temporary", options.preserveIntent),
        featureunhighlighted: NK.functions.vector.markAllById(layer, "default", options.preserveIntent)
    };
  }

  hoverCtrl = new OpenLayers.Control.SelectFeature(
    layer,
    selectFeatureProperties
  );


  map.addControl(hoverCtrl);
  hoverCtrl.activate();
  return hoverCtrl;
};

NK.functions.vector.addVectorControls = function (map, layer, options) {
  var controls = {};

  controls.hover = NK.functions.vector.addVectorHoverControls(map, layer, options);

  return controls;
};






NK.init = function () {

  var prmstr,
      prmarr,
      params,
      tmparr,
      i,
      j;

  if (!OpenLayers || !Proj4js) {
    setTimeout(NK.init, 100);
    return;
  }

  Proj4js.defs["EPSG:4326"] ="+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";
  Proj4js.defs["EPSG:32631"]="+proj=utm +zone=31 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32632"]="+proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32633"]="+proj=utm +zone=33 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32634"]="+proj=utm +zone=34 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32635"]="+proj=utm +zone=35 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:32636"]="+proj=utm +zone=36 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:25831"]="+proj=utm +zone=31 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25832"]="+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25833"]="+proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25834"]="+proj=utm +zone=34 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25835"]="+proj=utm +zone=35 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:25836"]="+proj=utm +zone=36 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
  Proj4js.defs["EPSG:3575"] ="+proj=laea +lat_0=90 +lon_0=10 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
  Proj4js.defs["EPSG:3034"] ="+proj=lcc +lat_1=35 +lat_2=65 +lat_0=52 +lon_0=10 +x_0=4000000 +y_0=2800000 +ellps=GRS80 +units=m +no_defs";

  NK.projections = proj = {  
    //pregenerated projection objects
    "32633": new OpenLayers.Projection('EPSG:32633'),
    "32631": new OpenLayers.Projection('EPSG:32631'),
    "32632": new OpenLayers.Projection('EPSG:32632'),
    "32634": new OpenLayers.Projection('EPSG:32634'),
    "32635": new OpenLayers.Projection('EPSG:32635'),
    "32636": new OpenLayers.Projection('EPSG:32636'),
    "25831": new OpenLayers.Projection('EPSG:25831'),
    "25832": new OpenLayers.Projection('EPSG:25832'),
    "25833": new OpenLayers.Projection('EPSG:25833'),
    "25834": new OpenLayers.Projection('EPSG:25834'),
    "25835": new OpenLayers.Projection('EPSG:25835'),
    "25836": new OpenLayers.Projection('EPSG:25836'),
    "4326" : new OpenLayers.Projection('EPSG:4326'),
    "3034" : new OpenLayers.Projection('EPSG:3034'),
    "3575" : new OpenLayers.Projection('EPSG:3575')
  };

  mapProj = proj[NK.baseProjection];
  mapBounds = new OpenLayers.Bounds(-2500000.0,3500000.0,3045984.0,9045984.0);

  OpenLayers.Util.onImageLoadErrorColor = 'transparent';
  OpenLayers.ImgPath = 'img/';

  OpenLayers.Lang.setCode('nb');

  // extract URL parameters into dictionary
  prmstr = window.location.search.substr(1);
  prmarr = prmstr.split ("&");
  params = {};

  for (i = 0, j = prmarr.length; i < j; i += 1) {
    tmparr = prmarr[i].split("=");
    params[tmparr[0]] = tmparr[1];
  }

  // Create map canvas

  if (!!params.proj) {
    mapProj = proj[params.proj]; 
  }
var options = {
};

  NK.mapOptions = {
    projection: mapProj,
    displayProjection: mapProj,
    maxExtent:  mapBounds,
    units: "m",
    maxResolution: 21664.0,
  //      minResolution: 0.165283203125,
    numZoomLevels: NK.zoomLevels,
  theme: 'theme/norgeskart/style.css'
  };

  map = new OpenLayers.Map( 
    'map', 
    OpenLayers.Util.extend(NK.mapOptions, {
      controls: [], //defined later
      numZoomLevels: NK.zoomLevels,
      eventListeners: NK.mapEventListeners
    })
  );

  // Default placement and zoom of the map
  NK.defaultCenter = new OpenLayers.LonLat(378604,7226208);
NK.defaultZoom = 5;


  // load SLD styles
  
NK = NK || {};
NK.styles = NK.styles || {};
NK.styles.unlabeledMarker = new OpenLayers.StyleMap(
	{
		'default': new OpenLayers.Style(
			{
				fillOpacity: 1, 
				pointRadius: 0,
				fontFamily: "Arial, Courier New, monospace",
				fontWeight: "bold",
				fillColor: "transparent",
				graphicWidth: 44,
				graphicHeight: 56,
				graphicYOffset: -55,
				graphicXOffset: -11,
				zIndex: 0,
				externalGraphic: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAA5CAYAAACiXaIXAAAGqElEQVR4XtWZW2xURRjHv3PbW7vdC21XirBUSwFrsLUJaEKEkmLEhIYYX0pfIDE+aJr4YIwm8mRiYkiQR8XwICo1PpgIxoK9kEJt6qWxEohUpC2u7tJLtt3uLnvuxznhjFtncnJ23a6wX/LPNzObdH7z7zdnd+Ywhw4dgvsZ586dg2KDL2EyphTYrq4uA/5j8CWAOrWxDLoNBrFooyjoEmAZLKIPFDSdDaLPFAPPFwxLA7IEOPk5DZqXToDn4QsA5x2BaSdZnE2RYxjaAVYn2kW5zjsBE2IJcUSfcJwCNqVZGYvB7UJd5wsBJkFJEQsg61ongEkRGxIvpDinaWAalifEmdqxY8djfr//EY7j/IBCUZSFlZWV29evX/9tFaSKMxae0xpnset28LzDxsPAJKhgiW9tbX2yvr6+2+12P6NX1YU0dwh0zgWGAeBVshCSUtDY2DgvSdJQPB4/ixYwZa6HKCkMDHn37cuEL8BljoB1mbmtra29rq6uxxXa0CVG2iAViILGeRGsAToCNnSUrTYrZ+o9K9Pd0Zqr3Q0NDZ/FYrEzN27cuAUAMl0eGBC7be80Xcu0yxjY3dHR8Up1qP418eHdsLJuGxhggRLAeEzhfSCFWtDCtoM/ea2nqWqiJxKJvDMyMnKGhqYXgN2moB2AeQzc2dn5lmfdxqPZLV2gCtWOwLollFBmIBl8HNLeBtjAfnts37594eHh4ZMY0EaU27z9E4N2GU3S66mNHs1uexE0hi8OWM/3c0IIZjYchEbjq1f37NmTRI5/vPop4/QUYQmXgQD+B3rnzp27q4J1vdmmgyUB489lxgMzkWfBHwwfa25ubsQbm3j2MwQXhnYsD1NCOBw+LEY7QBOqSgW2xgDu8kFIBFohGo0eoaFp8GKg+V27du3lwtH9UvDRNQPG43d824Grru1paWnZSnwXMFh0eTi7zIdCoW4x0r62wLiPEOJVLYAehYdtygMcnKbgufXr14cFX81eORBdc2DD6i94NoPH43meKItCnaa1adOmJ1RfPejAlAXYlMIIkBOCAVQizTSwPTRj57bP59uqemvLBoyNuMsFIBAINNlsPoeNSLjOcVxA59zlA7b6MuMGQRDCNqci2mkHcQYwZQU2rM8cgoa2Ox5pmpZklFxZgc02b0igqmqKmL8gaCChRVGc5qSlsgKbYz4tDel0epoAXpVpaMNG+uzs7E+ubAJNoJcNmNNlqNaWAf1cnaLOjkiOThNnOi2RSCQ1MTPuyv5ZFmAz1ykxkMTclzIKc04C2BHaoM90oKZSqb6axZ/LAmzybRZ/hbm5uT5zLmJ++/KwOTlrWGNjYxfYpdkrnvTtNQVGI9Ag3QImu/DFLyjycxbvtEE6jaQsLy/31c6PAaPm1gzYo6WhWbwKqATPWudGtRBw1u5xR5ye1fHx8QF5+c4HDYlBRKGVDMzqMrRnL0NuJXn8Ggo8TyElwuIbTCenkeShoaETzNLs+WiiH1g1V5LDT2cGADLzpy9duvSRdcBVCGDCYefyMEhoDP5HLPapkZyBpjvnwX83VjTwQ/IsPJUZBC2VOD44OPgeAEj47xOlYQrsa5p2W6fdBtmU1+v1i6IIYjIBG+P9sHXhIgRyMUSp2gKzugIREzZ9EZqXLn89F5s+jBz+0AKWHeoZCrn3+Dc8ES6Xq5plWVA1DdKZDAjiTdiciUGT2wspIQIi6wOFcQFj6MAZCni0DITUeZAl8ZvFxcW+iYmJ74n/XqEbkIbGbuOTuQ20IQiC34Q2rFLA8IAk8EuAVgQsw9ybUddvZrPZdy9OTv6w6otDJaTRwPQGpKHt3QYC3OA5rgZDr5YZpvtgygzDUOLx+MvT09Oz9heQNHAx99O02zS4YYrluCCDnDQDZQyNQfGMgIw9gYCn6D1CX/cSDhMl6gBNg9OX3cjl4Gpg3DbD7DP38szU1NRJk528UCdB7WvY3nHilZzz64vO/fsvoNyJgbFW9yVJeuG70dEBh1+QhLM0cIHQzvAI+keU2ingfPvz4aGhI06HC6oESn9RRJcLhkcRJkHRGG5mkMtvWjVrBw1FwTo77aycKKZRqsZ9wvHXBwcG3neCwUaU+40tBnblgSlNIsdPIhgdyhwsFBdhsI9er8eDy6IioE8j4FH4n4LBG8pJzx04YKbdSFcIgCTSFisXHBf6+++r028TwA98eYwinUKCSoHWkHrNXDHQlsOTSPCgQ9dZ+S+kN/BgRThtAWcqCXoE6SwSVAp0NdJLSFBJ0J8g/V5p0KfgAYi/AQ0R+7KQtU9QAAAAAElFTkSuQmCC'
			},
			{}
		),
		'select': new OpenLayers.Style(
			{
				fillOpacity: 1
			},
			{}
		),
		'temporary': new OpenLayers.Style(
			{
				fillOpacity: 1
			},
			{}
		)
	}
);






  // Base layers
  var matrixIds,
    wmts,
    i;

matrixIds = new Array(NK.zoomLevels);

for (i = 0; i <= NK.zoomLevels; ++i) {
  matrixIds[i] = {};
  matrixIds[i].identifier = mapProj + ":" + i;
} 

wmts = new OpenLayers.Layer.WMTS({
  name: "Europa",
  url: NK.mapservers.wmts,
  layer: "egk",
  matrixSet: mapProj,
  matrixIds: matrixIds,
  format: "image/png",
  requestEncoding: "kvp",
  style: "default",
  shortid: "europa", 
  visibility: 0, 
  transitionEffect: 'resize',
  opacity: 1.0,
  params: {
    gkt: NK.gkToken
  }
});

if (wmts.params.GKT) {
  wmts.params.gkt = wmts.params.GKT;
  delete wmts.params.GKT; 
}

wmts.events.register("tileerror", wmts, function(arg) {
  NK.functions.getNewToken();
});

map.events.register('zoomend', wmts, function (evt) {
  this.setVisibility(map.getZoom() <= 6);
});

map.addLayers([wmts]);


  // Overlays
  
NK.addLayerType = NK.addLayerType || {};
NK.addLayerType.WMTS = (function (M, MP) {
  var matrixIds = [],
      i;

  for (i = 0; i <= NK.zoomLevels; ++i) {
    matrixIds[i] = {};
    matrixIds[i].identifier = MP + ":" + i;
  } 

  return function (id, name, url, layer, options) {
    var layer, 
        layerOptions;
    var myMatrixIds = matrixIds;

    if (!!options.customProj) {
      var myMatrixIds = [],
        i;

      for (i = 0; i <= NK.zoomLevels; ++i) {
        myMatrixIds[i] = {};
        if (!!options.shortMatrixIds) {
          myMatrixIds[i].identifier = "" + i;
        } else {
          myMatrixIds[i].identifier = options.customProj + ":" + i;
        }
      } 
    } 

    layerOptions = {
      'name': name,
      'url': url,
      'layer': layer,
      'matrixSet': options.customProj || MP,
      'matrixIds': myMatrixIds,
      'format': "image/png",
      'requestEncoding': "kvp",
      'style': "default",
      'shortid': id, 
      'isBaseLayer': false,
      'linkedTo': options.linkedTo || null,
      'transitionEffect': 'resize',
      'displayOutsideMaxExtent': false,
      'buffer': 1
    };

    if (!!options.attribution) {
      layerOptions['attribution'] = options.attribution;
    }
    if (!!options.extent) {
      var c = options.extent.split(",");
      var customBounds = new OpenLayers.Bounds(c);
      layerOptions['tileFullExtent'] = customBounds;
    }
    if (!!options.tileorigin) {
      var c = options.tileorigin.split(",");
      var origin = new OpenLayers.LonLat(c);
      layerOptions['tileOrigin'] = origin;
    }
    if (!!options.databbox) {
      var c = options.databbox.split(",");
      var customBounds = new OpenLayers.Bounds(c);
      layerOptions['maxExtent'] = customBounds;
      layerOptions['visibility'] = 1;
    }

    layerOptions.displayInLayerSwitcher = !!(options.displayInLayerSwitcher) ? 1 : 0;
    layerOptions.visibility = !!(options.visibility) ? 1 : 0;

    if (!!options.params) {
      layerOptions.params = options.params;
    }

    layer = new OpenLayers.Layer.WMTS(layerOptions);

    if (options.layerGroup) {
      layer = OpenLayers.Util.extend(layer, {
        'layerGroup': options.layerGroup
      });
    }

    if (layer.params.GKT) {
      layer.params.gkt = layer.params.GKT;
      delete layer.params.GKT; 
    }

    if (options.visible) {
      NK.defaultVisibleLayers = NK.defaultVisibleLayers || [];
      NK.defaultVisibleLayers.push(id);
    }

    if (options.linkedTo) {
      layer.events.register("visibilitychanged", layer, function(arg) {
        map.getLayersBy("shortid",options.linkedTo)[0].setVisibility(layer.getVisibility());
      });
    }

    layer.events.register("tileerror", layer, function(arg) {
      NK.functions.getNewToken();
    });

    M.addLayers([layer]);

    return layer;
  };
}(map, mapProj));



(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;

    options.visibility = true;

    options.layerGroup = "land";

    options.params = { 'gkt': NK.gkToken };







    options.attribution = {
      title: "Kartverket",
      href: "http://www.kartverket.no/"
    }

  var layer = NK.addLayerType.WMTS('land', 'Land', url, 'topo2_dybde', options);

}());


(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;


    options.layerGroup = "land";

    options.params = { 'gkt': NK.gkToken };






    options.linkedTo = "fjellskygge"


  var layer = NK.addLayerType.WMTS('toporaster', 'Rasterkart', url, 'toporaster3', options);

}());


(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;


    options.layerGroup = "land";

    options.params = { 'gkt': NK.gkToken };








  var layer = NK.addLayerType.WMTS('enkel', 'enkel', url, 'norges_grunnkart', options);

}());

(function () {
  var wms = new OpenLayers.Layer.WMS(
    "Fly&shy;bilder",
    "http://gatekeeper1.geonorge.no/BaatGatekeeper/gk/gk.nibcache",
    {
      gkt: NK.gkToken,
      layers: "NiB",
      transparent: 0, 
      format: 'image/jpeg'
    },
    {
      shortid: "flybilder", 
      isBaseLayer: false,
      buffer: 0,
      ratio: 1, 
      visibility: 0, 
      singleTile: false,
      transitionEffect: 'resize'
    }
  );

    wms = OpenLayers.Util.extend(wms, { layerGroup: 'land' });



  if (wms.params.GKT) {
    wms.params.gkt = wms.params.GKT;
    delete wms.params.GKT; 
  }


  

  map.addLayers([wms]);
}());


(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;


    options.layerGroup = "land";

    options.params = { 'gkt': NK.gkToken };








  var layer = NK.addLayerType.WMTS('terreng', 'terreng', url, 'terreng_norgeskart', options);

}());


(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;


    options.layerGroup = "sjo";

    options.params = { 'gkt': NK.gkToken };








  var layer = NK.addLayerType.WMTS('sjo', 'Hovedkart', url, 'sjokartraster', options);

}());

(function () {
  var wms = new OpenLayers.Layer.WMS(
    "Elektron. Sj&oslash;kart",
    "http://wms.geonorge.no/skwms1/wms.ecc_enc",
    {
      ticket: NK.encTicket,
      layers: "cells",
      transparent: true, 
      styles: "style-id-263",
      format: 'image/png'
    },
    {
      shortid: "sjo_enc", 
      isBaseLayer: false,
      buffer: 0,
      ratio: 1, 
      visibility: false, 
      singleTile: true,
      minZoom: 10,
      transitionEffect: 'resize'
    }
  );

    wms = OpenLayers.Util.extend(wms, { layerGroup: 'sjo' });



  if (wms.params.GKT) {
    wms.params.gkt = wms.params.GKT;
    delete wms.params.GKT; 
  }

  if (wms.params.TICKET) {
    wms.params.ticket = wms.params.TICKET;
    delete wms.params.TICKET;
  }

  wms.events.register("visibilitychanged", wms, function(arg) {
    map.getLayersBy("shortid","enkel")[0].setVisibility(wms.getVisibility());
  });
  

  map.addLayers([wms]);
}());


(function () {
  var url, 
      options = {};

    url = "http://geodata.npolar.no/arcgis/rest/services/Basisdata/NP_Basiskart_Svalbard_WMTS_25833/MapServer/WMTS?";

    options.displayInLayerSwitcher = true;


    options.layerGroup = "flere";


    options.customProj = "EPSG:25833"

    options.shortMatrixIds = true


    options.databbox = "369976.3899489096,8221306.539890718,878234.7199568129,9010718.76990194"

    options.tileorigin = "-5120900.0,9998100.0"



  var layer = NK.addLayerType.WMTS('svalbard', 'svalbard', url, 'Basisdata_NP_Basiskart_Svalbard_WMTS_25833', options);

}());


(function () {
  var url, 
      options = {};

    url = "http://geodata.npolar.no/arcgis/rest/services/Basisdata/NP_Basiskart_JanMayen_WMTS_25833/MapServer/WMTS?";

    options.displayInLayerSwitcher = true;


    options.layerGroup = "flere";


    options.customProj = "EPSG:25833"

    options.shortMatrixIds = true


    options.databbox = "-393783.2540000008,7978220.98008712,-276963.7430000013,8084965.524000007"

    options.tileorigin = "-5120900.0,9998100.0"



  var layer = NK.addLayerType.WMTS('janmayen', 'janmayen', url, 'Basisdata_NP_Basiskart_JanMayen_WMTS_25833', options);

}());

(function (M, MP, P){
  var styleMap,
      layer,
      dataResponseHandler,
      highlightAllById,
      unhighlightAllById,
      selectControl;

    styleMap = new OpenLayers.StyleMap({
    'default': new OpenLayers.Style(
      {
        strokeWidth: 2,
        strokeColor  :"#844",
        fillOpacity: 0.1, 
        strokeOpacity: 1,

        label : "${nr}",
        fontColor: "#a88",
        fontSize: "12px",
        fontFamily: "Courier New, monospace",
        fontWeight: "bold",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 5
      }, 
      {
        rules: [
          new OpenLayers.Rule({
            maxScaleDenominator: 2500000,
            symbolizer: {
              label: "${nr}"
            }
          }),
          new OpenLayers.Rule({
            minScaleDenominator: 2500000,
            symbolizer: {
              label: ""
            }
          })       
        ]
      }
    ),
    'temporary': {
      strokeWidth: 6,
      strokeColor  : "#daa",
      fontColor: "#daa",
      fillOpacity: 0.1
    }
  });
  

  
	styleMap.styles['default'].defaultStyle.strokeColor = "#484";
	styleMap.styles['default'].defaultStyle.fontColor = "#8a8";
	styleMap.styles.temporary.defaultStyle.strokeColor = "#ada";
	styleMap.styles.temporary.defaultStyle.fontColor = "#ada";


  //dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Hoved&shy;kart sj&oslash;",
    {
      shortid: "dekning.sjo",
      styleMap: styleMap,
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "sjo"
    }
  );

  dataResponseHandler = function(request) {
    var geojson_format, 
        features,
        feature,
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['4326'] 
    });
    features = geojson_format.read(request.responseText);
    features = features.sort(function (a,b) {
       // sort by area
      return b.geometry.getArea() - a.geometry.getArea();
    });
    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        if (feature.fid.length < 4) {
          feature.attributes.nr = feature.fid;
          feature.attributes.vignett = '';
        } else {
          feature.attributes.nr = '';
          feature.attributes.vignett = feature.fid;
          feature.fid = feature.fid.slice(0, 3);
        }
      }
    }
    layer.addFeatures(features);
  };

  M.addLayer(layer);

  OpenLayers.Request.GET({
    url: "/json/dekning/sjo/hovedserie_ny.json",
    callback: dataResponseHandler
  });

  highlightAllById = function(element) {
    // highlight all elements with the same element.feature.fid;
    var ident = layer.getFeaturesByFid (element.feature.fid);
    $.each(ident, function(i, feature) {
      feature.renderIntent = "temporary";
      layer.drawFeature(feature);
    });
  };

  // un-highlight all elements with the same element.feature.fid;
  unhighlightAllById = function(element) {
    var ident = layer.getFeaturesByFid (element.feature.fid);

    $.each(ident, function(i, feature) {
      feature.renderIntent = "default";
      layer.drawFeature(feature);
    });
  };

  var highlightDekningCtrl = new OpenLayers.Control.SelectFeature(layer, {
    hover: true,
    multiple: true,
    highlightOnly: true,
    renderIntent: "temporary",
    eventListeners: {
        beforefeaturehighlighted: highlightAllById,
        featureunhighlighted: unhighlightAllById
    },
    autoActivate: true
  });
  map.addControl(highlightDekningCtrl);
  
  function onPopupClose(evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  }

  function projectionName(projectionNumber) {
    switch (projectionNumber) {
      case '8':
        return 'Mercator';
      case '16':
        return 'Gauss Kr\u00FCger';
      default:
        return '';  
    }
  }

  var datumNames = {
    '2': 'WGS84'
    // TODO: values for ED50 and NGO (see http://kartverket.no/en/Kart/Nautical-Charts/Nautical-Charts/) 
  };

  function generatePopupMarkup (feature) {
    var a  = feature.attributes;
    var mainMapFeature, i, j;
      var markup = '<article>';
      if (!!a.n) {
        markup += '<h1 class="h">' + feature.fid + " " + a.n + '</h1>';
      }
      if (a.vignett) {
        var mainMapNumber = a.vignett.slice(0, 3);
        for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
          if (feature.layer.features[i].attributes.nr === mainMapNumber) {
            mainMapFeature = feature.layer.features[i];
          }
        }
        if (mainMapFeature) {
          if (mainMapFeature.attributes.s !== a.s) {
            markup += OpenLayers.Lang.translate('Special in map');
          } else {
            markup += OpenLayers.Lang.translate('Vignette in map');
          }
           markup += ' ' + mainMapFeature.attributes.nr + ' ' + mainMapFeature.attributes.n;
        }
      }
      if (a.f) {
        markup += '<p>' + OpenLayers.Lang.translate('Current edition') + ': ' + a.f + '</p>';
      }
      if (a.g) {
        markup += '<p>' + OpenLayers.Lang.translate('Latest print') + ': ' + a.g + '</p>';
      }
      if (a.s) {
        markup += '<p>' + OpenLayers.Lang.translate('Scale') + ' ' + a.s + '</p>';
      }
      if (a.p) {
        markup += '<p>' + OpenLayers.Lang.translate('Projection') + ': ' + a.p + '</p>';
      }
      if (a.d) {
        markup += '<p>' + OpenLayers.Lang.translate('Datum') + ': ' + a.d + '</p>';
      }
      markup += '</article>';
      return markup;
  }

  function onFeatureSelect (feature) {
    var i, 
        j, 
        mainMapNumber,
        message,
        vignettes = [],
        specials = [],
        a;

      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };

        if (feature.attributes.vignett) {
            mainMapNumber = feature.attributes.vignett.slice(0, 3);
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              if (feature.layer.features[i].attributes.nr === mainMapNumber) {
                message.mainMapFeature = feature.layer.features[i].attributes;
              }
            }
        } else {
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              a = feature.layer.features[i].attributes;
              if (a.vignett && a.vignett.indexOf(feature.attributes.nr) === 0) {
                // feature[i] is a special or vignette in the selected map
                
                if (feature.attributes.s === a.s) {
                  vignettes.push(a);
                } else {
                  specials.push(a);
                }
              }
            }
            if (specials.length > 0) {
              message.specials = specials;
            }
            if (vignettes.length > 0) {
              message.vignettes = vignettes;
            }
        }

        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {

        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;

        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
      }
  }
  
  function onFeatureUnselect (feature) {
      if (feature.popup === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      M.removePopup(feature.popup);
      feature.popup.destroy();
      feature.popup = null;

  }

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect, 
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);

OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Current edition': 'Gyldig utgave',
  'Latest print': 'Siste trykk md/&aring;r',
  'Datum': 'Datum',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});

}(map, mapProj, proj));



NK.styles = NK.styles || {};
NK.styles.dekning = NK.styles.dekning || {};
NK.styles.dekning.land = new OpenLayers.StyleMap(
	{
	  'default': new OpenLayers.Style(
	    {
	      strokeWidth: 2,
	      strokeColor  : "#484",
	      fillOpacity: 0.1, 
	      label : "${nr}",
	      fontColor: "#8a8",
	      fontSize: "12px",
	      fontFamily: "Courier New, monospace",
	      fontWeight: "bold",
	      labelAlign: "cm",
	      labelOutlineColor: "white",
	      labelOutlineWidth: 5
	    },
	    {
	      rules: [
	        new OpenLayers.Rule({
	          maxScaleDenominator: 5000000,
	          symbolizer: {
	            label: "${nr}"
	          }
	        }),
	        new OpenLayers.Rule({
	          minScaleDenominator: 5000000,
	          symbolizer: {
	            label: ""
	          }
	        }),
	        new OpenLayers.Rule({
	          filter: new OpenLayers.Filter.Comparison({
	            type: OpenLayers.Filter.Comparison.LIKE,
	            property: "u",
	            value: "2013"
	          }),
	          symbolizer: {
	            strokeColor  : "#844",
	            fontColor: "#a88"
	          }
	        })
	      ]
	    }
	  ),
	  'temporary': new OpenLayers.Style(
			{
		      strokeWidth: 3,
		      strokeColor  : "#ada",
		      fontColor: "#ada",
		      fillOpacity: 0.1
			},
			{
				rules: [
			        new OpenLayers.Rule({
			        	symbolizer: {
					        strokeColor  : "#ada",
					        fontColor: "#ada"
				        }
				    }),
			        new OpenLayers.Rule({
						filter: new OpenLayers.Filter.Comparison({
							type: OpenLayers.Filter.Comparison.LIKE,
							property: "u",
							value: "2013"
						}),
						symbolizer: {
							strokeColor  : "#daa",
							fontColor: "#daa"
						}
			    })
				]
			}
	  )
	}
);



(function (M, MP, P) {
  var layer,
      selectControl,
      onPopupClose = null,
      onFeatureUnselect,
      onFeatureSelect,
      generatePopupMarkup,
      requestHandler;

  // dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Norge 1:50000",
    {
      shortid: "dekning.land", 
      styleMap: NK.styles.dekning.land, 
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "toporaster"
    }
  );

  M.addLayer(layer);

  requestHandler = function (request) {
    var geojson_format,
        features,
        feature, 
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['32633'] 
    });

    features = geojson_format.read(request.responseText);

    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        feature.attributes.nr = feature.fid;
      }
    }
    layer.addFeatures(features);
  };

  OpenLayers.Request.GET({
    url: "/json/dekning/land/n50/plast.json",
    callback: requestHandler
  });

  onPopupClose = function (evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  };

  generatePopupMarkup = function (feature) {
    var a  = feature.attributes;
      var markup = '<article>';
      if (a.n && a.n !== 'NULL') {
        markup += '<h1 class="h">' + a.n + '</h1>';
      }
      if (a.nr) {
        markup += '<p>' + OpenLayers.Lang.translate('Map number') + ': ' + a.nr + '</p>';
      }
      if (a.k) {
        markup += '<div class="municipalities">' + OpenLayers.Lang.translate('Municipalities') + ': <span>' + a.k.split(',').join(',</span><span>') + '</span></div>';
      }
      if (a.u) {
        markup += '<p>' + OpenLayers.Lang.translate('Updated') + ': ' + a.u + '</p>';
      }
      if (a.e) {
        markup += '<p>' + OpenLayers.Lang.translate('EAN-number') + ': ' + a.e + '</p>';
      }
      markup += '</article>';
      return markup;
  };

  onFeatureUnselect = function (feature) {
      if (feature === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      if (feature.popup) {
        M.removePopup(feature.popup);
        feature.popup.destroy();
        feature.popup = null;
      }
  };

  onFeatureSelect = function (feature) {
      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        var message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };
        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {
        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;
        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
    }
  };

  NK.functions.vector.addVectorHoverControls(M, layer);

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect,
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);


OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Map number': 'Kartblad',
  'Latest print': 'Siste trykk',
  'Datum': 'Datum',
  'Municipalities': 'Kommuner',
  'EAN-number': 'EAN-nummer',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Updated': 'Sist oppdatert',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});


}(map, mapProj, proj));

(function (M, MP, P){
  var styleMap,
      layer,
      dataResponseHandler,
      highlightAllById,
      unhighlightAllById,
      selectControl;

    styleMap = new OpenLayers.StyleMap({
    'default': new OpenLayers.Style(
      {
        strokeWidth: 2,
        strokeColor  :"#844",
        fillOpacity: 0.1, 
        strokeOpacity: 1,

        label : "${nr}",
        fontColor: "#a88",
        fontSize: "12px",
        fontFamily: "Courier New, monospace",
        fontWeight: "bold",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 5
      }, 
      {
        rules: [
          new OpenLayers.Rule({
            maxScaleDenominator: 2500000,
            symbolizer: {
              label: "${nr}"
            }
          }),
          new OpenLayers.Rule({
            minScaleDenominator: 2500000,
            symbolizer: {
              label: ""
            }
          })       
        ]
      }
    ),
    'temporary': {
      strokeWidth: 6,
      strokeColor  : "#daa",
      fontColor: "#daa",
      fillOpacity: 0.1
    }
  });
  

  


  //dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Havne&shy;kart",
    {
      shortid: "dekning.sjo.hv",
      styleMap: styleMap,
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "sjo"
    }
  );

  dataResponseHandler = function(request) {
    var geojson_format, 
        features,
        feature,
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['4326'] 
    });
    features = geojson_format.read(request.responseText);
    features = features.sort(function (a,b) {
       // sort by area
      return b.geometry.getArea() - a.geometry.getArea();
    });
    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        if (feature.fid.length < 4) {
          feature.attributes.nr = feature.fid;
          feature.attributes.vignett = '';
        } else {
          feature.attributes.nr = '';
          feature.attributes.vignett = feature.fid;
          feature.fid = feature.fid.slice(0, 3);
        }
      }
    }
    layer.addFeatures(features);
  };

  M.addLayer(layer);

  OpenLayers.Request.GET({
    url: "/json/dekning/sjo/havnekart_ny.json",
    callback: dataResponseHandler
  });

  highlightAllById = function(element) {
    // highlight all elements with the same element.feature.fid;
    var ident = layer.getFeaturesByFid (element.feature.fid);
    $.each(ident, function(i, feature) {
      feature.renderIntent = "temporary";
      layer.drawFeature(feature);
    });
  };

  // un-highlight all elements with the same element.feature.fid;
  unhighlightAllById = function(element) {
    var ident = layer.getFeaturesByFid (element.feature.fid);

    $.each(ident, function(i, feature) {
      feature.renderIntent = "default";
      layer.drawFeature(feature);
    });
  };

  var highlightDekningCtrl = new OpenLayers.Control.SelectFeature(layer, {
    hover: true,
    multiple: true,
    highlightOnly: true,
    renderIntent: "temporary",
    eventListeners: {
        beforefeaturehighlighted: highlightAllById,
        featureunhighlighted: unhighlightAllById
    },
    autoActivate: true
  });
  map.addControl(highlightDekningCtrl);
  
  function onPopupClose(evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  }

  function projectionName(projectionNumber) {
    switch (projectionNumber) {
      case '8':
        return 'Mercator';
      case '16':
        return 'Gauss Kr\u00FCger';
      default:
        return '';  
    }
  }

  var datumNames = {
    '2': 'WGS84'
    // TODO: values for ED50 and NGO (see http://kartverket.no/en/Kart/Nautical-Charts/Nautical-Charts/) 
  };

  function generatePopupMarkup (feature) {
    var a  = feature.attributes;
    var mainMapFeature, i, j;
      var markup = '<article>';
      if (!!a.n) {
        markup += '<h1 class="h">' + feature.fid + " " + a.n + '</h1>';
      }
      if (a.vignett) {
        var mainMapNumber = a.vignett.slice(0, 3);
        for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
          if (feature.layer.features[i].attributes.nr === mainMapNumber) {
            mainMapFeature = feature.layer.features[i];
          }
        }
        if (mainMapFeature) {
          if (mainMapFeature.attributes.s !== a.s) {
            markup += OpenLayers.Lang.translate('Special in map');
          } else {
            markup += OpenLayers.Lang.translate('Vignette in map');
          }
           markup += ' ' + mainMapFeature.attributes.nr + ' ' + mainMapFeature.attributes.n;
        }
      }
      if (a.f) {
        markup += '<p>' + OpenLayers.Lang.translate('Current edition') + ': ' + a.f + '</p>';
      }
      if (a.g) {
        markup += '<p>' + OpenLayers.Lang.translate('Latest print') + ': ' + a.g + '</p>';
      }
      if (a.s) {
        markup += '<p>' + OpenLayers.Lang.translate('Scale') + ' ' + a.s + '</p>';
      }
      if (a.p) {
        markup += '<p>' + OpenLayers.Lang.translate('Projection') + ': ' + a.p + '</p>';
      }
      if (a.d) {
        markup += '<p>' + OpenLayers.Lang.translate('Datum') + ': ' + a.d + '</p>';
      }
      markup += '</article>';
      return markup;
  }

  function onFeatureSelect (feature) {
    var i, 
        j, 
        mainMapNumber,
        message,
        vignettes = [],
        specials = [],
        a;

      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };

        if (feature.attributes.vignett) {
            mainMapNumber = feature.attributes.vignett.slice(0, 3);
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              if (feature.layer.features[i].attributes.nr === mainMapNumber) {
                message.mainMapFeature = feature.layer.features[i].attributes;
              }
            }
        } else {
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              a = feature.layer.features[i].attributes;
              if (a.vignett && a.vignett.indexOf(feature.attributes.nr) === 0) {
                // feature[i] is a special or vignette in the selected map
                
                if (feature.attributes.s === a.s) {
                  vignettes.push(a);
                } else {
                  specials.push(a);
                }
              }
            }
            if (specials.length > 0) {
              message.specials = specials;
            }
            if (vignettes.length > 0) {
              message.vignettes = vignettes;
            }
        }

        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {

        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;

        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
      }
  }
  
  function onFeatureUnselect (feature) {
      if (feature.popup === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      M.removePopup(feature.popup);
      feature.popup.destroy();
      feature.popup = null;

  }

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect, 
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);

OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Current edition': 'Gyldig utgave',
  'Latest print': 'Siste trykk md/&aring;r',
  'Datum': 'Datum',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});

}(map, mapProj, proj));

(function (M, MP, P){
  var styleMap,
      layer,
      dataResponseHandler,
      highlightAllById,
      unhighlightAllById,
      selectControl;

    styleMap = new OpenLayers.StyleMap({
    'default': new OpenLayers.Style(
      {
        strokeWidth: 2,
        strokeColor  :"#844",
        fillOpacity: 0.1, 
        strokeOpacity: 1,

        label : "${nr}",
        fontColor: "#a88",
        fontSize: "12px",
        fontFamily: "Courier New, monospace",
        fontWeight: "bold",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 5
      }, 
      {
        rules: [
          new OpenLayers.Rule({
            maxScaleDenominator: 2500000,
            symbolizer: {
              label: "${nr}"
            }
          }),
          new OpenLayers.Rule({
            minScaleDenominator: 2500000,
            symbolizer: {
              label: ""
            }
          })       
        ]
      }
    ),
    'temporary': {
      strokeWidth: 6,
      strokeColor  : "#daa",
      fontColor: "#daa",
      fillOpacity: 0.1
    }
  });
  

  
styleMap.styles['default'].defaultStyle.strokeColor = "#844";
styleMap.styles['default'].defaultStyle.fontColor = "#aa8";
styleMap.styles.temporary.defaultStyle.strokeColor = "#dda";
styleMap.styles.temporary.defaultStyle.fontColor = "#dda";


  //dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Kyst&shy;kart",
    {
      shortid: "dekning.sjo.ky",
      styleMap: styleMap,
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "sjo"
    }
  );

  dataResponseHandler = function(request) {
    var geojson_format, 
        features,
        feature,
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['4326'] 
    });
    features = geojson_format.read(request.responseText);
    features = features.sort(function (a,b) {
       // sort by area
      return b.geometry.getArea() - a.geometry.getArea();
    });
    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        if (feature.fid.length < 4) {
          feature.attributes.nr = feature.fid;
          feature.attributes.vignett = '';
        } else {
          feature.attributes.nr = '';
          feature.attributes.vignett = feature.fid;
          feature.fid = feature.fid.slice(0, 3);
        }
      }
    }
    layer.addFeatures(features);
  };

  M.addLayer(layer);

  OpenLayers.Request.GET({
    url: "/json/dekning/sjo/kystkart_ny.json",
    callback: dataResponseHandler
  });

  highlightAllById = function(element) {
    // highlight all elements with the same element.feature.fid;
    var ident = layer.getFeaturesByFid (element.feature.fid);
    $.each(ident, function(i, feature) {
      feature.renderIntent = "temporary";
      layer.drawFeature(feature);
    });
  };

  // un-highlight all elements with the same element.feature.fid;
  unhighlightAllById = function(element) {
    var ident = layer.getFeaturesByFid (element.feature.fid);

    $.each(ident, function(i, feature) {
      feature.renderIntent = "default";
      layer.drawFeature(feature);
    });
  };

  var highlightDekningCtrl = new OpenLayers.Control.SelectFeature(layer, {
    hover: true,
    multiple: true,
    highlightOnly: true,
    renderIntent: "temporary",
    eventListeners: {
        beforefeaturehighlighted: highlightAllById,
        featureunhighlighted: unhighlightAllById
    },
    autoActivate: true
  });
  map.addControl(highlightDekningCtrl);
  
  function onPopupClose(evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  }

  function projectionName(projectionNumber) {
    switch (projectionNumber) {
      case '8':
        return 'Mercator';
      case '16':
        return 'Gauss Kr\u00FCger';
      default:
        return '';  
    }
  }

  var datumNames = {
    '2': 'WGS84'
    // TODO: values for ED50 and NGO (see http://kartverket.no/en/Kart/Nautical-Charts/Nautical-Charts/) 
  };

  function generatePopupMarkup (feature) {
    var a  = feature.attributes;
    var mainMapFeature, i, j;
      var markup = '<article>';
      if (!!a.n) {
        markup += '<h1 class="h">' + feature.fid + " " + a.n + '</h1>';
      }
      if (a.vignett) {
        var mainMapNumber = a.vignett.slice(0, 3);
        for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
          if (feature.layer.features[i].attributes.nr === mainMapNumber) {
            mainMapFeature = feature.layer.features[i];
          }
        }
        if (mainMapFeature) {
          if (mainMapFeature.attributes.s !== a.s) {
            markup += OpenLayers.Lang.translate('Special in map');
          } else {
            markup += OpenLayers.Lang.translate('Vignette in map');
          }
           markup += ' ' + mainMapFeature.attributes.nr + ' ' + mainMapFeature.attributes.n;
        }
      }
      if (a.f) {
        markup += '<p>' + OpenLayers.Lang.translate('Current edition') + ': ' + a.f + '</p>';
      }
      if (a.g) {
        markup += '<p>' + OpenLayers.Lang.translate('Latest print') + ': ' + a.g + '</p>';
      }
      if (a.s) {
        markup += '<p>' + OpenLayers.Lang.translate('Scale') + ' ' + a.s + '</p>';
      }
      if (a.p) {
        markup += '<p>' + OpenLayers.Lang.translate('Projection') + ': ' + a.p + '</p>';
      }
      if (a.d) {
        markup += '<p>' + OpenLayers.Lang.translate('Datum') + ': ' + a.d + '</p>';
      }
      markup += '</article>';
      return markup;
  }

  function onFeatureSelect (feature) {
    var i, 
        j, 
        mainMapNumber,
        message,
        vignettes = [],
        specials = [],
        a;

      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };

        if (feature.attributes.vignett) {
            mainMapNumber = feature.attributes.vignett.slice(0, 3);
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              if (feature.layer.features[i].attributes.nr === mainMapNumber) {
                message.mainMapFeature = feature.layer.features[i].attributes;
              }
            }
        } else {
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              a = feature.layer.features[i].attributes;
              if (a.vignett && a.vignett.indexOf(feature.attributes.nr) === 0) {
                // feature[i] is a special or vignette in the selected map
                
                if (feature.attributes.s === a.s) {
                  vignettes.push(a);
                } else {
                  specials.push(a);
                }
              }
            }
            if (specials.length > 0) {
              message.specials = specials;
            }
            if (vignettes.length > 0) {
              message.vignettes = vignettes;
            }
        }

        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {

        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;

        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
      }
  }
  
  function onFeatureUnselect (feature) {
      if (feature.popup === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      M.removePopup(feature.popup);
      feature.popup.destroy();
      feature.popup = null;

  }

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect, 
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);

OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Current edition': 'Gyldig utgave',
  'Latest print': 'Siste trykk md/&aring;r',
  'Datum': 'Datum',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});

}(map, mapProj, proj));

(function (M, MP, P){
  var styleMap,
      layer,
      dataResponseHandler,
      highlightAllById,
      unhighlightAllById,
      selectControl;

    styleMap = new OpenLayers.StyleMap({
    'default': new OpenLayers.Style(
      {
        strokeWidth: 2,
        strokeColor  :"#844",
        fillOpacity: 0.1, 
        strokeOpacity: 1,

        label : "${nr}",
        fontColor: "#a88",
        fontSize: "12px",
        fontFamily: "Courier New, monospace",
        fontWeight: "bold",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 5
      }, 
      {
        rules: [
          new OpenLayers.Rule({
            maxScaleDenominator: 2500000,
            symbolizer: {
              label: "${nr}"
            }
          }),
          new OpenLayers.Rule({
            minScaleDenominator: 2500000,
            symbolizer: {
              label: ""
            }
          })       
        ]
      }
    ),
    'temporary': {
      strokeWidth: 6,
      strokeColor  : "#daa",
      fontColor: "#daa",
      fillOpacity: 0.1
    }
  });
  

  
styleMap.styles['default'].defaultStyle.strokeColor = "#448";
styleMap.styles['default'].defaultStyle.fontColor = "#88a";
styleMap.styles.temporary.defaultStyle.strokeColor = "#aad";
styleMap.styles.temporary.defaultStyle.fontColor = "#aad";


  //dekningsoversikt - vector layer
  layer = new OpenLayers.Layer.Vector(
    "Overseilingskart",
    {
      shortid: "dekning.sjo.fi",
      styleMap: styleMap,
      visibility: 0,
      layerGroup: "dekning",
      preferredBackground: "sjo"
    }
  );

  dataResponseHandler = function(request) {
    var geojson_format, 
        features,
        feature,
        key;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['4326'] 
    });
    features = geojson_format.read(request.responseText);
    features = features.sort(function (a,b) {
       // sort by area
      return b.geometry.getArea() - a.geometry.getArea();
    });
    for (key in features) {
      if (features.hasOwnProperty(key)) {
        feature = features[key];
        if (feature.fid.length < 4) {
          feature.attributes.nr = feature.fid;
          feature.attributes.vignett = '';
        } else {
          feature.attributes.nr = '';
          feature.attributes.vignett = feature.fid;
          feature.fid = feature.fid.slice(0, 3);
        }
      }
    }
    layer.addFeatures(features);
  };

  M.addLayer(layer);

  OpenLayers.Request.GET({
    url: "/json/dekning/sjo/overseilingskart_ny.json",
    callback: dataResponseHandler
  });

  highlightAllById = function(element) {
    // highlight all elements with the same element.feature.fid;
    var ident = layer.getFeaturesByFid (element.feature.fid);
    $.each(ident, function(i, feature) {
      feature.renderIntent = "temporary";
      layer.drawFeature(feature);
    });
  };

  // un-highlight all elements with the same element.feature.fid;
  unhighlightAllById = function(element) {
    var ident = layer.getFeaturesByFid (element.feature.fid);

    $.each(ident, function(i, feature) {
      feature.renderIntent = "default";
      layer.drawFeature(feature);
    });
  };

  var highlightDekningCtrl = new OpenLayers.Control.SelectFeature(layer, {
    hover: true,
    multiple: true,
    highlightOnly: true,
    renderIntent: "temporary",
    eventListeners: {
        beforefeaturehighlighted: highlightAllById,
        featureunhighlighted: unhighlightAllById
    },
    autoActivate: true
  });
  map.addControl(highlightDekningCtrl);
  
  function onPopupClose(evt) {
      selectControl.unselect(NK.selectedCoverageMap);
      delete NK.selectedCoverageMap;
  }

  function projectionName(projectionNumber) {
    switch (projectionNumber) {
      case '8':
        return 'Mercator';
      case '16':
        return 'Gauss Kr\u00FCger';
      default:
        return '';  
    }
  }

  var datumNames = {
    '2': 'WGS84'
    // TODO: values for ED50 and NGO (see http://kartverket.no/en/Kart/Nautical-Charts/Nautical-Charts/) 
  };

  function generatePopupMarkup (feature) {
    var a  = feature.attributes;
    var mainMapFeature, i, j;
      var markup = '<article>';
      if (!!a.n) {
        markup += '<h1 class="h">' + feature.fid + " " + a.n + '</h1>';
      }
      if (a.vignett) {
        var mainMapNumber = a.vignett.slice(0, 3);
        for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
          if (feature.layer.features[i].attributes.nr === mainMapNumber) {
            mainMapFeature = feature.layer.features[i];
          }
        }
        if (mainMapFeature) {
          if (mainMapFeature.attributes.s !== a.s) {
            markup += OpenLayers.Lang.translate('Special in map');
          } else {
            markup += OpenLayers.Lang.translate('Vignette in map');
          }
           markup += ' ' + mainMapFeature.attributes.nr + ' ' + mainMapFeature.attributes.n;
        }
      }
      if (a.f) {
        markup += '<p>' + OpenLayers.Lang.translate('Current edition') + ': ' + a.f + '</p>';
      }
      if (a.g) {
        markup += '<p>' + OpenLayers.Lang.translate('Latest print') + ': ' + a.g + '</p>';
      }
      if (a.s) {
        markup += '<p>' + OpenLayers.Lang.translate('Scale') + ' ' + a.s + '</p>';
      }
      if (a.p) {
        markup += '<p>' + OpenLayers.Lang.translate('Projection') + ': ' + a.p + '</p>';
      }
      if (a.d) {
        markup += '<p>' + OpenLayers.Lang.translate('Datum') + ': ' + a.d + '</p>';
      }
      markup += '</article>';
      return markup;
  }

  function onFeatureSelect (feature) {
    var i, 
        j, 
        mainMapNumber,
        message,
        vignettes = [],
        specials = [],
        a;

      if (NK.easyXDM && NK.easyXDM.socket) {
        // there is an active easyXDM socket - send feature data
        message = {
          type: 'featureSelected', 
          feature: feature.attributes,
          layer: feature.layer.shortid
        };

        if (feature.attributes.vignett) {
            mainMapNumber = feature.attributes.vignett.slice(0, 3);
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              if (feature.layer.features[i].attributes.nr === mainMapNumber) {
                message.mainMapFeature = feature.layer.features[i].attributes;
              }
            }
        } else {
            for (i = 0, j = feature.layer.features.length; i < j; i += 1) {
              a = feature.layer.features[i].attributes;
              if (a.vignett && a.vignett.indexOf(feature.attributes.nr) === 0) {
                // feature[i] is a special or vignette in the selected map
                
                if (feature.attributes.s === a.s) {
                  vignettes.push(a);
                } else {
                  specials.push(a);
                }
              }
            }
            if (specials.length > 0) {
              message.specials = specials;
            }
            if (vignettes.length > 0) {
              message.vignettes = vignettes;
            }
        }

        NK.easyXDM.socket.postMessage(JSON.stringify(message));
      } else {

        NK = NK || {};
        if (NK.selectedCoverageMap ) {
            selectControl.unselect(NK.selectedCoverageMap);
        }
        NK.selectedCoverageMap = feature;

        var mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
        M.setCenter(mousePosition);
        var popup = new OpenLayers.Popup.FramedSideAnchored("nk-selected-coverage-map", 
                                 mousePosition,
                                 null,
                                 generatePopupMarkup(feature),
                                 null, true, onPopupClose);
        popup.autoSize = true;
        feature.popup = popup;
        M.addPopup(popup);
      }
  }
  
  function onFeatureUnselect (feature) {
      if (feature.popup === NK.selectedCoverageMap) {
          NK.selectedCoverageMap = null;
      }
      M.removePopup(feature.popup);
      feature.popup.destroy();
      feature.popup = null;

  }

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      select: onFeatureSelect, 
      unselect: onFeatureUnselect,
      click: true,
      autoActivate: true
  });

  M.addControl(selectControl);

OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Current edition': 'Gyldig utgave',
  'Latest print': 'Siste trykk md/&aring;r',
  'Datum': 'Datum',
  'Projection': 'Projeksjon',
  'Scale': 'M&aring;lestokk',
  'Special in map': 'Spesiale i kartblad',
  'Vignette in map': 'Vignett i kartblad'
});

}(map, mapProj, proj));




  
NK.functions = NK.functions || {};
NK.functions.popup = NK.functions.popup || {};

NK.functions.popup.generatePopupMarkup = function (conf) {
  return function (feature) {
    var a = feature.attributes, 
        i,
        l,
        markup = '<article>';

    if (conf.heading && a[conf.heading]) {
      markup += '<h1 class="h">' + a[conf.heading] + '</h1>';
    }
    if (conf.data) {
      for (i = 0, l = conf.data.length; i < l; i += 1) {
        if (conf.data[i].attribute && a[conf.data[i].attribute]) {
          markup += '<p>' + OpenLayers.Lang.translate(conf.data[i].label) + ': ' + a[conf.data[i].attribute] + ' '+ conf.data[i].unit +'</p>';
        }
      }
    }
    markup += '</article>';
    return markup;
  };
};

NK.functions.popup.getFeatureSelector = function (M, markupGeneratorFunction, popupCloseFunction, options) {
  var featureSelector = options.selectControl;
  return function (feature) {
    var popup, 
        message, 
        mousePosition,
        featurePosition,
        popupPosition,
        offset = {},
        sameFidFeatures,
        xOffset,
        yOffset,
        i, j;

    if (feature.cluster) {
      return false;
    }

    if (NK.easyXDM && NK.easyXDM.socket) {
      // there is an active easyXDM socket - send feature data
      message = {
        cmd: 'featureSelected', 
        feature: feature.fid,
        attributes: feature.attributes,
        layer: feature.layer.shortid
      };
      NK.easyXDM.socket.postMessage(JSON.stringify(message));
    }

    if (feature.fid && feature.layer) {

      sameFidFeatures = feature.layer.getFeaturesByFid(feature.fid);
      for (i = 0, j = sameFidFeatures.length; i < j; i += 1) {
        feature.layer.selectedFeatures.push(sameFidFeatures[i]);

        this.highlight.apply(this, [sameFidFeatures[i]]);
      } 
    }

    // find out where to position the popup
    if (options && options.featureCentroidPosition) {
      featurePosition = feature.geometry.getBounds().getCenterLonLat();

      if (featurePosition) {
        xOffset = feature.layer.styleMap.styles[feature.renderIntent].defaultStyle.graphicXOffset || feature.layer.styleMap.styles['default'].defaultStyle.graphicXOffset || 0;
        xOffset += (feature.layer.styleMap.styles[feature.renderIntent].defaultStyle.graphicWidth || feature.layer.styleMap.styles['default'].defaultStyle.graphicWidth) / 2;
        yOffset = feature.layer.styleMap.styles[feature.renderIntent].defaultStyle.graphicYOffset || feature.layer.styleMap.styles['default'].defaultStyle.graphicYOffset || 0;

        if (xOffset || yOffset) {
          offset.x = -5;
          offset.y = -18;
          offset.addX = xOffset;
          offset.addY = yOffset;
        }
      }
    }

    mousePosition = map.getLonLatFromPixel((map.getControlsByClass('OpenLayers.Control.MousePosition')[0]).lastXy);
    popupPosition = featurePosition || mousePosition;

    M.panTo(popupPosition);

    popup = new OpenLayers.Popup.FramedSideAnchored(
      "nk-selected-coverage-map", 
      popupPosition,
      null,
      markupGeneratorFunction(feature),
      null, 
      true, 
      popupCloseFunction,
      offset,
      'selected-feature-popup'
    );

    popup.autoSize = true;
    feature.popup = popup;
    popup.feature = feature;
    M.addPopup(popup);
  
  };
};

NK.functions.popup.addConfiguredPopup = function (M, layer, popupConfig) {

  var generatePopupMarkup,
      onFeatureSelect,
      onFeatureUnselect,
      onPopupClose,
      selectControl;
      
  generatePopupMarkup = NK.functions.popup.generatePopupMarkup(popupConfig);

  onPopupClose = function (evt) {
    if (this.feature) {
      selectControl.unselect(this.feature);
    }
  };

  onFeatureSelect = NK.functions.popup.getFeatureSelector(M, generatePopupMarkup, onPopupClose, popupConfig);

  onFeatureUnselect = function (feature) {
      if (feature.popup) {
        feature.popup.feature = null;
        M.removePopup(feature.popup);
        feature.popup.destroy();
        feature.popup = null;
      }
  };

  selectControl = new OpenLayers.Control.SelectFeature(layer, {
      onUnselect: onFeatureUnselect,
      highlightOnly: true,
      autoActivate: true
  });
  selectControl.onSelect = OpenLayers.Function.bind(onFeatureSelect, selectControl);

  M.addControl(selectControl);

};





NK.addLayerType = NK.addLayerType || {};

NK.addLayerType.geoJSONFile = (function (M, MP, P) {
  return function (id, name, url, options) {
    var layer,
        layerOptions,
        formatOptions,
        geoJSONFormat;

    formatOptions = {
      'internalProjection': MP,
      'externalProjection': MP 
    };

    // set external projection, if provided  
    if (options.epsgCode && P[options.epsgCode]) {
      formatOptions.externalProjection = P[options.epsgCode];
    }

    geoJSONFormat = new OpenLayers.Format.GeoJSON(formatOptions);

    layerOptions = {
      shortid: id, 
      protocol: new OpenLayers.Protocol.HTTP({
        'url': url,
        'format': geoJSONFormat
      }),
      strategies: [new OpenLayers.Strategy.Fixed({preload: true, autoActivate: true})],
      styleMap: NK.styles.omriss,
      projection: MP,
      displayInLayerSwitcher: (options && options.hideFromLayerSwitcher) ? 0 : 1,
      visibility: (options && options.visible) ? 1 : 0
    };
    if (options) {

      if (options.styleName && NK.styles && NK.styles[options.styleName]) {
        layerOptions.styleMap = NK.styles[options.styleName];
      }

      if (options.styleNameSLD && NK.styles && NK.styles.SLD && NK.styles.SLD[options.styleNameSLD]) {
        layerOptions.styleMap = NK.styles.SLD[options.styleName];
      }

      if (options.label) {
        var tempSM = layerOptions.styleMap;
        layerOptions.styleMap = new OpenLayers.StyleMap(
          {
            'default': tempSM.styles['default'].clone(),
            'select': tempSM.styles.select, 
            'temporary': tempSM.styles.temporary,
            'delete': tempSM.styles['delete']
          }
        );
        layerOptions.styleMap.styles['default'].context = {
          'getLabel': function (feature) {
            return feature.attributes[options.label];
          }
        };

        layerOptions.styleMap.styles['default'].defaultStyle.label = '${getLabel}';
      }

      if (options.cluster && NK.strategies.cluster) {
        layerOptions.strategies.push(NK.strategies.cluster);
      }
    }

    layer = new OpenLayers.Layer.Vector(
      name,
      layerOptions
    );

    if (options) {
      if (options.styleNameSLD && NK.styles && NK.styles.SLD && NK.styles.SLD[options.styleNameSLD]) {
        NK.functions.setSLDStyleForLayer(options.styleNameSLD, layer);
      }

      if (options.cluster) {
        NK.styles.addClusteringRule(layer.styleMap);
      }

      if (options && options.layerGroup) {
        layer = OpenLayers.Util.extend(layer, {'layerGroup': options.layerGroup});
      }

      if (options && options.visible) {
        NK.defaultVisibleLayers = NK.defaultVisibleLayers || [];
        NK.defaultVisibleLayers.push(id);
      }

      if (options && options.popupConfig) {
        NK.functions.popup.addConfiguredPopup(M, layer, options.popupConfig);
      }
    }
    
    M.addLayer(layer);
  };
}(map, mapProj, proj));



(function () {
  var options = {};

  options.layerGroup = 'tjenester.fakta';




  options.styleName = 'unlabeledMarker';



  options.epsgCode = '32633';

  options.popupConfig = (function () {
	var result = {
		'heading': 'OFFISIELT NAVN'
	};
	result.data = [];
	result.data.push({'attribute': 'FYLKESNAVN', 'label': 'Fylke', 'unit': ''});

result.data.push({'attribute': 'KOMMUNENAVN', 'label': 'Kommune', 'unit': ''});

result.data.push({'attribute': 'HOYDE [m]', 'label': 'H&oslash;yde', 'unit': 'm'});

	return result;
}());
;

  NK.addLayerType.geoJSONFile('fjelltopper', 'Kommunenes fjelltopper', '/json/tema/kommunefjell/Kommunefjell.geojson', options);
}());

(function () {
  var wms = new OpenLayers.Layer.WMS(
    "Fotruter",
    "http://wms.geonorge.no/skwms1/wms.friluftsruter",
    {
      layers: "Fotrute",
      transparent: true, 
      format: 'image/png'
    },
    {
      shortid: "Fotrute", 
      isBaseLayer: false,
      buffer: 0,
      ratio: 1, 
      visibility: 0, 
      singleTile: true,
      transitionEffect: 'resize'
    }
  );

    wms = OpenLayers.Util.extend(wms, { layerGroup: 'tjenester.friluft' });

    wms["displayInLayerSwitcher"] = false;


  if (wms.params.GKT) {
    wms.params.gkt = wms.params.GKT;
    delete wms.params.GKT; 
  }


  

  map.addLayers([wms]);
}());

(function () {
  var wms = new OpenLayers.Layer.WMS(
    "Sykkelruter",
    "http://wms.geonorge.no/skwms1/wms.friluftsruter",
    {
      layers: "Sykkelrute",
      transparent: true, 
      format: 'image/png'
    },
    {
      shortid: "Sykkelrute", 
      isBaseLayer: false,
      buffer: 0,
      ratio: 1, 
      visibility: 0, 
      singleTile: true,
      transitionEffect: 'resize'
    }
  );

    wms = OpenLayers.Util.extend(wms, { layerGroup: 'tjenester.friluft' });

    wms["displayInLayerSwitcher"] = false;


  if (wms.params.GKT) {
    wms.params.gkt = wms.params.GKT;
    delete wms.params.GKT; 
  }


  

  map.addLayers([wms]);
}());

(function () {
  var wms = new OpenLayers.Layer.WMS(
    "Skil&oslash;yper",
    "http://wms.geonorge.no/skwms1/wms.friluftsruter",
    {
      layers: "Skiloype",
      transparent: true, 
      format: 'image/png'
    },
    {
      shortid: "Skiloype", 
      isBaseLayer: false,
      buffer: 0,
      ratio: 1, 
      visibility: 0, 
      singleTile: true,
      transitionEffect: 'resize'
    }
  );

    wms = OpenLayers.Util.extend(wms, { layerGroup: 'tjenester.friluft' });

    wms["displayInLayerSwitcher"] = false;


  if (wms.params.GKT) {
    wms.params.gkt = wms.params.GKT;
    delete wms.params.GKT; 
  }


  

  map.addLayers([wms]);
}());

(function () {
  var wms = new OpenLayers.Layer.WMS(
    "Annen",
    "http://wms.geonorge.no/skwms1/wms.friluftsruter",
    {
      layers: "AnnenRute",
      transparent: true, 
      format: 'image/png'
    },
    {
      shortid: "FriluftAnnen", 
      isBaseLayer: false,
      buffer: 0,
      ratio: 1, 
      visibility: 0, 
      singleTile: true,
      transitionEffect: 'resize'
    }
  );

    wms = OpenLayers.Util.extend(wms, { layerGroup: 'tjenester.friluft' });

    wms["displayInLayerSwitcher"] = false;


  if (wms.params.GKT) {
    wms.params.gkt = wms.params.GKT;
    delete wms.params.GKT; 
  }


  

  map.addLayers([wms]);
}());

(function () {
  var wms = new OpenLayers.Layer.WMS(
    "Tilrette- legging",
    "http://wms.geonorge.no/skwms1/wms.friluftsruter",
    {
      layers: "Friluftslivtilrettelegging",
      transparent: true, 
      format: 'image/png'
    },
    {
      shortid: "FriluftTilrettelegging", 
      isBaseLayer: false,
      buffer: 0,
      ratio: 1, 
      visibility: 0, 
      singleTile: true,
      transitionEffect: 'resize'
    }
  );

    wms = OpenLayers.Util.extend(wms, { layerGroup: 'tjenester.friluft' });

    wms["displayInLayerSwitcher"] = false;


  if (wms.params.GKT) {
    wms.params.gkt = wms.params.GKT;
    delete wms.params.GKT; 
  }


  

  map.addLayers([wms]);
}());


(function () {
  var url, 
      options = {};

    url = NK.mapservers.wmts;

    options.displayInLayerSwitcher = true;



    options.params = { 'gkt': NK.gkToken };








  var layer = NK.addLayerType.WMTS('fjellskygge', 'Fjellskygge', url, 'fjellskygge', options);

}());


  var removePopups = function () {
    var popup, p;

    for (p in map.popups) {
      if (map.popups.hasOwnProperty(p)) {
        popup = map.popups[p];

        map.removePopup(popup);
      }
    }
  };

  map.events.register('changelayer', map, removePopups);

  // Add controls at the end, to keep focus
  var controlContext = map;
  var container = null;
  var collect = null;

  NK.status = document.createElement("div");
NK.status.setAttribute("class","toolbar");
NK.status.setAttribute("id","status");
NK.status.messages = {};
document.body.appendChild(NK.status);

NK.status.refresh = function() {
  var content = "", msg, height;
  var now = new Date().getTime();
  for (msg in NK.status.messages) { 
    if (now > parseInt(msg) + 20000) {
      delete NK.status.messages[msg];
    }
  }
  for (msg in NK.status.messages) { 
    content += '<div class="statusmsg">'+NK.status.messages[msg]+'</div>';
  }
  NK.status.innerHTML = content;

  if (!!Object.keys(NK.status.messages).length) {
    $("#status").animate({"max-height": "200px"}); 
  } else {
    $("#status").animate({"max-height": "0px"}); 
  }
}

NK.functions.log = function(msg) {
  var now = new Date().getTime();
  NK.status.messages[new Date().getTime()] = msg;
  NK.status.refresh();
  setTimeout(NK.status.refresh, 21000);
  return now;
}
NK.functions.updateLog = function(time, msg) {
  delete NK.status.messages[time];
  NK.functions.log(msg);
}


NK.functions = NK.functions || {};

/**
 *  used by controls templates to place controls in the correct context
 *
 */
NK.functions.addControlToContext = function (control, context) {
  // utility method to add control to map or panel

  if (context.addControl) {
    // context is a map
    context.addControl(control);
  } else if (context.addControls) {
    // context is a panel
    context.addControls([control]);
  }
};




(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	

options.bind = true;
NK.geolocator = new OpenLayers.Control.Geolocate(options); 
NK.functions.addControlToContext(NK.geolocator, context);
}(controlContext, container));


(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	
options.dragPanOptions = {enableKinetic: false};
NK.functions.addControlToContext(new OpenLayers.Control.Navigation(options), context);
NK.functions.addControlToContext(new OpenLayers.Control.TouchNavigation(options), context);
NK.functions.addControlToContext(new OpenLayers.Control.KeyboardDefaults(options), context);
NK.functions.addControlToContext(new OpenLayers.Control.MousePosition({
	draw: function() {
		return this.div;
	}, 
	redraw: function(evt) {
		if (evt) {
			this.lastXy = evt.xy;
		}
	}
}), context);

}(controlContext, container));


(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
		

NK.functions.addControlToContext(new OpenLayers.Control.ScaleLine({bottomOutUnits:''}), context);

}(controlContext, container));




(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "basic-toolbar";



  container.className = className;
  parentContainer.appendChild(container);



	(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "fullscreen-panel";



  container.className = className;
  parentContainer.appendChild(container);



	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	

NK.functions.addControlToContext(new OpenLayers.Control.FullScreen(options), context);
}(controlContext, container));
}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "zoom-panel";



  container.className = className;
  parentContainer.appendChild(container);



	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	

NK.functions.addControlToContext(new OpenLayers.Control.ZoomBarWithButtons( options ), context);

}(controlContext, container));


(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	

NK.functions.addControlToContext(new OpenLayers.Control.ZoomToSelection(options), context);
}(controlContext, container));
}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "layerselector-panel";


      var header = document.createElement("button");
      header.className = "panel-name";
      header.innerHTML = 'Kartvalg';

        header.innerHTML += OpenLayers.Util.hideFromOldIE('<svg width="45" height="45" xmlns="http://www.w3.org/2000/svg"><g><title>Layer 1</title><path id="svg_1" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="m16.768551,38.517307l11.167488,4.42775v-36.803636l-11.167488,-4.427935v36.803631l0,0.000191zm-14.768551,4.911568l12.387096,-4.911568v-36.803627l-12.387096,4.911755v36.803642l0,-0.000202zm28.316563,-37.263813v36.803638l12.417843,-4.923439v-36.803629l-12.417843,4.923722l0,-0.000292l0,0z" fill="none"/></g></svg>');
      var div = document.createElement("div");
      div.setAttribute("id","map_chooser")
      div.setAttribute("class","widget")

      var wrapper = document.createElement("div");
      wrapper.setAttribute("class","wrapper")

      var cnt = document.createElement("div");
      cnt.setAttribute("class","cnt")
      cnt.setAttribute("id","layerswitcher")

      var wrapperHeader = document.createElement("div");
      var h3 = document.createElement("h3");
      var text = document.createTextNode("Velg karttype:");
      h3.appendChild(text);
      wrapperHeader.appendChild(h3);

      wrapper.appendChild(cnt);
      div.appendChild(wrapperHeader);
      div.appendChild(wrapper);

      container.appendChild(div);
      container.appendChild(header);

  container.className = className;
  parentContainer.appendChild(container);

    $('#layerselector-panel').click(this, function(event) {
      $(this).toggleClass('active');
    });


	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	
	options.layerGroup = "land";
	options.title = "Land";
options.popup = true;

var control = new OpenLayers.Control.RasterOverlayLayerSwitcher(options);
NK.functions.addControlToContext(control, context);

if (NK.functions.updateHistory) {
	control.events.register("buttonclick", NK.functions.updateHistory);
}

}(controlContext, container));


(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	
	options.layerGroup = "sjo";
	options.title = "Sj&oslash;";
options.popup = true;

var control = new OpenLayers.Control.RasterOverlayLayerSwitcher(options);
NK.functions.addControlToContext(control, context);

if (NK.functions.updateHistory) {
	control.events.register("buttonclick", NK.functions.updateHistory);
}

}(controlContext, container));


(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	
	options.layerGroup = "flere";
	options.title = "Flere";
options.popup = true;

var control = new OpenLayers.Control.RasterOverlayLayerSwitcher(options);
NK.functions.addControlToContext(control, context);

if (NK.functions.updateHistory) {
	control.events.register("buttonclick", NK.functions.updateHistory);
}

}(controlContext, container));


(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	

options.layerGroup = "dekning";
options.name = "Kart- inndeling";

var control = new OpenLayers.Control.VectorLayerSwitcher(options);
NK.functions.addControlToContext(control, context);

if (NK.functions.updateHistory) {
	control.events.register("buttonclick", NK.functions.updateHistory);
}

}(controlContext, container));
}(controlContext, container, collect));

}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}

  container = document.createElement('nav');
  container.id = "top-toolbar";
  container.className = className + ' navbar-inverse';

  var innerContainer = document.createElement('div');
  innerContainer.className = 'container-fluid';

  var header = document.createElement('div');
  header.className = 'navbar-header';

  header.innerHTML = '<button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#navbar-collapse-1"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button>';
  header.innerHTML += ' <a class="navbar-brand" href="http://kartverket.no" target="_blank"><svg width="45" height="45" xmlns="http://www.w3.org/2000/svg"><g><title>Layer 1</title><path id="svg_1" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="m16.768551,38.517307l11.167488,4.42775v-36.803636l-11.167488,-4.427935v36.803631l0,0.000191zm-14.768551,4.911568l12.387096,-4.911568v-36.803627l-12.387096,4.911755v36.803642l0,-0.000202zm28.316563,-37.263813v36.803638l12.417843,-4.923439v-36.803629l-12.417843,4.923722l0,-0.000292l0,0z" fill="none"/></g></svg>Norgeskart</a>';

  var collectDiv = document.createElement('div');
  collectDiv.className = 'collapse navbar-collapse';
  collectDiv.id = 'navbar-collapse-1';

  collect = document.createElement('ul');
  collect.className = 'nav navbar-nav';

  collectDiv.appendChild(collect);

  innerContainer.appendChild(header);
  innerContainer.appendChild(collectDiv);

  container.appendChild(innerContainer);
  parentContainer.appendChild(container);

	(function (context, containerParam, collect) {

  var html = '<li class="dropdown">';
      html += '<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Se andre karttjenester <span class="caret"></span></a>';
        html += '<ul class="dropdown-menu" role="menu">';
        html += '<li><a href="http://norgeskart.no/" target="_blank">Norgeskart</a></li>';
        html += '<li role="presentation" class="divider"></li>';
        html += '<li><a href="http://norgeskart.no/ssr" target="_blank">Stedsnavn</a></li>';
        html += '<li><a href="http://norgeskart.no/tilgjengelighet" target="_blank">Tilgjengelighet</a></li>';
        html += '<li><a href="http://norgeskart.no/nrl" target="_blank">Luftfartshindre (NRL)</a></li>';
        html += '<li><a href="http://norgeskart.no/fastmerker" target="_blank">Fastmerker</a></li>';
      html += '</ul>';
      html += '</li>';

  collect.innerHTML = html;

}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}

  container = document.createElement("li");
    container.id = "search-panel";


  container.className = className;
  collect.appendChild(container);

	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	
        options.coordinates = "http://norgeskart.no/ws/trans.py";
        options.searchUrl = "https://ws.geonorge.no/SKWS3Index/ssr/sok";
        options.streetAddressesSearchUrl = "http://norgeskart.no/ws/veg.py";
        options.addressSearchUrl = "http://norgeskart.no/ws/adr.py";
        options.propertySearchUrl = "http://norgeskart.no/ws/eie.py";
NK.functions.addControlToContext(new OpenLayers.Control.Search(options), context);

}(controlContext, container));
}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}

  container = document.createElement("li");
    container.id = "del-panel";


  container.className = className;
  collect.appendChild(container);

	(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;
	className = "topnavpanel toolbar";

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
  	className = "topnavpanel";
	}

  container = document.createElement("li");
    container.id = "print-panel";


  container.className = className;
  collect.appendChild(container);

	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	

var control = new OpenLayers.Control.Print(options);
NK.functions.addControlToContext(control, context);

}(controlContext, container));
}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;
	className = "topnavpanel toolbar";

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
  	className = "topnavpanel";
	}

  container = document.createElement("li");
    container.id = "getURL-panel";


  container.className = className;
  collect.appendChild(container);

	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	

NK.functions.addControlToContext(new OpenLayers.Control.GetURL(options), context);

}(controlContext, container));
}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;
	className = "topnavpanel toolbar";

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
  	className = "topnavpanel";
	}

  container = document.createElement("li");
    container.id = "embed-panel";


  container.className = className;
  collect.appendChild(container);

	

(function (context, container) {

	(function() {
var translations = {};

translations['Embed'] = 'Bruk kartutsnitt';
translations['Select type'] = 'Velg type';
translations['Dynamic map based on open services'] = 'Dynamisk kart basert p&aring; &aring;pne tjenester';
translations['Static map'] = 'Statisk kart';
translations['Terms'] = 'Vilk&aring;r for bruk';
translations['You can use the maps freely for any internet based purposes. You are not allowed to combine multiple maps to form a bigger, continous map.'] = 'Du kan fritt bruke kartutsnittene til alle nettbaserte form&aring;l. Kartene m&aring; brukes enkeltvis og ikke settes sammen slik at de danner et st&oslash;rre sammenhengende kart.';
translations['Svalbard terms'] = 'Integrasjon av Svalbard-kart er ikke tillatt uten spesiell avtale med Norsk Polarinstitutt. Se bruksvilk&aring;rene i Norsk Polarinstitutts egen kartportal, TopoSvalbard (toposvalbard.npolar.no) for ytterligere informasjon.';
translations['Content providers: Kartverket, Geovekst, municipalities and Norge digitalt partners.'] = 'Innholdsleverand&oslash;rer: Kartverket, Geovekst, kommuner og Norge digitalt-parter.';
translations['Previous'] = 'Forrige';
translations['Next'] = 'Neste';
translations['Show selected map area'] = 'Vis kartutsnitt';
translations['Choose area'] = 'Velg utsnitt';
translations['Include map tools'] = 'Ta med kartverkt&oslash;y';
translations['Include markers'] = 'Sett inn mark&oslash;r';
translations['Delete marker'] = 'Slett mark&oslash;r';
translations['Comment'] = 'Skriv inn kommentar';
translations['Add'] = 'Legg til';
translations['Skip'] = 'Hopp over';
translations['Click in the map to add markers with descriptions.'] = 'Klikk p&aring; steder i kartet for &aring; sette inn mark&oslash;rer med forklaring. Legg til flere punkter ved &aring; klikke i kartet.';
translations['To ensure a good user experience, we recommend you provide descriptions for your map. As a result, the embedded map will cater to people using assistive technology.'] = 'For &aring; skape en god brukeropplevelse anbefaler vi at det legges inn beskrivelse. Kartutsnittet vil da bli tilrettelagt for brukere med spesielle behov.';
translations['Hold down left mouse button and draw desired embed area on the map. You may later adjust the size of the area with the buttons that appear on the corners of the drawn rectangle.'] = 'Tegn &oslash;nsket utsnitt og st&oslash;rrelse i kartet ved &aring; holde nede venstre museknapp. Du kan justere st&oslash;rrelsen ved &aring; dra i hj&oslash;rnene p&aring; kartutsnittet.';
translations['Map description'] = 'Beskriv kartutsnitt';
translations['Short description:'] = 'Kort beskrivelse:';
translations['I.ex.'] = 'F.eks.';
translations['"Stores in Hordaland"'] = '"Utsalgssteder i Hordaland"';
translations['Why?'] = 'Hvorfor?';
translations['A short description is shown when the mouse cursor is held over the embedded map.'] = 'En kort beskrivelse vises n&aring;r musepekeren holdes over kartet.';
translations['Long description:'] = 'Lang beskrivelse:';
translations['A long description is used when there is an error, or when the user is unable to see the map.'] = 'Lang beskrivelse brukes n&aring;r det skjer en feil s&aring; kartet ikke kan vises, eller n&aring;r brukeren ikke kan se kartet.';
translations['Generate map'] = 'Generere kart';
translations['Generate code'] = 'Generere kode';
translations['Points:'] = 'Punkter:';
translations['Select code and copy'] = 'Merk kode og klipp ut';
translations['step <span>${stepCount}</span> of '] = 'trinn <span>${stepCount}</span> av ';
translations['Quit'] = 'Avslutt';

OpenLayers.Util.extend(OpenLayers.Lang['nb'], translations);
}());


	var options = {};
	if (container) {
		options.div = container;
	}
	OpenLayers.Util.extend(OpenLayers.Lang.nb, {
    'Height': 'H\u00F8yde',
    'Width': 'Bredde'
});
NK.styles = NK.styles || {};
NK.styles.embed = NK.styles.embed || {};
NK.styles.embed.box = new OpenLayers.StyleMap({
	'default': new OpenLayers.Style({
	  strokeWidth: 2,
	  strokeColor  : "#616060",
	  fillOpacity: 0, 
	  label: OpenLayers.Lang.translate('Height') + ": ${height}\n" + OpenLayers.Lang.translate('Width') + ": ${width}",
	  fontColor: "#616060",
	  fontSize: "12px",
	  fontFamily: "Courier New, monospace",
	  fontWeight: "bold",
	  labelAlign: "lt",
	  labelOutlineColor: "white",
	  labelOutlineWidth: 5,
	  labelXOffset: "${getXOffset}",
	  labelYOffset: "${getYOffset}"
	}, 
	{
		context: {
			getXOffset: function (feature) {
				return parseInt(feature.attributes.width, 10) / 2 + 7;
			},
			getYOffset: function (feature) {
				return parseInt(feature.attributes.height, 10) / 2 - 2;
			}
		}
	})
});

NK.styles.embed.mask =  new OpenLayers.Style({
	strokeWidth: 2,
	strokeColor  : "#616060",
	fillOpacity: 0, 
	label: OpenLayers.Lang.translate('Height') + ": ${height}\n" + OpenLayers.Lang.translate('Width') + ": ${width}",
	fontColor: "#616060",
	fontSize: "12px",
	fontFamily: "Courier New, monospace",
	fontWeight: "bold",
	labelAlign: "cm",
	labelOutlineColor: "white",
	labelOutlineWidth: 5
});






NK.functions.addControlToContext(new OpenLayers.Control.Embed(options), context);
}(controlContext, container));
}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;
	className = "topnavpanel toolbar";

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
  	className = "topnavpanel";
	}

  container = document.createElement("li");
    container.id = "help-panel";


  container.className = className;
  collect.appendChild(container);

	

(function (context, container) {

	(function() {
var translations = {};

translations['Keyboard shortcuts'] = 'Tastatursnarveier';
translations['You can navigate using the following keyboard shortcuts'] = 'F&oslash;lgende taster kan brukes til navigasjon';
translations['Press TAB to change selected control. Press ENTER to activate the selected control.'] = 'Flytt deg rundt i kartets navigasjon ved &aring; bruke TAB-tasten. Velg enkeltfunksjon ved hjelp av ENTER-tasten.';
translations['Keyboard shortcut'] = 'Tastekombinasjon';
translations['Function'] = 'Funksjon';

OpenLayers.Util.extend(OpenLayers.Lang['nb'], translations);
}());


	var options = {};
	if (container) {
		options.div = container;
	}
	

  options.faqUrl = "http://norgeskart.no/js/faq.html";

NK.functions.addControlToContext(new OpenLayers.Control.Help(options), context);
}(controlContext, container));
}(controlContext, container, collect));

}(controlContext, container, collect));

}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "secondary-toolbar";

        var header = document.createElement("button");

      header.className = "panel-name";
      var name = document.createElement('span');
      name.innerHTML = "Verkt&oslash;y";

        header.innerHTML = OpenLayers.Util.hideFromOldIE('<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="27px" height="27px" viewBox="0 0 27 27" class="icon tools" preserveAspectRatio="xMidYMid meet"><path d="M7.551,12.259c0.006,0.007,0.012,0.014,0.018,0.021l2.719,2.81l0.949-0.98l-1.024-1.056L9.75,12.574l2.373-2.452l0.313,0.036c0.08,0.009,0.162,0.014,0.243,0.014c0.164,0,0.324-0.021,0.48-0.057L11.412,8.31c-0.035-0.037-0.073-0.069-0.11-0.103c0.539-2,0.048-4.233-1.474-5.806C8.317,0.841,6.176,0.33,4.251,0.867l3.261,3.369L6.656,7.537L3.461,8.421L0.2,5.052c-0.52,1.989-0.025,4.201,1.485,5.762C3.272,12.453,5.554,12.934,7.551,12.259z M17.188,14.275c-0.054,0.242-0.067,0.494-0.041,0.748l0.035,0.324l-0.223,0.229l-1.688,1.743L14.809,17.8l-1.487-1.536l-0.949,0.979l8.609,8.894c0.529,0.549,1.227,0.822,1.922,0.822s1.391-0.273,1.921-0.822c1.062-1.096,1.062-2.873,0-3.97L17.188,14.275z M23.833,25.216l-1.365,0.378l-1.106-1.145l0.365-1.41l1.365-0.379l1.107,1.145L23.833,25.216z M13.332,15.316l1.486,1.535l1.688-1.742c-0.092-0.851,0.177-1.733,0.808-2.385c0.631-0.652,1.486-0.929,2.31-0.834l7.377-7.622L22.867,0L15.49,7.622c0.092,0.85-0.178,1.734-0.809,2.386c-0.631,0.651-1.486,0.928-2.309,0.834l-1.688,1.743l1.487,1.536l-7.29,7.531l-0.267-0.275L3.218,22.54l-2.354,3.84l0.601,0.621l3.717-2.433l1.127-1.445l-0.268-0.275L13.332,15.316z"/></svg>');

      header.appendChild(name);
      container.appendChild(header);
      OpenLayers.Event.observe(header, 'click', OpenLayers.Function.bind(function (evt) {
        if (OpenLayers.Element.hasClass(this,'minified')) {
          OpenLayers.Element.removeClass(this, 'minified');
        } else {
          OpenLayers.Element.addClass(this, 'minified');
          map.getControlsByClass('OpenLayers.Control.Draw')[0].hideControls(true);
          map.getControlsByClass('OpenLayers.Control.OverlayGroupPanel')[0].hideControls(true);
          map.getControlsByClass('OpenLayers.Control.HeightProfile')[0].hideControls(true);
          map.getControlsByClass('OpenLayers.Control.Transformations')[0].hideControls(true);
        }
      }, container));


  container.className = className;
  parentContainer.appendChild(container);



	(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "tools-panel";



  container.className = className;
  parentContainer.appendChild(container);



	

(function (context, container) {

	(function() {
var translations = {};

translations['Drawing'] = 'Tegne og m\u00E5le';
translations['Drawing tool'] = 'Tegne og m\u00E5le';
translations['Draw point'] = 'Tegn punkt';
translations['Draw line'] = 'Tegn linje';
translations['Draw polygon'] = 'Tegn areal';
translations['Draw label'] = 'Legg tekst til elementer i tegningen';
translations['Undo'] = 'Angre';
translations['Upload'] = 'Last opp';
translations['Upload files in GPX format. More to come.'] = 'Last opp filer i formatet GPX.';
translations['Download'] = 'Last ned';
translations['Download drawing in GeoJSON format. More options to come.'] = 'Last ned tegningen i formatet GeoJSON.';
translations['Save'] = 'Lagre';
translations['Longitude'] = 'Lengdegrad';
translations['Latitude'] = 'Breddegrad';
translations['Length'] = 'Lengde';
translations['Circumference'] = 'Omkrets';
translations['Area'] = 'Areal';
translations['Measures'] = 'M&aring;l';
translations['Cancel'] = 'Avbryt';
translations['Add text'] = 'Legg til tekst';
translations['Update'] = 'Oppdat&eacute;r';

OpenLayers.Util.extend(OpenLayers.Lang['nb'], translations);
}());


	var options = {};
	if (container) {
		options.div = container;
	}
	NK.styles = NK.styles || {};
NK.styles.track = NK.styles.track = new OpenLayers.StyleMap({
	'default': new OpenLayers.Style({
	  strokeWidth: 5,
	  strokeColor  : "#0058a3",
	  fillOpacity: 0.4,
	  fillColor: "#0058a3",
	  graphicName: 'circle',
	  pointRadius: 6,
	  fontColor: "#0058a3",
	  fontSize: "16px",
	  fontFamily: "Arial, sans-serif",
	  fontWeight: "normal",
	  labelAlign: "${getLabelAlign}",
	  label: "${getLabel}",
	  labelXOffset: "${getLabelXOffset}",
	  labelYOffset: 0,
	  labelOutlineColor: "white",
	  labelOutlineWidth: 3	  
	},
	{
		context: {
			getLabel: function (feature) {
				return feature.attributes.label || '';
			},
			getLabelXOffset: function (feature) {
				return (feature.geometry.CLASS_NAME === 'OpenLayers.Geometry.Point') ? 10 : 0;
			},
			getLabelAlign: function (feature) {
				return (feature.geometry.CLASS_NAME === 'OpenLayers.Geometry.Point') ? 'lm' : 'cm';
			}

		}
	}),
	'temporary': new OpenLayers.Style({
	  strokeWidth: 5,
	  strokeColor  : "#0058a3",
	  fillOpacity: 0.4,
	  strokeDashstyle: "${getStrokeDashStyle}",
	  fillColor: "#0058a3",
	  pointRadius: 6
	},
	{
		context: {
			getStrokeDashStyle: function (feature) {
				return (feature.geometry.CLASS_NAME === 'OpenLayers.Geometry.Point') ? 'solid' : 'dash';
			}
		}
	}),
	'select': new OpenLayers.Style({
	  strokeWidth: 6,
	  strokeColor  : "#f058a3",
	  fillOpacity: 0.4,
	  fillColor: "#f058a3",
	  pointRadius: 5,
	  cursor: 'text',
	  fontColor: "#0058a3",
	  fontSize: "16px",
	  fontFamily: "Arial, sans-serif",
	  fontWeight: "normal",
	  labelAlign: "${getLabelAlign}",
	  label: "${getLabel}",
	  labelXOffset: "${getLabelXOffset}",
	  labelYOffset: 0,
	  labelOutlineColor: "white",
	  labelOutlineWidth: 3	  
	},
	{
		context: {
			getLabel: function (feature) {
				return feature.attributes.label || '';
			},
			getLabelXOffset: function (feature) {
				return (feature.geometry.CLASS_NAME === 'OpenLayers.Geometry.Point') ? 10 : 0;
			},
			getLabelAlign: function (feature) {
				return (feature.geometry.CLASS_NAME === 'OpenLayers.Geometry.Point') ? 'lm' : 'cm';
			}

		}
	})
});





options.autoActivate = true;
options.activeDrawControl = 'point';

options.JSONDataStorageUrl = '/ws/upload-json.py';

	options.styleName = 'track';
	if (NK.styles && NK.styles[options.styleName]) {
		options.styleMap = NK.styles[options.styleName];
	}

var control = new OpenLayers.Control.Draw(options);
NK.functions.addControlToContext(control, context);

}(controlContext, container));


(function (context, container) {

	(function() {
var translations = {};

translations['Emergency poster'] = 'N\u00F8dplakat';
translations['Make an emergency poster'] = 'Lag en n\u00F8dplakat';
translations['Select a position in the map'] = 'Velg et punkt i kartet';
translations['Legal'] = 'Ansvar';
translations['Location'] = 'Sted';
translations['Preview'] = 'Visning';
translations['Name your marker'] = 'Gi punktet ditt et navn';
translations['E.g. the name of your cabin'] = 'F.eks. navn p&aring; hytta';
translations['Location is'] = 'Stedet er';
translations['Choose a different location nearby'] = 'Velg et annet stedsnavn i n&aelig;rheten';
translations['The Emergency poster is developed in cooperation with the Joint Rescue Coordination Centres and the emergency services. The Norwegian Mapping Authority is responsible for the data layer; meaning names of locations and mapping - as well as the underlying technology.'] = 'N\u00F8dplakaten er utviklet i samarbeid med Hovedredningsentralene og n\u00F8detatene. Kartverket er ansvarlig for datagrunnlaget, dvs. stedsnavn og kart - samt teknologien bak.';
translations['It\'s the user\'s responsibility to ensure that the location displayed on the poster is correct.'] = 'Det er brukerens ansvar &aring; kontrollere at det er korrekt hytte eller sted som vises p&aring; plakaten.';
translations['The Norwegian Mapping Authority is not responsible for possible errors caused by the user, data layer or technology.'] = 'Kartverket tar ikke ansvar for mulige feil som skyldes brukeren, datagrunnlaget eller teknologien.';
translations['New location'] = 'Velg nytt sted';
translations['Accept and prepare print'] = 'Godkjenn og klargj&oslash;r utskrift';
translations['Accept and proceed'] = 'Jeg godtar og g&aring;r videre';
translations['Download PDF'] = 'Lagre PDF';
translations['Open PDF'] = '&Aring;pne PDF';
translations['Doctor'] = 'Lege';
translations['Police'] = 'Politi';
translations['Fire'] = 'Brann';
translations['While speaking to the emergency services, say the following:'] = 'Ved henvendelse til n&oslash;detaten, si f&oslash;lgende:';
translations['My location is'] = 'Stedet er';
translations['My position is'] = 'Min posisjon er';
translations['in'] = 'i';
translations['degrees'] = 'grader';
translations['minutes'] = 'minutter';
translations['seconds'] = 'sekunder';
translations['decimal degrees'] = 'desimalgrader';
translations['decimal minutes'] = 'desimalminutter';
translations['north'] = 'nord';
translations['south'] = 's&oslash;r';
translations['east'] = '&oslash;st';
translations['west'] = 'vest';
translations['N'] = 'N';
translations['S'] = 'S';
translations['E'] = '&Oslash;';
translations['Unknown'] = 'Ukjent';
translations['municipality'] = 'kommune';
translations['No alternative places found nearby (2 km)'] = 'Ingen andre stedsnavn ble funnet i n&aelig;rheten (2 km)';

OpenLayers.Util.extend(OpenLayers.Lang['nb'], translations);
}());


	var options = {};
	if (container) {
		options.div = container;
	}
	
        options.serviceURL = "http://openwps.statkart.no/skwms1/wps.elevation";
        options.ssrwsURL = "https://ws.geonorge.no/SKWS3Index/ssr/sok?";
        options.pdfServiceUrl = "http://ws.geonorge.no/ngnk2/ngnk?";
var control = new OpenLayers.Control.EmergencyPoster(options);
NK.functions.addControlToContext(control, context);

}(controlContext, container));


(function (context, container) {

	(function() {
var translations = {};

translations['Height profile'] = 'H\u00F8ydeprofil';
translations['Make a height profile'] = 'Lage h\u00F8ydeprofil';
translations['Click in the map to draw a line.'] = 'Klikk p&aring; steder i kartet for &aring; tegne opp en linje.';
translations['Double click to finish'] = 'Dobbeltklikk for &aring; avslutte';
translations['Use some other format'] = 'Bruk et annet format';
translations['Show height profile'] = 'Vis h&oslash;ydeprofil';
translations['Popular routes'] = 'Popul&aelig;re h&oslash;ydeprofiler';
translations['Birkebeinerrennet'] = 'Birkebeinerrennet';
translations['Besseggen'] = 'Besseggen';
translations['Norseman'] = 'Norseman';
translations['An error occured.'] = 'Det har skjedd en feil.';
translations['Unable to read track from file.'] = 'Filen inneholder ingen GPX-data.';
translations['Upload GPX file'] = 'Last opp en GPX-fil';
translations['Choose File'] = 'Velg fil';
translations['Enter WKT geometry data'] = 'Lim inn et WKT LINESTRING-uttrykk';
translations['Generating height profile visualization'] = 'Genererer h&oslash;ydeprofil-visualisering';
translations['Your height profile'] = 'Din h&oslash;ydeprofil';
translations['Close'] = 'Lukk';
translations['Open print friendly'] = '&Aring;pne utskriftsvennlig';

OpenLayers.Util.extend(OpenLayers.Lang['nb'], translations);
}());


	var options = {};
	if (container) {
		options.div = container;
	}
	

options.heightProfileServiceUrl = 'http://openwps.statkart.no/skwms1/wps.elevation';

options.gpxStorageUrl = '/ws/upload-gpx.py';

	var trackStyleName = 'track';
	if (NK.styles && NK.styles[trackStyleName]) {
		options.trackStyleMap = NK.styles[trackStyleName];
	}

	options.gpxTracks = options.gpxTracks || [];
options.gpxTracks.push({
	'name': 'Rallarvegen Haugast&oslash;l - Fl&aring;m',
	'url': '/xml/gpx/rallarvegen.gpx'
});

options.gpxTracks = options.gpxTracks || [];
options.gpxTracks.push({
	'name': 'Birkebeinerrittet',
	'url': '/xml/gpx/birkebeinerrittet.gpx'
});

options.gpxTracks = options.gpxTracks || [];
options.gpxTracks.push({
	'name': 'Birkebeinerrennet 2012',
	'url': '/xml/gpx/birkebeinerrennet-2012.gpx'
});


var control = new OpenLayers.Control.HeightProfile(options);
NK.functions.addControlToContext(control, context);
}(controlContext, container));


(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	
	options.url = "/ws/trans.py";

var control = new OpenLayers.Control.Transformations(options);
NK.functions.addControlToContext(control, context);
}(controlContext, container));
}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "services-panel";

        var header = document.createElement("div");

      header.className = "panel-name";
      var name = document.createElement('span');
      name.innerHTML = "Tjenester";


      header.appendChild(name);
      container.appendChild(header);
      OpenLayers.Event.observe(header, 'click', OpenLayers.Function.bind(function (evt) {
        if (OpenLayers.Element.hasClass(this,'minified')) {
          OpenLayers.Element.removeClass(this, 'minified');
        } else {
          OpenLayers.Element.addClass(this, 'minified');
          map.getControlsByClass('OpenLayers.Control.Draw')[0].hideControls(true);
          map.getControlsByClass('OpenLayers.Control.OverlayGroupPanel')[0].hideControls(true);
          map.getControlsByClass('OpenLayers.Control.HeightProfile')[0].hideControls(true);
          map.getControlsByClass('OpenLayers.Control.Transformations')[0].hideControls(true);
        }
      }, container));


  container.className = className;
  parentContainer.appendChild(container);



	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	

	options.group = 'tjenester.friluft';
	options.buttonText = 'Friluft';
options.title = "Friluft";


var control = new OpenLayers.Control.OverlayGroupPanel(options);
NK.functions.addControlToContext(control, context);
}(controlContext, container));


(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	

	options.group = 'tjenester.fakta';
	options.buttonText = 'Fakta';
options.title = "Fakta";


var control = new OpenLayers.Control.OverlayGroupPanel(options);
NK.functions.addControlToContext(control, context);
}(controlContext, container));
}(controlContext, container, collect));

(function (context, containerParam) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}
	
	container = document.createElement("div");

	container.id = "gamlenk-panel";

	var header = document.createElement("span");
	header.className = "externalToolbarLink";
	header.innerHTML = '<a href="http://gammel.norgeskart.no" target="_blank" title="g&aring; til gamle norgeskartet">Gamle Norges- kart</a>';
	container.appendChild(header);


	container.className = className;
	parentContainer.appendChild(container); 

}(controlContext, container));

}(controlContext, container, collect));

(function (context, containerParam, collect) {
	var parentContainer = document.body,
		className = "toolbar",
		container;

	// set parentContainer if divControllerContainer is set
	if (containerParam) {
		parentContainer = containerParam;
		className = "panel";
	}


  container = document.createElement("div");
    container.id = "overview-container-panel";



  container.className = className;
  parentContainer.appendChild(container);



	

(function (context, container) {


	var options = {};
	if (container) {
		options.div = container;
	}
	


NK.styles = NK.styles || {};
NK.styles.omriss = new OpenLayers.StyleMap(
	{
	  'default': new OpenLayers.Style(
	    {
	      strokeWidth: 0,
	      strokeColor: "#606161",
	      strokeOpacity: 0.5,
	      fillOpacity: 1,
	      fillColor: "white"
	    }
	  )
	}
);


OpenLayers.Util.extend(OpenLayers.Lang.nb, {
  'Show big overview map': 'Vis stort oversiktskart',
  'Show small overview map': 'Vis lite oversiktskart'
});

(function (M, MP, P) {
  var layer,
      requestHandler,
      control,
      detailedLayer;

  var norgeExtent = new OpenLayers.Bounds(-76856, 6453900, 1114892, 7939873);

  layer = new OpenLayers.Layer.Vector(
    "omriss",
    {
      shortid: "omriss.norge.500m", 
      styleMap: NK.styles.omriss, 
      visibility: true
    }
  );

  requestHandler = function (request) {
    var geojson_format,
        features;

    geojson_format = new OpenLayers.Format.GeoJSON({
      'internalProjection': MP,
      'externalProjection': P['32633'] 
    });


    features = geojson_format.read(request.responseText);

    layer.addFeatures(features);

    for (i = 0, j = M.layers.length; i < j; i += 1) {
      if (M.layers[i].shortid && M.layers[i].shortid === 'enkel') {
        detailedLayer = M.layers[i].clone();
        break;
      }
    }

  	options.maximized = false;
  	options.maximizeTitle = OpenLayers.Lang.translate('Show big overview map');
  	options.minimizeTitle = OpenLayers.Lang.translate('Show small overview map');
    options.minRatio = 32;
    options.maxRatio = 32;
    options.size = {w: 80, h: 90};
    options.autoPan = true;
    options.minRectSize = 5;

    options.mapOptions = OpenLayers.Util.extend(NK.mapOptions, {
      numZoomLevels: NK.zoomLevels,
      restrictedExtent: norgeExtent,
      controls: [],
      baseLayer: layer
    });

    if (detailedLayer) {
      options.layers = [layer, detailedLayer];
    } else {
      options.layers = [layer];
    }

    control = new OpenLayers.Control.OverviewMapExpandable(options);
  	NK.functions.addControlToContext(control, context);

  };

  OpenLayers.Request.GET({
    url: "/json/norge/500m.geojson",
    callback: requestHandler
  });

}(map, mapProj, proj));


}(controlContext, container));
}(controlContext, container, collect));



  // initialize URL update state
  if (NK.functions.storeInitialLayerVisibility) {
    NK.functions.storeInitialLayerVisibility();
  }

  var mapPosition = {x: null, y: null};
  if (NK.functions.setMapStateFromURL) {
    mapPosition = NK.functions.setMapStateFromURL();
  }

  // decide which position to use
  if (!(mapPosition.x && mapPosition.y)) {
    map.setCenter(NK.defaultCenter, NK.defaultZoom);

    if (NK.geolocator) {
      NK.geolocator.activate();
    } 
  }

  if (NK.functions.postMessage) {
    (function () {
      var vectorLayers,
          layer,
          feature,
          vectorLayerData = [],
          vectorFeatureData = [],
          i, 
          j,
          k,
          l,
          message;

      vectorLayers = map.getLayersByClass("OpenLayers.Layer.Vector").slice();

      for (i = 0, j = vectorLayers.length; i < j; i += 1) {
        layer = vectorLayers[i];
        vectorLayerData.push({shortid: layer.shortid, name: layer.name, visibility: layer.visibility});

        if (layer.visibility && layer.features && layer.features.length) {

          for (k = 0, l = layer.features.length; k < l; k += 1) {
            feature = layer.features[k];
            vectorFeatureData.push({
              "feature": feature.fid,
              "attributes": feature.attributes
            });
          }

        }
      }

      message = {
        "type": "mapInitialized",
        "vectorLayers": vectorLayerData
      };

      if (vectorFeatureData.length > 0) {
        message.visibleLayerFeatures = vectorFeatureData;
      }

      NK.functions.postMessage(message);
    }());

  }
  map.addControl(new OpenLayers.Control.Attribution());

};
// end init()


var addEvent = function(event, handler) {
  var listen = window.addEventListener || window.attachEvent;
  if (window.addEventListener) {
    listen(event, handler, false);
  } else {
    listen("on" + event, handler);
  }
};

var cb = function(response, status, request) {
  NK.gkToken = request.responseText.replace(/[\"\r\n]/g, '');
};
var startTicket = function(response, status, request) {
  NK.encTicket = request.responseText.replace(/[\"\r\n]/g, '');
  NK.init();
};

var initializeToken = function () {
  $.ajax({
    url: NK.ticketService,
    success: startTicket,
    type: 'GET'
  });
  $.ajax({
    url: NK.tokenService, 
    success: cb,
    type: 'GET'
  });
};
addEvent('load', initializeToken);

